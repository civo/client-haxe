-- Generated by Haxe 4.0.2
local _hx_array_mt = {
  __newindex = function(t,k,v)
    local len = t.length
    t.length =  k >= len and (k + 1) or len
    rawset(t,k,v)
  end
}

local function _hx_tab_array(tab,length)
  tab.length = length
  return setmetatable(tab, _hx_array_mt)
end

local function _hx_anon_newindex(t,k,v) t.__fields__[k] = true; rawset(t,k,v); end
local _hx_anon_mt = {__newindex=_hx_anon_newindex}
local function _hx_a(...)
  local __fields__ = {};
  local ret = {__fields__ = __fields__};
  local max = select('#',...);
  local tab = {...};
  local cur = 1;
  while cur < max do
    local v = tab[cur];
    __fields__[v] = true;
    ret[v] = tab[cur+1];
    cur = cur + 2
  end
  return setmetatable(ret, _hx_anon_mt)
end

local function _hx_e()
  return setmetatable({__fields__ = {}}, _hx_anon_mt)
end

local function _hx_o(obj)
  return setmetatable(obj, _hx_anon_mt)
end

local function _hx_new(prototype)
  return setmetatable({__fields__ = {}}, {__newindex=_hx_anon_newindex, __index=prototype})
end

local _hxClasses = {}
local Int = _hx_e();
local Dynamic = _hx_e();
local Float = _hx_e();
local Bool = _hx_e();
local Class = _hx_e();
local Enum = _hx_e();

local _hx_exports = _hx_exports or {}
_hx_exports["civo"] = _hx_exports["civo"] or _hx_e()
_hx_exports["civo"]["net"] = _hx_exports["civo"]["net"] or _hx_e()
local Array = _hx_e()
local Civo = _hx_e()
local Date = _hx_e()
__lua_lib_lrexlib_Rex = _G.require("rex_pcre")
__lua_lib_luautf8_Utf8 = _G.require("lua-utf8")
local EReg = _hx_e()
local Lambda = _hx_e()
local Math = _hx_e()
local Reflect = _hx_e()
local String = _hx_e()
local Std = _hx_e()
local StringBuf = _hx_e()
__haxe_SysTools = _hx_e()
local StringTools = _hx_e()
local Sys = _hx_e()
local ValueType = _hx_e()
local Type = _hx_e()
__civo_Charges = _hx_e()
__civo_Dns = _hx_e()
__civo_Firewalls = _hx_e()
__civo_Instances = _hx_e()
__civo_Kubernetes = _hx_e()
__civo_LoadBalancers = _hx_e()
__civo_Networks = _hx_e()
__civo_Quota = _hx_e()
__civo_Regions = _hx_e()
__civo_Snapshots = _hx_e()
__civo_Ssh = _hx_e()
__civo_Templates = _hx_e()
__civo_Volumes = _hx_e()
__civo_Webhooks = _hx_e()
__civo_net_CivoHttp = _hx_e()
__haxe_StackItem = _hx_e()
__haxe_IMap = _hx_e()
__haxe_EntryPoint = _hx_e()
__haxe_Json = _hx_e()
__haxe_MainEvent = _hx_e()
__haxe_MainLoop = _hx_e()
__haxe_Timer = _hx_e()
__haxe_io_Bytes = _hx_e()
__haxe_ds_BalancedTree = _hx_e()
__haxe_ds_TreeNode = _hx_e()
__haxe_ds_EnumValueMap = _hx_e()
__haxe_ds_Option = _hx_e()
__haxe_ds_StringMap = _hx_e()
__haxe_format_JsonParser = _hx_e()
__haxe_format_JsonPrinter = _hx_e()
__haxe_http_HttpBase = _hx_e()
__haxe_io_BytesBuffer = _hx_e()
__haxe_io_Input = _hx_e()
__haxe_io_Output = _hx_e()
__haxe_io_BytesOutput = _hx_e()
__haxe_io_Encoding = _hx_e()
__haxe_io_Eof = _hx_e()
__haxe_io_Error = _hx_e()
__httpstatus__HttpStatusMessage_HttpStatusMessage_Impl_ = _hx_e()
__lua_Boot = _hx_e()
__lua_UserData = _hx_e()
__lua_Thread = _hx_e()
__lua_lib_luasocket_Socket = _G.require("socket")
__lua_lib_luv_Loop = _G.require("luv")
__lua_lib_luv_Pipe = _G.require("luv")
__lua_lib_luv_Process = _G.require("luv")
__lua_lib_luv_fs_FileSystem = _G.require("luv")
__lua_lib_luv_net_Dns = _G.require("luv")
__sys_FileSystem = _hx_e()
__sys_Http = _hx_e()
__sys_io_Process = _hx_e()
__sys_io__Process_ProcessInput = _hx_e()
__sys_io__Process_ProcessOutput = _hx_e()
__sys_net_Host = _hx_e()
__sys_net_Socket = _hx_e()
__sys_net__Socket_SocketInput = _hx_e()
__sys_net__Socket_SocketOutput = _hx_e()
__tink_chunk_ChunkBase = _hx_e()
__tink_chunk_ChunkObject = _hx_e()
__tink__Chunk_EmptyChunk = _hx_e()
__tink__Chunk_CompoundChunk = _hx_e()
__tink__Chunk_Chunk_Impl_ = _hx_e()
__tink__Url_Url_Impl_ = _hx_e()
__tink_chunk_ByteChunk = _hx_e()
__tink_chunk_ChunkCursor = _hx_e()
__tink_core__Callback_Callback_Impl_ = _hx_e()
__tink_core_LinkObject = _hx_e()
__tink_core__Callback_ListCell = _hx_e()
__tink_core__Callback_CallbackList_Impl_ = _hx_e()
__tink_core_TypedError = _hx_e()
__tink_core__Future_FutureObject = _hx_e()
__tink_core_Noise = _hx_e()
__tink_core__Lazy_LazyObject = _hx_e()
__tink_core__Lazy_LazyConst = _hx_e()
__tink_core__Future_SyncFuture = _hx_e()
__tink_core__Future_Future_Impl_ = _hx_e()
__tink_core__Future_SimpleFuture = _hx_e()
__tink_core__Future_NestedFuture = _hx_e()
__tink_core_FutureTrigger = _hx_e()
__tink_core__Future_LazyTrigger = _hx_e()
__tink_core__Lazy_LazyFunc = _hx_e()
__tink_core_NamedWith = _hx_e()
__tink_core_Outcome = _hx_e()
__tink_core_MPair = _hx_e()
__tink_core__Promise_Promise_Impl_ = _hx_e()
__tink_io_StreamParserObject = _hx_e()
__tink_http_ClientObject = _hx_e()
__tink_http__Client_CustomClient = _hx_e()
__tink_http_Container = _hx_e()
__tink_http_Fetch = _hx_e()
__tink_http_ClientType = _hx_e()
__tink_http__Fetch_FetchResponse_Impl_ = _hx_e()
__tink_http_HandlerObject = _hx_e()
__tink_http_Header = _hx_e()
__tink_http__Header_HeaderValue_Impl_ = _hx_e()
__tink_http_HeaderField = _hx_e()
__tink_io_BytewiseParser = _hx_e()
__tink_io_ParseStep = _hx_e()
__tink_http_HeaderParser = _hx_e()
__tink_http_Message = _hx_e()
__tink_http_RequestHeader = _hx_e()
__tink_http_IncomingRequestHeader = _hx_e()
__tink_http_OutgoingRequestHeader = _hx_e()
__tink_http_OutgoingRequest = _hx_e()
__tink_http_IncomingRequest = _hx_e()
__tink_http_IncomingRequestBody = _hx_e()
__tink_http_ResponseHeaderBase = _hx_e()
__tink_http__Response_OutgoingResponseData = _hx_e()
__tink_http_IncomingResponse = _hx_e()
__tink_http_BodyPart = _hx_e()
__tink_http_clients_CurlClient = _hx_e()
__tink_http_clients_LocalContainerClient = _hx_e()
__tink_http_clients_SecureCurlClient = _hx_e()
__tink_http_clients_SocketClient = _hx_e()
__tink_http_clients_SecureSocketClient = _hx_e()
__tink_http_clients_StdClient = _hx_e()
__tink_http_containers_LocalContainer = _hx_e()
__tink_io_PipeResult = _hx_e()
__tink_io_PipeResultTools = _hx_e()
__tink_io_SinkObject = _hx_e()
__tink_io_SinkBase = _hx_e()
__tink_io__Sink_SinkYielding_Impl_ = _hx_e()
__tink_streams_StreamObject = _hx_e()
__tink_streams_StreamBase = _hx_e()
__tink_streams_Empty = _hx_e()
__tink_io__Source_Source_Impl_ = _hx_e()
__tink_io_RealSourceTools = _hx_e()
__tink_io_IdealSourceTools = _hx_e()
__tink_io_ParseResult = _hx_e()
__tink_io__StreamParser_StreamParser_Impl_ = _hx_e()
__tink_io_WorkerObject = _hx_e()
__tink_io__Worker_EagerWorker = _hx_e()
__tink_io__Worker_Worker_Impl_ = _hx_e()
__tink_streams_Generator = _hx_e()
__tink_io_std_InputSource = _hx_e()
__tink_io_std_OutputSink = _hx_e()
__tink_streams__Stream_Stream_Impl_ = _hx_e()
__tink_streams_RegroupStatus = _hx_e()
__tink_streams_RegroupResult = _hx_e()
__tink_streams__Stream_Regrouper_Impl_ = _hx_e()
__tink_streams__Stream_CompoundStream = _hx_e()
__tink_streams__Stream_RegroupStream = _hx_e()
__tink_streams_Handled = _hx_e()
__tink_streams_Conclusion = _hx_e()
__tink_streams_ReductionStep = _hx_e()
__tink_streams_Reduction = _hx_e()
__tink_streams__Stream_CloggedStream = _hx_e()
__tink_streams__Stream_ErrorStream = _hx_e()
__tink_streams_Single = _hx_e()
__tink_streams__Stream_Handler_Impl_ = _hx_e()
__tink_streams__Stream_Reducer_Impl_ = _hx_e()
__tink_streams_FutureStream = _hx_e()
__tink_streams_Step = _hx_e()
__tink_url__Host_Host_Impl_ = _hx_e()
__tink_url__Path_Path_Impl_ = _hx_e()

local _hx_bind, _hx_bit, _hx_staticToInstance, _hx_funcToField, _hx_maxn, _hx_print, _hx_apply_self, _hx_box_mr, _hx_bit_clamp, _hx_table, _hx_bit_raw
local _hx_pcall_default = {};
local _hx_pcall_break = {};

Array.new = function() 
  local self = _hx_new(Array.prototype)
  Array.super(self)
  return self
end
Array.super = function(self) 
  _hx_tab_array(self, 0);
end
Array.__name__ = true
Array.prototype = _hx_a();
Array.prototype.length= nil;
Array.prototype.concat = function(self,a) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do 
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  local ret = _g;
  local _g3 = 0;
  while (_g3 < a.length) do 
    local i1 = a[_g3];
    _g3 = _g3 + 1;
    ret:push(i1);
  end;
  do return ret end
end
Array.prototype.join = function(self,sep) 
  local tbl = ({});
  local _gthis = self;
  local cur_length = 0;
  local i = _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self) 
    do return cur_length < _gthis.length end;
  end,next=function(self) 
    cur_length = cur_length + 1;
    do return _gthis[cur_length - 1] end;
  end});
  while (i:hasNext()) do 
    local i1 = i:next();
    _G.table.insert(tbl, Std.string(i1));
  end;
  do return _G.table.concat(tbl, sep) end
end
Array.prototype.pop = function(self) 
  if (self.length == 0) then 
    do return nil end;
  end;
  local ret = self[self.length - 1];
  self[self.length - 1] = nil;
  self.length = self.length - 1;
  do return ret end
end
Array.prototype.push = function(self,x) 
  self[self.length] = x;
  do return self.length end
end
Array.prototype.reverse = function(self) 
  local tmp;
  local i = 0;
  while (i < Std.int(self.length / 2)) do 
    tmp = self[i];
    self[i] = self[(self.length - i) - 1];
    self[(self.length - i) - 1] = tmp;
    i = i + 1;
  end;
end
Array.prototype.shift = function(self) 
  if (self.length == 0) then 
    do return nil end;
  end;
  local ret = self[0];
  if (self.length == 1) then 
    self[0] = nil;
  else
    if (self.length > 1) then 
      self[0] = self[1];
      _G.table.remove(self, 1);
    end;
  end;
  local tmp = self;
  tmp.length = tmp.length - 1;
  do return ret end
end
Array.prototype.slice = function(self,pos,_end) 
  if ((_end == nil) or (_end > self.length)) then 
    _end = self.length;
  else
    if (_end < 0) then 
      _end = _G.math.fmod((self.length - (_G.math.fmod(-_end, self.length))), self.length);
    end;
  end;
  if (pos < 0) then 
    pos = _G.math.fmod((self.length - (_G.math.fmod(-pos, self.length))), self.length);
  end;
  if ((pos > _end) or (pos > self.length)) then 
    do return _hx_tab_array({}, 0) end;
  end;
  local ret = _hx_tab_array({}, 0);
  local _g = pos;
  local _g1 = _end;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    ret:push(self[i]);
  end;
  do return ret end
end
Array.prototype.sort = function(self,f) 
  local i = 0;
  local l = self.length;
  while (i < l) do 
    local swap = false;
    local j = 0;
    local max = (l - i) - 1;
    while (j < max) do 
      if (f(self[j], self[j + 1]) > 0) then 
        local tmp = self[j + 1];
        self[j + 1] = self[j];
        self[j] = tmp;
        swap = true;
      end;
      j = j + 1;
    end;
    if (not swap) then 
      break;
    end;
    i = i + 1;
  end;
end
Array.prototype.splice = function(self,pos,len) 
  if ((len < 0) or (pos > self.length)) then 
    do return _hx_tab_array({}, 0) end;
  else
    if (pos < 0) then 
      pos = self.length - (_G.math.fmod(-pos, self.length));
    end;
  end;
  len = Math.min(len, self.length - pos);
  local ret = _hx_tab_array({}, 0);
  local _g = pos;
  local _g1 = pos + len;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    ret:push(self[i]);
    self[i] = self[i + len];
  end;
  local _g2 = pos + len;
  local _g3 = self.length;
  while (_g2 < _g3) do 
    _g2 = _g2 + 1;
    local i1 = _g2 - 1;
    self[i1] = self[i1 + len];
  end;
  local tmp = self;
  tmp.length = tmp.length - len;
  do return ret end
end
Array.prototype.toString = function(self) 
  local tbl = ({});
  _G.table.insert(tbl, "[");
  _G.table.insert(tbl, self:join(","));
  _G.table.insert(tbl, "]");
  do return _G.table.concat(tbl, "") end
end
Array.prototype.unshift = function(self,x) 
  local len = self.length;
  local _g = 0;
  local _g1 = len;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    self[len - i] = self[(len - i) - 1];
  end;
  self[0] = x;
end
Array.prototype.insert = function(self,pos,x) 
  if (pos > self.length) then 
    pos = self.length;
  end;
  if (pos < 0) then 
    pos = self.length + pos;
    if (pos < 0) then 
      pos = 0;
    end;
  end;
  local cur_len = self.length;
  while (cur_len > pos) do 
    self[cur_len] = self[cur_len - 1];
    cur_len = cur_len - 1;
  end;
  self[pos] = x;
end
Array.prototype.remove = function(self,x) 
  local _g = 0;
  local _g1 = self.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    if (self[i] == x) then 
      local _g2 = i;
      local _g11 = self.length - 1;
      while (_g2 < _g11) do 
        _g2 = _g2 + 1;
        local j = _g2 - 1;
        self[j] = self[j + 1];
      end;
      self[self.length - 1] = nil;
      self.length = self.length - 1;
      do return true end;
    end;
  end;
  do return false end
end
Array.prototype.indexOf = function(self,x,fromIndex) 
  local _end = self.length;
  if (fromIndex == nil) then 
    fromIndex = 0;
  else
    if (fromIndex < 0) then 
      fromIndex = self.length + fromIndex;
      if (fromIndex < 0) then 
        fromIndex = 0;
      end;
    end;
  end;
  local _g = fromIndex;
  local _g1 = _end;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    if (x == self[i]) then 
      do return i end;
    end;
  end;
  do return -1 end
end
Array.prototype.lastIndexOf = function(self,x,fromIndex) 
  if ((fromIndex == nil) or (fromIndex >= self.length)) then 
    fromIndex = self.length - 1;
  else
    if (fromIndex < 0) then 
      fromIndex = self.length + fromIndex;
      if (fromIndex < 0) then 
        do return -1 end;
      end;
    end;
  end;
  local i = fromIndex;
  while (i >= 0) do 
    if (self[i] == x) then 
      do return i end;
    else
      i = i - 1;
    end;
  end;
  do return -1 end
end
Array.prototype.copy = function(self) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do 
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  do return _g end
end
Array.prototype.map = function(self,f) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do 
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(f(i));
  end;
  do return _g end
end
Array.prototype.filter = function(self,f) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do 
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    if (f(i)) then 
      _g:push(i);
    end;
  end;
  do return _g end
end
Array.prototype.iterator = function(self) 
  local _gthis = self;
  local cur_length = 0;
  do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self) 
    do return cur_length < _gthis.length end;
  end,next=function(self) 
    cur_length = cur_length + 1;
    do return _gthis[cur_length - 1] end;
  end}) end
end
Array.prototype.resize = function(self,len) 
  if (self.length < len) then 
    self.length = len;
  else
    if (self.length > len) then 
      local _g = len;
      local _g1 = self.length;
      while (_g < _g1) do 
        _g = _g + 1;
        local i = _g - 1;
        self[i] = nil;
      end;
      self.length = len;
    end;
  end;
end

Array.prototype.__class__ =  Array

Civo.new = {}
Civo.__name__ = true
Civo.main = function() 
end

Date.new = function(year,month,day,hour,min,sec) 
  local self = _hx_new(Date.prototype)
  Date.super(self,year,month,day,hour,min,sec)
  return self
end
Date.super = function(self,year,month,day,hour,min,sec) 
  self.t = _G.os.time(_hx_o({__fields__={year=true,month=true,day=true,hour=true,min=true,sec=true},year=year,month=month + 1,day=day,hour=hour,min=min,sec=sec}));
  self.d = _G.os.date("*t", self.t);
  self.dUTC = _G.os.date("!*t", self.t);
end
Date.__name__ = true
Date.prototype = _hx_a();
Date.prototype.d= nil;
Date.prototype.dUTC= nil;
Date.prototype.t= nil;
Date.prototype.getHours = function(self) 
  do return self.d.hour end
end
Date.prototype.getMinutes = function(self) 
  do return self.d.min end
end
Date.prototype.getSeconds = function(self) 
  do return self.d.sec end
end
Date.prototype.getFullYear = function(self) 
  do return self.d.year end
end
Date.prototype.getMonth = function(self) 
  do return self.d.month - 1 end
end
Date.prototype.getDate = function(self) 
  do return self.d.day end
end

Date.prototype.__class__ =  Date

EReg.new = function(r,opt) 
  local self = _hx_new(EReg.prototype)
  EReg.super(self,r,opt)
  return self
end
EReg.super = function(self,r,opt) 
  local ropt = 0;
  local _g = 0;
  local _g1 = __lua_lib_luautf8_Utf8.len(opt);
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local _g2 = __lua_lib_luautf8_Utf8.sub(opt, i + 1, i + 1);
    if (_g2) == "g" then 
      self.global = true;
    elseif (_g2) == "i" then 
      ropt = _hx_bit.bor(ropt,EReg.FLAGS.CASELESS);
    elseif (_g2) == "m" then 
      ropt = _hx_bit.bor(ropt,EReg.FLAGS.MULTILINE);
    elseif (_g2) == "s" then 
      ropt = _hx_bit.bor(ropt,EReg.FLAGS.DOTALL);else end;
  end;
  ropt = _hx_bit.bor(ropt,EReg.FLAGS.UTF8);
  ropt = _hx_bit.bor(ropt,EReg.FLAGS.UCP);
  if (self.global == nil) then 
    self.global = false;
  end;
  self.r = __lua_lib_lrexlib_Rex.new(r, ropt);
end
EReg.__name__ = true
EReg.prototype = _hx_a();
EReg.prototype.r= nil;
EReg.prototype.global= nil;
EReg.prototype.s= nil;
EReg.prototype.m= nil;
EReg.prototype.match = function(self,s) 
  if (s == nil) then 
    do return false end;
  else
    self.m = _hx_table.pack(self.r:exec(s, 1));
    self.s = s;
    do return self.m[1] ~= nil end;
  end;
end
EReg.prototype.matched = function(self,n) 
  if ((self.m[1] == nil) or (n < 0)) then 
    _G.error("EReg::matched",0);
  else
    if (n == 0) then 
      local k = _G.string.sub(self.s, self.m[1], self.m[2]);
      do return k end;
    else
      if (__lua_Boot.__instanceof(self.m[3], _G.table)) then 
        local mn = 2 * (n - 1);
        if (__lua_Boot.__instanceof(self.m[3][mn + 1], Bool)) then 
          do return nil end;
        end;
        do return _G.string.sub(self.s, self.m[3][mn + 1], self.m[3][mn + 2]) end;
      else
        _G.error("EReg:matched",0);
      end;
    end;
  end;
end
EReg.prototype.matchedLeft = function(self) 
  if (self.m[1] == nil) then 
    _G.error("No string matched",0);
  end;
  do return _G.string.sub(self.s, 1, self.m[1] - 1) end
end
EReg.prototype.matchedPos = function(self) 
  local left = self:matchedLeft();
  local matched = self:matched(0);
  if (self.m[1] == nil) then 
    _G.error("No string matched",0);
  end;
  do return _hx_o({__fields__={pos=true,len=true},pos=__lua_lib_luautf8_Utf8.len(left),len=__lua_lib_luautf8_Utf8.len(matched)}) end
end

EReg.prototype.__class__ =  EReg

Lambda.new = {}
Lambda.__name__ = true
Lambda.has = function(it,elt) 
  local x = it:iterator();
  while (x:hasNext()) do 
    local x1 = x:next();
    if (x1 == elt) then 
      do return true end;
    end;
  end;
  do return false end;
end
Lambda.exists = function(it,f) 
  local x = it:iterator();
  while (x:hasNext()) do 
    local x1 = x:next();
    if (f(x1)) then 
      do return true end;
    end;
  end;
  do return false end;
end

Math.new = {}
Math.__name__ = true
Math.isNaN = function(f) 
  do return f ~= f end;
end
Math.isFinite = function(f) 
  if (f > -_G.math.huge) then 
    do return f < _G.math.huge end;
  else
    do return false end;
  end;
end
Math.min = function(a,b) 
  if (Math.isNaN(a) or Math.isNaN(b)) then 
    do return (0/0) end;
  else
    do return _G.math.min(a, b) end;
  end;
end

Reflect.new = {}
Reflect.__name__ = true
Reflect.field = function(o,field) 
  if (_G.type(o) == "string") then 
    if (field == "length") then 
      do return _hx_wrap_if_string_field(o,'length') end;
    else
      do return String.prototype[field] end;
    end;
  else
    local _hx_status, _hx_result = pcall(function() 
    
        do return o[field] end;
      return _hx_pcall_default
    end)
    if not _hx_status and _hx_result == "_hx_pcall_break" then
    elseif not _hx_status then 
    
      local _hx_1 = _hx_result
      local e = _hx_1
      do return nil end;
    elseif _hx_result ~= _hx_pcall_default then
      return _hx_result
    end;
  end;
end
Reflect.fields = function(o) 
  if (_G.type(o) == "string") then 
    do return Reflect.fields(String.prototype) end;
  else
    local _g = _hx_tab_array({}, 0);
    local f = __lua_Boot.fieldIterator(o);
    while (f:hasNext()) do 
      local f1 = f:next();
      _g:push(f1);
    end;
    do return _g end;
  end;
end
Reflect.isFunction = function(f) 
  if (_G.type(f) == "function") then 
    do return not ((function() 
      local _hx_1
      if (_G.type(f) ~= "table") then 
      _hx_1 = false; else 
      _hx_1 = f.__name__; end
      return _hx_1
    end )() or (function() 
      local _hx_2
      if (_G.type(f) ~= "table") then 
      _hx_2 = false; else 
      _hx_2 = f.__ename__; end
      return _hx_2
    end )()) end;
  else
    do return false end;
  end;
end
Reflect.compare = function(a,b) 
  if (a == b) then 
    do return 0 end;
  else
    if (a == nil) then 
      do return -1 end;
    else
      if (b == nil) then 
        do return 1 end;
      else
        if (a > b) then 
          do return 1 end;
        else
          do return -1 end;
        end;
      end;
    end;
  end;
end
Reflect.compareMethods = function(f1,f2) 
  do return f1 == f2 end;
end
Reflect.isEnumValue = function(v) 
  if ((v ~= nil) and __lua_Boot.__instanceof(v, _G.table)) then 
    do return v.__enum__ ~= nil end;
  else
    do return false end;
  end;
end
Reflect.copy = function(o) 
  if (o == nil) then 
    do return nil end;
  end;
  local o2 = _hx_e();
  local _g = 0;
  local _g1 = Reflect.fields(o);
  while (_g < _g1.length) do 
    local f = _g1[_g];
    _g = _g + 1;
    o2[f] = Reflect.field(o, f);
  end;
  do return o2 end;
end

String.new = function(string) 
  local self = _hx_new(String.prototype)
  String.super(self,string)
  self = string
  return self
end
String.super = function(self,string) 
end
String.__name__ = true
String.__index = function(s,k) 
  if (k == "length") then 
    do return __lua_lib_luautf8_Utf8.len(s) end;
  else
    local o = String.prototype;
    local field = k;
    if ((function() 
      local _hx_1
      if ((_G.type(o) == "string") and ((String.prototype[field] ~= nil) or (field == "length"))) then 
      _hx_1 = true; elseif (o.__fields__ ~= nil) then 
      _hx_1 = o.__fields__[field] ~= nil; else 
      _hx_1 = o[field] ~= nil; end
      return _hx_1
    end )()) then 
      do return String.prototype[k] end;
    else
      if (String.__oldindex ~= nil) then 
        if (_G.type(String.__oldindex) == "function") then 
          do return String.__oldindex(s, k) end;
        else
          if (_G.type(String.__oldindex) == "table") then 
            do return String.__oldindex[k] end;
          end;
        end;
        do return nil end;
      else
        do return nil end;
      end;
    end;
  end;
end
String.fromCharCode = function(code) 
  do return __lua_lib_luautf8_Utf8.char(code) end;
end
String.prototype = _hx_a();
String.prototype.length= nil;
String.prototype.toUpperCase = function(self) 
  do return __lua_lib_luautf8_Utf8.upper(self) end
end
String.prototype.toLowerCase = function(self) 
  do return __lua_lib_luautf8_Utf8.lower(self) end
end
String.prototype.indexOf = function(self,str,startIndex) 
  if (startIndex == nil) then 
    startIndex = 1;
  else
    startIndex = startIndex + 1;
  end;
  local r = __lua_lib_luautf8_Utf8.find(self, str, startIndex, true);
  if ((r ~= nil) and (r > 0)) then 
    do return r - 1 end;
  else
    do return -1 end;
  end;
end
String.prototype.lastIndexOf = function(self,str,startIndex) 
  local i = 0;
  local ret = -1;
  if (startIndex == nil) then 
    startIndex = __lua_lib_luautf8_Utf8.len(self);
  end;
  while (true) do 
    local startIndex1 = ret + 1;
    if (startIndex1 == nil) then 
      startIndex1 = 1;
    else
      startIndex1 = startIndex1 + 1;
    end;
    local r = __lua_lib_luautf8_Utf8.find(self, str, startIndex1, true);
    local p = (function() 
      local _hx_1
      if ((r ~= nil) and (r > 0)) then 
      _hx_1 = r - 1; else 
      _hx_1 = -1; end
      return _hx_1
    end )();
    if ((p == -1) or (p > startIndex)) then 
      break;
    end;
    ret = p;
  end;
  do return ret end
end
String.prototype.split = function(self,delimiter) 
  local idx = 1;
  local ret = _hx_tab_array({}, 0);
  local delim_offset = (function() 
    local _hx_1
    if (__lua_lib_luautf8_Utf8.len(delimiter) > 0) then 
    _hx_1 = __lua_lib_luautf8_Utf8.len(delimiter); else 
    _hx_1 = 1; end
    return _hx_1
  end )();
  while (idx ~= nil) do 
    local newidx = 0;
    if (__lua_lib_luautf8_Utf8.len(delimiter) > 0) then 
      newidx = __lua_lib_luautf8_Utf8.find(self, delimiter, idx, true);
    else
      if (idx >= __lua_lib_luautf8_Utf8.len(self)) then 
        newidx = nil;
      else
        newidx = idx + 1;
      end;
    end;
    if (newidx ~= nil) then 
      local match = __lua_lib_luautf8_Utf8.sub(self, idx, newidx - 1);
      ret:push(match);
      idx = newidx + __lua_lib_luautf8_Utf8.len(delimiter);
    else
      ret:push(__lua_lib_luautf8_Utf8.sub(self, idx, __lua_lib_luautf8_Utf8.len(self)));
      idx = nil;
    end;
  end;
  do return ret end
end
String.prototype.toString = function(self) 
  do return self end
end
String.prototype.substring = function(self,startIndex,endIndex) 
  if (endIndex == nil) then 
    endIndex = __lua_lib_luautf8_Utf8.len(self);
  end;
  if (endIndex < 0) then 
    endIndex = 0;
  end;
  if (startIndex < 0) then 
    startIndex = 0;
  end;
  if (endIndex < startIndex) then 
    do return __lua_lib_luautf8_Utf8.sub(self, endIndex + 1, startIndex) end;
  else
    do return __lua_lib_luautf8_Utf8.sub(self, startIndex + 1, endIndex) end;
  end;
end
String.prototype.charAt = function(self,index) 
  do return __lua_lib_luautf8_Utf8.sub(self, index + 1, index + 1) end
end
String.prototype.charCodeAt = function(self,index) 
  do return __lua_lib_luautf8_Utf8.byte(self, index + 1) end
end
String.prototype.substr = function(self,pos,len) 
  if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(self)))) then 
    len = __lua_lib_luautf8_Utf8.len(self);
  else
    if (len < 0) then 
      len = __lua_lib_luautf8_Utf8.len(self) + len;
    end;
  end;
  if (pos < 0) then 
    pos = __lua_lib_luautf8_Utf8.len(self) + pos;
  end;
  if (pos < 0) then 
    pos = 0;
  end;
  do return __lua_lib_luautf8_Utf8.sub(self, pos + 1, pos + len) end
end

String.prototype.__class__ =  String

Std.new = {}
Std.__name__ = true
Std.string = function(s) 
  do return __lua_Boot.__string_rec(s) end;
end
Std.int = function(x) 
  if (not Math.isFinite(x) or Math.isNaN(x)) then 
    do return 0 end;
  else
    do return _hx_bit_clamp(x) end;
  end;
end
Std.parseInt = function(x) 
  if (x == nil) then 
    do return nil end;
  end;
  local hexMatch = _G.string.match(x, "^ *[%-+]*0[xX][%da-fA-F]*");
  if (hexMatch ~= nil) then 
    local pos = 2;
    local len = nil;
    if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(hexMatch)))) then 
      len = __lua_lib_luautf8_Utf8.len(hexMatch);
    else
      if (len < 0) then 
        len = __lua_lib_luautf8_Utf8.len(hexMatch) + len;
      end;
    end;
    if (pos < 0) then 
      pos = __lua_lib_luautf8_Utf8.len(hexMatch) + pos;
    end;
    if (pos < 0) then 
      pos = 0;
    end;
    do return _G.tonumber(__lua_lib_luautf8_Utf8.sub(hexMatch, pos + 1, pos + len), 16) end;
  else
    local intMatch = _G.string.match(x, "^ *[%-+]?%d*");
    if (intMatch ~= nil) then 
      do return _G.tonumber(intMatch) end;
    else
      do return nil end;
    end;
  end;
end
Std.parseFloat = function(x) 
  if ((x == nil) or (x == "")) then 
    do return (0/0) end;
  end;
  local digitMatch = _G.string.match(x, "^ *[%.%-+]?[0-9]%d*");
  if (digitMatch == nil) then 
    do return (0/0) end;
  end;
  local pos = __lua_lib_luautf8_Utf8.len(digitMatch);
  local len = nil;
  if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(x)))) then 
    len = __lua_lib_luautf8_Utf8.len(x);
  else
    if (len < 0) then 
      len = __lua_lib_luautf8_Utf8.len(x) + len;
    end;
  end;
  if (pos < 0) then 
    pos = __lua_lib_luautf8_Utf8.len(x) + pos;
  end;
  if (pos < 0) then 
    pos = 0;
  end;
  x = __lua_lib_luautf8_Utf8.sub(x, pos + 1, pos + len);
  local decimalMatch = _G.string.match(x, "^%.%d*");
  if (decimalMatch == nil) then 
    decimalMatch = "";
  end;
  local pos1 = __lua_lib_luautf8_Utf8.len(decimalMatch);
  local len1 = nil;
  if ((len1 == nil) or (len1 > (pos1 + __lua_lib_luautf8_Utf8.len(x)))) then 
    len1 = __lua_lib_luautf8_Utf8.len(x);
  else
    if (len1 < 0) then 
      len1 = __lua_lib_luautf8_Utf8.len(x) + len1;
    end;
  end;
  if (pos1 < 0) then 
    pos1 = __lua_lib_luautf8_Utf8.len(x) + pos1;
  end;
  if (pos1 < 0) then 
    pos1 = 0;
  end;
  x = __lua_lib_luautf8_Utf8.sub(x, pos1 + 1, pos1 + len1);
  local eMatch = _G.string.match(x, "^[eE][+%-]?%d+");
  if (eMatch == nil) then 
    eMatch = "";
  end;
  local result = _G.tonumber(Std.string(Std.string(digitMatch) .. Std.string(decimalMatch)) .. Std.string(eMatch));
  if (result ~= nil) then 
    do return result end;
  else
    do return (0/0) end;
  end;
end
Std.random = function(x) 
  if (x <= 0) then 
    do return 0 end;
  else
    do return _G.math.floor(_G.math.random() * x) end;
  end;
end

StringBuf.new = function() 
  local self = _hx_new(StringBuf.prototype)
  StringBuf.super(self)
  return self
end
StringBuf.super = function(self) 
  self.b = ({});
  self.length = 0;
end
StringBuf.__name__ = true
StringBuf.prototype = _hx_a();
StringBuf.prototype.b= nil;
StringBuf.prototype.length= nil;

StringBuf.prototype.__class__ =  StringBuf

__haxe_SysTools.new = {}
__haxe_SysTools.__name__ = true
__haxe_SysTools.quoteUnixArg = function(argument) 
  if (argument == "") then 
    do return "''" end;
  end;
  if (not EReg.new("[^a-zA-Z0-9_@%+=:,./-]", ""):match(argument)) then 
    do return argument end;
  end;
  do return Std.string(Std.string("'") .. Std.string(StringTools.replace(argument, "'", "'\"'\"'"))) .. Std.string("'") end;
end
__haxe_SysTools.quoteWinArg = function(argument,escapeMetaCharacters) 
  if (not EReg.new("^[^ \t\\\\\"]+$", ""):match(argument)) then 
    local result_b = ({});
    local result_length = 0;
    local needquote;
    local startIndex = nil;
    if (startIndex == nil) then 
      startIndex = 1;
    else
      startIndex = startIndex + 1;
    end;
    local r = __lua_lib_luautf8_Utf8.find(argument, " ", startIndex, true);
    if ((function() 
      local _hx_1
      if ((r ~= nil) and (r > 0)) then 
      _hx_1 = r - 1; else 
      _hx_1 = -1; end
      return _hx_1
    end )() == -1) then 
      local startIndex1 = nil;
      if (startIndex1 == nil) then 
        startIndex1 = 1;
      else
        startIndex1 = startIndex1 + 1;
      end;
      local r1 = __lua_lib_luautf8_Utf8.find(argument, "\t", startIndex1, true);
      needquote = (function() 
        local _hx_2
        if ((r1 ~= nil) and (r1 > 0)) then 
        _hx_2 = r1 - 1; else 
        _hx_2 = -1; end
        return _hx_2
      end )() ~= -1;
    else
      needquote = true;
    end;
    local needquote1 = needquote or (argument == "");
    if (needquote1) then 
      local str = "\"";
      _G.table.insert(result_b, str);
      result_length = result_length + __lua_lib_luautf8_Utf8.len(str);
    end;
    local bs_buf = StringBuf.new();
    local _g = 0;
    local _g1 = __lua_lib_luautf8_Utf8.len(argument);
    while (_g < _g1) do 
      _g = _g + 1;
      local i = _g - 1;
      local _g2 = __lua_lib_luautf8_Utf8.byte(argument, i + 1);
      local _g3 = _g2;
      if (_g3) == 34 then 
        local bs = _G.table.concat(bs_buf.b);
        local str1 = Std.string(bs);
        _G.table.insert(result_b, str1);
        result_length = result_length + __lua_lib_luautf8_Utf8.len(str1);
        local str2 = Std.string(bs);
        _G.table.insert(result_b, str2);
        result_length = result_length + __lua_lib_luautf8_Utf8.len(str2);
        bs_buf = StringBuf.new();
        local str3 = "\\\"";
        _G.table.insert(result_b, str3);
        result_length = result_length + __lua_lib_luautf8_Utf8.len(str3);
      elseif (_g3) == 92 then 
        local str4 = "\\";
        _G.table.insert(bs_buf.b, str4);
        local bs_buf1 = bs_buf;
        bs_buf1.length = bs_buf1.length + __lua_lib_luautf8_Utf8.len(str4);else
      local c = _g2;
      if (bs_buf.length > 0) then 
        local str5 = Std.string(_G.table.concat(bs_buf.b));
        _G.table.insert(result_b, str5);
        result_length = result_length + __lua_lib_luautf8_Utf8.len(str5);
        bs_buf = StringBuf.new();
      end;
      _G.table.insert(result_b, __lua_lib_luautf8_Utf8.char(c));
      result_length = result_length + 1; end;
    end;
    local str6 = Std.string(_G.table.concat(bs_buf.b));
    _G.table.insert(result_b, str6);
    result_length = result_length + __lua_lib_luautf8_Utf8.len(str6);
    if (needquote1) then 
      local str7 = Std.string(_G.table.concat(bs_buf.b));
      _G.table.insert(result_b, str7);
      result_length = result_length + __lua_lib_luautf8_Utf8.len(str7);
      local str8 = "\"";
      _G.table.insert(result_b, str8);
      result_length = result_length + __lua_lib_luautf8_Utf8.len(str8);
    end;
    argument = _G.table.concat(result_b);
  end;
  if (escapeMetaCharacters) then 
    local result_b1 = ({});
    local result_length1 = 0;
    local _g4 = 0;
    local _g11 = __lua_lib_luautf8_Utf8.len(argument);
    while (_g4 < _g11) do 
      _g4 = _g4 + 1;
      local i1 = _g4 - 1;
      local c1 = __lua_lib_luautf8_Utf8.byte(argument, i1 + 1);
      if (__haxe_SysTools.winMetaCharacters:indexOf(c1) >= 0) then 
        _G.table.insert(result_b1, __lua_lib_luautf8_Utf8.char(94));
        result_length1 = result_length1 + 1;
      end;
      _G.table.insert(result_b1, __lua_lib_luautf8_Utf8.char(c1));
      result_length1 = result_length1 + 1;
    end;
    do return _G.table.concat(result_b1) end;
  else
    do return argument end;
  end;
end

StringTools.new = {}
StringTools.__name__ = true
StringTools.urlEncode = function(s) 
  s = _G.string.gsub(s, "\n", "\r\n");
  s = _G.string.gsub(s, "([^%w %-%_%.%~])", function(c) 
    do return _G.string.format("%%%02X", Std.string(_G.string.byte(c)) .. Std.string("")) end;
  end);
  s = _G.string.gsub(s, " ", "+");
  do return s end;
end
StringTools.startsWith = function(s,start) 
  if (__lua_lib_luautf8_Utf8.len(s) >= __lua_lib_luautf8_Utf8.len(start)) then 
    local startIndex = 0;
    local ret = -1;
    if (startIndex == nil) then 
      startIndex = __lua_lib_luautf8_Utf8.len(s);
    end;
    while (true) do 
      local startIndex1 = ret + 1;
      if (startIndex1 == nil) then 
        startIndex1 = 1;
      else
        startIndex1 = startIndex1 + 1;
      end;
      local r = __lua_lib_luautf8_Utf8.find(s, start, startIndex1, true);
      local p = (function() 
        local _hx_1
        if ((r ~= nil) and (r > 0)) then 
        _hx_1 = r - 1; else 
        _hx_1 = -1; end
        return _hx_1
      end )();
      if ((p == -1) or (p > startIndex)) then 
        break;
      end;
      ret = p;
    end;
    do return ret == 0 end;
  else
    do return false end;
  end;
end
StringTools.endsWith = function(s,_end) 
  local elen = __lua_lib_luautf8_Utf8.len(_end);
  local slen = __lua_lib_luautf8_Utf8.len(s);
  if (slen >= elen) then 
    local startIndex = slen - elen;
    if (startIndex == nil) then 
      startIndex = 1;
    else
      startIndex = startIndex + 1;
    end;
    local r = __lua_lib_luautf8_Utf8.find(s, _end, startIndex, true);
    do return (function() 
      local _hx_1
      if ((r ~= nil) and (r > 0)) then 
      _hx_1 = r - 1; else 
      _hx_1 = -1; end
      return _hx_1
    end )() == (slen - elen) end;
  else
    do return false end;
  end;
end
StringTools.isSpace = function(s,pos) 
  if (((__lua_lib_luautf8_Utf8.len(s) == 0) or (pos < 0)) or (pos >= __lua_lib_luautf8_Utf8.len(s))) then 
    do return false end;
  end;
  local c = __lua_lib_luautf8_Utf8.byte(s, pos + 1);
  if (not ((c > 8) and (c < 14))) then 
    do return c == 32 end;
  else
    do return true end;
  end;
end
StringTools.ltrim = function(s) 
  local l = __lua_lib_luautf8_Utf8.len(s);
  local r = 0;
  while ((r < l) and StringTools.isSpace(s, r)) do 
    r = r + 1;
  end;
  if (r > 0) then 
    local pos = r;
    local len = l - r;
    if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(s)))) then 
      len = __lua_lib_luautf8_Utf8.len(s);
    else
      if (len < 0) then 
        len = __lua_lib_luautf8_Utf8.len(s) + len;
      end;
    end;
    if (pos < 0) then 
      pos = __lua_lib_luautf8_Utf8.len(s) + pos;
    end;
    if (pos < 0) then 
      pos = 0;
    end;
    do return __lua_lib_luautf8_Utf8.sub(s, pos + 1, pos + len) end;
  else
    do return s end;
  end;
end
StringTools.rtrim = function(s) 
  local l = __lua_lib_luautf8_Utf8.len(s);
  local r = 0;
  while ((r < l) and StringTools.isSpace(s, (l - r) - 1)) do 
    r = r + 1;
  end;
  if (r > 0) then 
    local pos = 0;
    local len = l - r;
    if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(s)))) then 
      len = __lua_lib_luautf8_Utf8.len(s);
    else
      if (len < 0) then 
        len = __lua_lib_luautf8_Utf8.len(s) + len;
      end;
    end;
    if (pos < 0) then 
      pos = __lua_lib_luautf8_Utf8.len(s) + pos;
    end;
    if (pos < 0) then 
      pos = 0;
    end;
    do return __lua_lib_luautf8_Utf8.sub(s, pos + 1, pos + len) end;
  else
    do return s end;
  end;
end
StringTools.trim = function(s) 
  do return StringTools.ltrim(StringTools.rtrim(s)) end;
end
StringTools.lpad = function(s,c,l) 
  if (__lua_lib_luautf8_Utf8.len(c) <= 0) then 
    do return s end;
  end;
  local buf_b = ({});
  local buf_length = 0;
  l = l - __lua_lib_luautf8_Utf8.len(s);
  while (buf_length < l) do 
    local str = Std.string(c);
    _G.table.insert(buf_b, str);
    buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
  end;
  local str1 = Std.string(s);
  _G.table.insert(buf_b, str1);
  buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str1);
  do return _G.table.concat(buf_b) end;
end
StringTools.replace = function(s,sub,by) 
  local idx = 1;
  local ret = _hx_tab_array({}, 0);
  local delim_offset = (function() 
    local _hx_1
    if (__lua_lib_luautf8_Utf8.len(sub) > 0) then 
    _hx_1 = __lua_lib_luautf8_Utf8.len(sub); else 
    _hx_1 = 1; end
    return _hx_1
  end )();
  while (idx ~= nil) do 
    local newidx = 0;
    if (__lua_lib_luautf8_Utf8.len(sub) > 0) then 
      newidx = __lua_lib_luautf8_Utf8.find(s, sub, idx, true);
    else
      if (idx >= __lua_lib_luautf8_Utf8.len(s)) then 
        newidx = nil;
      else
        newidx = idx + 1;
      end;
    end;
    if (newidx ~= nil) then 
      local match = __lua_lib_luautf8_Utf8.sub(s, idx, newidx - 1);
      ret:push(match);
      idx = newidx + __lua_lib_luautf8_Utf8.len(sub);
    else
      ret:push(__lua_lib_luautf8_Utf8.sub(s, idx, __lua_lib_luautf8_Utf8.len(s)));
      idx = nil;
    end;
  end;
  do return ret:join(by) end;
end

Sys.new = {}
Sys.__name__ = true
Sys.getSystemName = function() 
  do return __lua_Boot.systemName() end;
end
Sys.systemName = function() 
  if (Sys._system_name == nil) then 
    Sys._system_name = Sys.getSystemName();
  end;
  do return Sys._system_name end;
end
Sys.time = function() 
  do return __lua_lib_luasocket_Socket.gettime() end;
end
_hxClasses["ValueType"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="TNull","TInt","TFloat","TBool","TObject","TFunction","TClass","TEnum","TUnknown"},9)}
ValueType = _hxClasses["ValueType"];
ValueType.TNull = _hx_tab_array({[0]="TNull",0,__enum__ = ValueType},2)

ValueType.TInt = _hx_tab_array({[0]="TInt",1,__enum__ = ValueType},2)

ValueType.TFloat = _hx_tab_array({[0]="TFloat",2,__enum__ = ValueType},2)

ValueType.TBool = _hx_tab_array({[0]="TBool",3,__enum__ = ValueType},2)

ValueType.TObject = _hx_tab_array({[0]="TObject",4,__enum__ = ValueType},2)

ValueType.TFunction = _hx_tab_array({[0]="TFunction",5,__enum__ = ValueType},2)

ValueType.TClass = function(c) local _x = _hx_tab_array({[0]="TClass",6,c,__enum__=ValueType}, 3); return _x; end 
ValueType.TEnum = function(e) local _x = _hx_tab_array({[0]="TEnum",7,e,__enum__=ValueType}, 3); return _x; end 
ValueType.TUnknown = _hx_tab_array({[0]="TUnknown",8,__enum__ = ValueType},2)


Type.new = {}
Type.__name__ = true
Type.getClass = function(o) 
  if (o == nil) then 
    do return nil end;
  end;
  local o1 = o;
  if (__lua_Boot.__instanceof(o1, Array)) then 
    do return Array end;
  else
    if (__lua_Boot.__instanceof(o1, String)) then 
      do return String end;
    else
      local cl = o1.__class__;
      if (cl ~= nil) then 
        do return cl end;
      else
        do return nil end;
      end;
    end;
  end;
end
Type.getInstanceFields = function(c) 
  local p = c.prototype;
  local a = _hx_tab_array({}, 0);
  while (p ~= nil) do 
    local f = __lua_Boot.fieldIterator(p);
    while (f:hasNext()) do 
      local f1 = f:next();
      if (not Lambda.has(a, f1)) then 
        a:push(f1);
      end;
    end;
    local mt = _G.getmetatable(p);
    if ((mt ~= nil) and (mt.__index ~= nil)) then 
      p = mt.__index;
    else
      p = nil;
    end;
  end;
  do return a end;
end
Type.typeof = function(v) 
  local _g = _G.type(v);
  if (_g) == "boolean" then 
    do return ValueType.TBool end;
  elseif (_g) == "function" then 
    if ((function() 
      local _hx_1
      if (_G.type(v) ~= "table") then 
      _hx_1 = false; else 
      _hx_1 = v.__name__; end
      return _hx_1
    end )() or (function() 
      local _hx_2
      if (_G.type(v) ~= "table") then 
      _hx_2 = false; else 
      _hx_2 = v.__ename__; end
      return _hx_2
    end )()) then 
      do return ValueType.TObject end;
    end;
    do return ValueType.TFunction end;
  elseif (_g) == "nil" then 
    do return ValueType.TNull end;
  elseif (_g) == "number" then 
    if (_G.math.ceil(v) == (_G.math.fmod(v, 2147483648.0))) then 
      do return ValueType.TInt end;
    end;
    do return ValueType.TFloat end;
  elseif (_g) == "string" then 
    do return ValueType.TClass(String) end;
  elseif (_g) == "table" then 
    local e = v.__enum__;
    if (e ~= nil) then 
      do return ValueType.TEnum(e) end;
    end;
    local c;
    if (__lua_Boot.__instanceof(v, Array)) then 
      c = Array;
    else
      if (__lua_Boot.__instanceof(v, String)) then 
        c = String;
      else
        local cl = v.__class__;
        c = (function() 
          local _hx_3
          if (cl ~= nil) then 
          _hx_3 = cl; else 
          _hx_3 = nil; end
          return _hx_3
        end )();
      end;
    end;
    if (c ~= nil) then 
      do return ValueType.TClass(c) end;
    end;
    do return ValueType.TObject end;else
  do return ValueType.TUnknown end; end;
end

__civo_Charges.new = {}
_hx_exports["civo"]["Charges"] = __civo_Charges
__civo_Charges.__name__ = true
__civo_Charges.list = function(token,dateRange,handler) 
  __civo_net_CivoHttp.get(token, __civo_Charges.path, handler, dateRange);
end

__civo_Dns.new = {}
_hx_exports["civo"]["Dns"] = __civo_Dns
__civo_Dns.__name__ = true
__civo_Dns.list_domains = function(token,handler) 
  __civo_net_CivoHttp.get(token, __civo_Dns.path, handler);
end
__civo_Dns.create_domain = function(token,name,handler) 
  __civo_net_CivoHttp.post(token, __civo_Dns.path, handler, _hx_o({__fields__={name=true},name=name}));
end
__civo_Dns.update_domain = function(token,domain_id,domain_name,handler) 
  __civo_net_CivoHttp.put(token, Std.string(Std.string(Std.string("") .. Std.string(__civo_Dns.path)) .. Std.string("/")) .. Std.string(domain_id), handler, _hx_o({__fields__={name=true},name=domain_name}));
end
__civo_Dns.delete_domain = function(token,domain_id,handler) 
  __civo_net_CivoHttp.delete(token, Std.string(Std.string(Std.string("") .. Std.string(__civo_Dns.path)) .. Std.string("/")) .. Std.string(domain_id), handler);
end
__civo_Dns.list_dns = function(token,domain_id,handler) 
  __civo_net_CivoHttp.get(token, Std.string(Std.string(Std.string(Std.string("") .. Std.string(__civo_Dns.path)) .. Std.string("/")) .. Std.string(domain_id)) .. Std.string("/records"), handler);
end
__civo_Dns.create_dns = function(token,domain_id,params,handler) 
  __civo_net_CivoHttp.post(token, Std.string(Std.string(Std.string(Std.string("") .. Std.string(__civo_Dns.path)) .. Std.string("/")) .. Std.string(domain_id)) .. Std.string("/records"), handler, params);
end
__civo_Dns.update_dns = function(token,domain_id,dns_id,params,handler) 
  __civo_net_CivoHttp.put(token, Std.string(Std.string(Std.string(Std.string(Std.string("") .. Std.string(__civo_Dns.path)) .. Std.string("/")) .. Std.string(domain_id)) .. Std.string("/records/")) .. Std.string(dns_id), handler, params);
end
__civo_Dns.delete_dns = function(token,domain_id,dns_id,handler) 
  __civo_net_CivoHttp.delete(token, Std.string(Std.string(Std.string(Std.string(Std.string("") .. Std.string(__civo_Dns.path)) .. Std.string("/")) .. Std.string(domain_id)) .. Std.string("/records/")) .. Std.string(dns_id), handler);
end

__civo_Firewalls.new = {}
_hx_exports["civo"]["Firewalls"] = __civo_Firewalls
__civo_Firewalls.__name__ = true
__civo_Firewalls.create = function(token,name,handler) 
  __civo_net_CivoHttp.post(token, __civo_Firewalls.path, handler, _hx_o({__fields__={name=true},name=name}));
end
__civo_Firewalls.create_rules = function(token,firewall_id,params,handler) 
  __civo_net_CivoHttp.post(token, Std.string(Std.string(Std.string(Std.string("") .. Std.string(__civo_Firewalls.path)) .. Std.string("/")) .. Std.string(firewall_id)) .. Std.string("/rules"), handler, params);
end
__civo_Firewalls.get_rules = function(token,firewall_id,handler) 
  __civo_net_CivoHttp.get(token, Std.string(Std.string(Std.string(Std.string("") .. Std.string(__civo_Firewalls.path)) .. Std.string("/")) .. Std.string(firewall_id)) .. Std.string("/rules"), handler);
end
__civo_Firewalls.list = function(token,handler) 
  __civo_net_CivoHttp.get(token, __civo_Firewalls.path, handler);
end
__civo_Firewalls.delete = function(token,firewall_id,handler) 
  __civo_net_CivoHttp.delete(token, Std.string(Std.string(Std.string("") .. Std.string(__civo_Firewalls.path)) .. Std.string("/")) .. Std.string(firewall_id), handler);
end
__civo_Firewalls.delete_rule = function(token,firewall_id,rule_id,handler) 
  __civo_net_CivoHttp.delete(token, Std.string(Std.string(Std.string(Std.string(Std.string("") .. Std.string(__civo_Firewalls.path)) .. Std.string("/")) .. Std.string(firewall_id)) .. Std.string("/rules/")) .. Std.string(rule_id), handler);
end

__civo_Instances.new = {}
_hx_exports["civo"]["Instances"] = __civo_Instances
__civo_Instances.__name__ = true
__civo_Instances.available_sizes = function(token,handler) 
  __civo_net_CivoHttp.get(token, "sizes", handler);
end
__civo_Instances.create = function(token,params,handler) 
  __civo_net_CivoHttp.post(token, __civo_Instances.path, handler, params);
end
__civo_Instances.list = function(token,params,handler) 
  __civo_net_CivoHttp.get(token, __civo_Instances.path, handler, params);
end
__civo_Instances.get = function(token,instance_id,handler) 
  __civo_net_CivoHttp.get(token, Std.string(Std.string(Std.string("") .. Std.string(__civo_Instances.path)) .. Std.string("/")) .. Std.string(instance_id), handler);
end
__civo_Instances.delete = function(token,instance_id,handler) 
  __civo_net_CivoHttp.delete(token, Std.string(Std.string(Std.string("") .. Std.string(__civo_Instances.path)) .. Std.string("/")) .. Std.string(instance_id), handler);
end
__civo_Instances.retag = function(token,instance_id,tags,handler) 
  __civo_net_CivoHttp.put(token, Std.string(Std.string(Std.string(Std.string("") .. Std.string(__civo_Instances.path)) .. Std.string("/")) .. Std.string(instance_id)) .. Std.string("/tags"), handler, _hx_o({__fields__={tags=true},tags=tags}));
end
__civo_Instances.hard_reboots = function(token,instance_id,handler) 
  __civo_net_CivoHttp.post(token, Std.string(Std.string(Std.string(Std.string("") .. Std.string(__civo_Instances.path)) .. Std.string("/")) .. Std.string(instance_id)) .. Std.string("/hard_reboots"), handler);
end
__civo_Instances.soft_reboots = function(token,instance_id,handler) 
  __civo_net_CivoHttp.post(token, Std.string(Std.string(Std.string(Std.string("") .. Std.string(__civo_Instances.path)) .. Std.string("/")) .. Std.string(instance_id)) .. Std.string("/soft_reboots"), handler);
end
__civo_Instances.stop = function(token,instance_id,handler) 
  __civo_net_CivoHttp.put(token, Std.string(Std.string(Std.string(Std.string("") .. Std.string(__civo_Instances.path)) .. Std.string("/")) .. Std.string(instance_id)) .. Std.string("/stop"), handler);
end
__civo_Instances.start = function(token,instance_id,handler) 
  __civo_net_CivoHttp.put(token, Std.string(Std.string(Std.string(Std.string("") .. Std.string(__civo_Instances.path)) .. Std.string("/")) .. Std.string(instance_id)) .. Std.string("/start"), handler);
end
__civo_Instances.resize = function(token,instance_id,size,handler) 
  __civo_net_CivoHttp.put(token, Std.string(Std.string(Std.string(Std.string("") .. Std.string(__civo_Instances.path)) .. Std.string("/")) .. Std.string(instance_id)) .. Std.string("/resize"), handler, _hx_o({__fields__={size=true},size=size}));
end
__civo_Instances.firewall = function(token,instance_id,firewall_id,handler) 
  __civo_net_CivoHttp.put(token, Std.string(Std.string(Std.string(Std.string("") .. Std.string(__civo_Instances.path)) .. Std.string("/")) .. Std.string(instance_id)) .. Std.string("/firewall"), handler, _hx_o({__fields__={firewall_id=true},firewall_id=firewall_id}));
end
__civo_Instances.move_ip = function(token,instance_id,ip_address,handler) 
  __civo_net_CivoHttp.put(token, Std.string(Std.string(Std.string(Std.string(Std.string("") .. Std.string(__civo_Instances.path)) .. Std.string("/")) .. Std.string(instance_id)) .. Std.string("/ip/")) .. Std.string(ip_address), handler);
end

__civo_Kubernetes.new = {}
_hx_exports["civo"]["Kubernetes"] = __civo_Kubernetes
__civo_Kubernetes.__name__ = true
__civo_Kubernetes.create = function(token,params,handler) 
  __civo_net_CivoHttp.post(token, __civo_Kubernetes.path, handler, params);
end
__civo_Kubernetes.list = function(token,handler) 
  __civo_net_CivoHttp.get(token, __civo_Kubernetes.path, handler);
end
__civo_Kubernetes.get = function(token,kubernetes_id,handler) 
  __civo_net_CivoHttp.get(token, Std.string(Std.string(Std.string("") .. Std.string(__civo_Kubernetes.path)) .. Std.string("/")) .. Std.string(kubernetes_id), handler);
end
__civo_Kubernetes.update = function(token,kubernetes_id,params,handler) 
  __civo_net_CivoHttp.put(token, Std.string(Std.string(Std.string("") .. Std.string(__civo_Kubernetes.path)) .. Std.string("/")) .. Std.string(kubernetes_id), handler);
end
__civo_Kubernetes.applications = function(token,handler) 
  __civo_net_CivoHttp.get(token, __civo_Kubernetes.apps, handler);
end
__civo_Kubernetes.delete = function(token,kubernetes_id,handler) 
  __civo_net_CivoHttp.delete(token, Std.string(Std.string(Std.string("") .. Std.string(__civo_Kubernetes.path)) .. Std.string("/")) .. Std.string(kubernetes_id), handler);
end
__civo_Kubernetes.recycle = function(token,kubernetes_id,hostname,handler) 
  __civo_net_CivoHttp.post(token, Std.string(Std.string(Std.string(Std.string("") .. Std.string(__civo_Kubernetes.path)) .. Std.string("/")) .. Std.string(kubernetes_id)) .. Std.string("/recycle"), handler, _hx_o({__fields__={hostname=true},hostname=hostname}));
end

__civo_LoadBalancers.new = {}
_hx_exports["civo"]["LoadBalancers"] = __civo_LoadBalancers
__civo_LoadBalancers.__name__ = true
__civo_LoadBalancers.list = function(token,handler) 
  __civo_net_CivoHttp.get(token, __civo_LoadBalancers.path, handler);
end
__civo_LoadBalancers.create = function(token,params,handler) 
  __civo_net_CivoHttp.post(token, __civo_LoadBalancers.path, handler, params);
end
__civo_LoadBalancers.update = function(token,lb_id,params,handler) 
  __civo_net_CivoHttp.put(token, Std.string(Std.string(Std.string("") .. Std.string(__civo_LoadBalancers.path)) .. Std.string("/")) .. Std.string(lb_id), handler, params);
end
__civo_LoadBalancers.delete = function(token,lb_id,handler) 
  __civo_net_CivoHttp.delete(token, Std.string(Std.string(Std.string("") .. Std.string(__civo_LoadBalancers.path)) .. Std.string("/")) .. Std.string(lb_id), handler);
end

__civo_Networks.new = {}
_hx_exports["civo"]["Networks"] = __civo_Networks
__civo_Networks.__name__ = true
__civo_Networks.create = function(token,label,handler) 
  __civo_net_CivoHttp.post(token, __civo_Networks.path, handler, _hx_o({__fields__={label=true},label=label}));
end
__civo_Networks.list = function(token,handler) 
  __civo_net_CivoHttp.get(token, __civo_Networks.path, handler);
end
__civo_Networks.rename = function(token,network_id,label,handler) 
  __civo_net_CivoHttp.put(token, Std.string(Std.string(Std.string("") .. Std.string(__civo_Networks.path)) .. Std.string("/")) .. Std.string(network_id), handler, _hx_o({__fields__={label=true},label=label}));
end
__civo_Networks.delete = function(token,network_id,handler) 
  __civo_net_CivoHttp.delete(token, Std.string(Std.string(Std.string("") .. Std.string(__civo_Networks.path)) .. Std.string("/")) .. Std.string(network_id), handler);
end

__civo_Quota.new = {}
_hx_exports["civo"]["Quota"] = __civo_Quota
__civo_Quota.__name__ = true
__civo_Quota.get = function(token,handler) 
  __civo_net_CivoHttp.get(token, __civo_Quota.path, handler);
end

__civo_Regions.new = {}
_hx_exports["civo"]["Regions"] = __civo_Regions
__civo_Regions.__name__ = true
__civo_Regions.available_regions = function(token,handler) 
  __civo_net_CivoHttp.get(token, __civo_Regions.path, handler);
end

__civo_Snapshots.new = {}
_hx_exports["civo"]["Snapshots"] = __civo_Snapshots
__civo_Snapshots.__name__ = true
__civo_Snapshots.create = function(token,name,params,handler) 
  __civo_net_CivoHttp.put(token, Std.string(Std.string(Std.string("") .. Std.string(__civo_Snapshots.path)) .. Std.string("/")) .. Std.string(name), handler, params);
end
__civo_Snapshots.list = function(token,handler) 
  __civo_net_CivoHttp.get(token, __civo_Snapshots.path, handler);
end
__civo_Snapshots.delete = function(token,name,handler) 
  __civo_net_CivoHttp.delete(token, Std.string(Std.string(Std.string("") .. Std.string(__civo_Snapshots.path)) .. Std.string("/")) .. Std.string(name), handler);
end

__civo_Ssh.new = {}
_hx_exports["civo"]["Ssh"] = __civo_Ssh
__civo_Ssh.__name__ = true
__civo_Ssh.list = function(token,handler) 
  __civo_net_CivoHttp.get(token, __civo_Ssh.path, handler);
end
__civo_Ssh.get = function(token,ssh_id,handler) 
  __civo_net_CivoHttp.get(token, Std.string(Std.string(Std.string("") .. Std.string(__civo_Ssh.path)) .. Std.string("/")) .. Std.string(ssh_id), handler);
end
__civo_Ssh.upload = function(token,name,public_key,handler) 
  __civo_net_CivoHttp.post(token, __civo_Ssh.path, handler, _hx_o({__fields__={name=true,public_key=true},name=name,public_key=public_key}));
end
__civo_Ssh.update = function(token,ssh_id,name,handler) 
  __civo_net_CivoHttp.put(token, Std.string(Std.string(Std.string("") .. Std.string(__civo_Ssh.path)) .. Std.string("/")) .. Std.string(ssh_id), handler, _hx_o({__fields__={name=true},name=name}));
end
__civo_Ssh.delete = function(token,ssh_id,handler) 
  __civo_net_CivoHttp.delete(token, Std.string(Std.string(Std.string("") .. Std.string(__civo_Ssh.path)) .. Std.string("/")) .. Std.string(ssh_id), handler);
end

__civo_Templates.new = {}
_hx_exports["civo"]["Templates"] = __civo_Templates
__civo_Templates.__name__ = true
__civo_Templates.create = function(token,params,handler) 
  __civo_net_CivoHttp.post(token, __civo_Templates.path, handler, params);
end
__civo_Templates.update = function(token,template_id,params,handler) 
  __civo_net_CivoHttp.put(token, Std.string(Std.string(Std.string("") .. Std.string(__civo_Templates.path)) .. Std.string("/")) .. Std.string(template_id), handler, params);
end
__civo_Templates.list = function(token,handler) 
  __civo_net_CivoHttp.get(token, __civo_Templates.path, handler);
end
__civo_Templates.delete = function(token,template_id,handler) 
  __civo_net_CivoHttp.delete(token, Std.string(Std.string(Std.string("") .. Std.string(__civo_Templates.path)) .. Std.string("/")) .. Std.string(template_id), handler);
end

__civo_Volumes.new = {}
_hx_exports["civo"]["Volumes"] = __civo_Volumes
__civo_Volumes.__name__ = true
__civo_Volumes.create = function(token,params,handler) 
  __civo_net_CivoHttp.post(token, __civo_Volumes.path, handler, params);
end
__civo_Volumes.list = function(token,handler) 
  __civo_net_CivoHttp.get(token, __civo_Volumes.path, handler);
end
__civo_Volumes.resize = function(token,volume_id,size_gb,handler) 
  __civo_net_CivoHttp.put(token, Std.string(Std.string(Std.string(Std.string("") .. Std.string(__civo_Volumes.path)) .. Std.string("/")) .. Std.string(volume_id)) .. Std.string("/resize"), handler, _hx_o({__fields__={size_gb=true},size_gb=size_gb}));
end
__civo_Volumes.attach = function(token,volume_id,instance_id,handler) 
  __civo_net_CivoHttp.put(token, Std.string(Std.string(Std.string(Std.string("") .. Std.string(__civo_Volumes.path)) .. Std.string("/")) .. Std.string(volume_id)) .. Std.string("/attach"), handler, _hx_o({__fields__={instance_id=true},instance_id=instance_id}));
end
__civo_Volumes.detach = function(token,volume_id,handler) 
  __civo_net_CivoHttp.put(token, Std.string(Std.string(Std.string(Std.string("") .. Std.string(__civo_Volumes.path)) .. Std.string("/")) .. Std.string(volume_id)) .. Std.string("/detach"), handler);
end
__civo_Volumes.delete = function(token,volume_id,handler) 
  __civo_net_CivoHttp.delete(token, Std.string(Std.string(Std.string("") .. Std.string(__civo_Volumes.path)) .. Std.string("/")) .. Std.string(volume_id), handler);
end

__civo_Webhooks.new = {}
_hx_exports["civo"]["Webhooks"] = __civo_Webhooks
__civo_Webhooks.__name__ = true
__civo_Webhooks.create = function(token,params,handler) 
  __civo_net_CivoHttp.post(token, __civo_Webhooks.path, handler, params);
end
__civo_Webhooks.list = function(token,handler) 
  __civo_net_CivoHttp.get(token, __civo_Webhooks.path, handler);
end
__civo_Webhooks.update = function(token,webhook_id,params,handler) 
  __civo_net_CivoHttp.put(token, Std.string(Std.string(Std.string("") .. Std.string(__civo_Webhooks.path)) .. Std.string("/")) .. Std.string(webhook_id), handler, params);
end
__civo_Webhooks.test = function(token,webhook_id,handler) 
  __civo_net_CivoHttp.post(token, Std.string(Std.string(Std.string(Std.string("") .. Std.string(__civo_Webhooks.path)) .. Std.string("/")) .. Std.string(webhook_id)) .. Std.string("/test"), handler);
end
__civo_Webhooks.delete = function(token,webhook_id,handler) 
  __civo_net_CivoHttp.delete(token, Std.string(Std.string(Std.string("") .. Std.string(__civo_Webhooks.path)) .. Std.string("/")) .. Std.string(webhook_id), handler);
end

__civo_net_CivoHttp.new = {}
_hx_exports["civo"]["net"]["CivoHttp"] = __civo_net_CivoHttp
__civo_net_CivoHttp.__name__ = true
__civo_net_CivoHttp.url = function(path) 
  do return Std.string("https://api.civo.com/v2") .. Std.string(path) end;
end
__civo_net_CivoHttp.get = function(token,path,handler,params) 
  do return __civo_net_CivoHttp.request("GET", token, path, handler, params) end;
end
__civo_net_CivoHttp.put = function(token,path,handler,params) 
  do return __civo_net_CivoHttp.request("PUT", token, path, handler, params) end;
end
__civo_net_CivoHttp.post = function(token,path,handler,params) 
  do return __civo_net_CivoHttp.request("POST", token, path, handler, params) end;
end
__civo_net_CivoHttp.delete = function(token,path,handler,params) 
  do return __civo_net_CivoHttp.request("DELETE", token, path, handler, params) end;
end
__civo_net_CivoHttp.request = function(method,token,path,handler,params) 
  local uri = __civo_net_CivoHttp.url(path);
  local body = (function() 
    local _hx_1
    if (params ~= nil) then 
    _hx_1 = __haxe_Json.stringify(params); else 
    _hx_1 = ""; end
    return _hx_1
  end )();
  local this1 = __lua_lib_luautf8_Utf8.lower("Content-Type");
  local headers = __tink_http_HeaderField.new(this1, "application/json");
  local this2 = __lua_lib_luautf8_Utf8.lower("Content-Length");
  local headers1 = __tink_http_HeaderField.new(this2, __tink_http__Header_HeaderValue_Impl_.ofInt(__lua_lib_luautf8_Utf8.len(body)));
  local this3 = __lua_lib_luautf8_Utf8.lower("Authorization");
  local headers2 = _hx_tab_array({[0]=headers, headers1, __tink_http_HeaderField.new(this3, Std.string("Bearer ") .. Std.string(token))}, 3);
  do return __tink_http__Fetch_FetchResponse_Impl_.all(__tink_http_Fetch.fetch(__tink__Url_Url_Impl_.fromString(uri), _hx_o({__fields__={method=true,headers=true,body=true},method=method,headers=headers2,body=__tink_streams_Single.new(__tink_core__Lazy_LazyConst.new(__tink_chunk_ByteChunk.of(__haxe_io_Bytes.ofString(body))))}))):handle(function(o) 
    local tmp = o[1];
    if (tmp) == 0 then 
      local res = o[2];
      local body1 = (function() 
        local _hx_2
        if ((res.body ~= nil) and (res.body:toString() ~= "")) then 
        _hx_2 = __haxe_Json.parse(res.body:toString()); else 
        _hx_2 = nil; end
        return _hx_2
      end )();
      handler(res.header.statusCode, body1);
    elseif (tmp) == 1 then 
      local res1 = o[2];
      local body2 = (function() 
        local _hx_3
        if ((res1.data ~= nil) and (res1.data ~= "")) then 
        _hx_3 = __haxe_Json.parse(res1.data); else 
        _hx_3 = res1.message; end
        return _hx_3
      end )();
      handler(res1.code, body2); end;
  end) end;
end
_hxClasses["haxe.StackItem"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="CFunction","Module","FilePos","Method","LocalFunction"},5)}
__haxe_StackItem = _hxClasses["haxe.StackItem"];
__haxe_StackItem.CFunction = _hx_tab_array({[0]="CFunction",0,__enum__ = __haxe_StackItem},2)

__haxe_StackItem.Module = function(m) local _x = _hx_tab_array({[0]="Module",1,m,__enum__=__haxe_StackItem}, 3); return _x; end 
__haxe_StackItem.FilePos = function(s,file,line,column) local _x = _hx_tab_array({[0]="FilePos",2,s,file,line,column,__enum__=__haxe_StackItem}, 6); return _x; end 
__haxe_StackItem.Method = function(classname,method) local _x = _hx_tab_array({[0]="Method",3,classname,method,__enum__=__haxe_StackItem}, 4); return _x; end 
__haxe_StackItem.LocalFunction = function(v) local _x = _hx_tab_array({[0]="LocalFunction",4,v,__enum__=__haxe_StackItem}, 3); return _x; end 

__haxe_IMap.new = {}
__haxe_IMap.__name__ = true

__haxe_EntryPoint.new = {}
__haxe_EntryPoint.__name__ = true
__haxe_EntryPoint.processEvents = function() 
  while (true) do 
    local f = __haxe_EntryPoint.pending:shift();
    if (f == nil) then 
      break;
    end;
    f();
  end;
  local time = __haxe_MainLoop.tick();
  if (not __haxe_MainLoop.hasEvents() and (__haxe_EntryPoint.threadCount == 0)) then 
    do return -1 end;
  end;
  do return time end;
end
__haxe_EntryPoint.run = function() 
  while (true) do 
    local nextTick = __haxe_EntryPoint.processEvents();
    if (nextTick < 0) then 
      break;
    end;
    local tmp = nextTick > 0;
  end;
end

__haxe_Json.new = {}
__haxe_Json.__name__ = true
__haxe_Json.parse = function(text) 
  do return __haxe_format_JsonParser.new(text):doParse() end;
end
__haxe_Json.stringify = function(value,replacer,space) 
  do return __haxe_format_JsonPrinter.print(value, replacer, space) end;
end

__haxe_MainEvent.new = function(f,p) 
  local self = _hx_new(__haxe_MainEvent.prototype)
  __haxe_MainEvent.super(self,f,p)
  return self
end
__haxe_MainEvent.super = function(self,f,p) 
  self.isBlocking = true;
  self.f = _hx_funcToField(f);
  self.priority = p;
  self.nextRun = -_G.math.huge;
end
__haxe_MainEvent.__name__ = true
__haxe_MainEvent.prototype = _hx_a();
__haxe_MainEvent.prototype.f= nil;
__haxe_MainEvent.prototype.prev= nil;
__haxe_MainEvent.prototype.next= nil;
__haxe_MainEvent.prototype.isBlocking= nil;
__haxe_MainEvent.prototype.nextRun= nil;
__haxe_MainEvent.prototype.priority= nil;
__haxe_MainEvent.prototype.delay = function(self,t) 
  self.nextRun = (function() 
    local _hx_1
    if (t == nil) then 
    _hx_1 = -_G.math.huge; else 
    _hx_1 = Sys.time() + t; end
    return _hx_1
  end )();
end
__haxe_MainEvent.prototype.stop = function(self) 
  if (self.f == nil) then 
    do return end;
  end;
  self.f = nil;
  self.nextRun = -_G.math.huge;
  if (self.prev == nil) then 
    __haxe_MainLoop.pending = self.next;
  else
    self.prev.next = self.next;
  end;
  if (self.next ~= nil) then 
    self.next.prev = self.prev;
  end;
end

__haxe_MainEvent.prototype.__class__ =  __haxe_MainEvent

__haxe_MainLoop.new = {}
__haxe_MainLoop.__name__ = true
__haxe_MainLoop.hasEvents = function() 
  local p = __haxe_MainLoop.pending;
  while (p ~= nil) do 
    if (p.isBlocking) then 
      do return true end;
    end;
    p = p.next;
  end;
  do return false end;
end
__haxe_MainLoop.add = function(f,priority) 
  if (priority == nil) then 
    priority = 0;
  end;
  if (f == nil) then 
    _G.error("Event function is null",0);
  end;
  local e = __haxe_MainEvent.new(f, priority);
  local head = __haxe_MainLoop.pending;
  if (head ~= nil) then 
    head.prev = e;
  end;
  e.next = head;
  __haxe_MainLoop.pending = e;
  do return e end;
end
__haxe_MainLoop.sortEvents = function() 
  local list = __haxe_MainLoop.pending;
  if (list == nil) then 
    do return end;
  end;
  local insize = 1;
  local nmerges;
  local psize = 0;
  local qsize = 0;
  local p;
  local q;
  local e;
  local tail;
  while (true) do 
    p = list;
    list = nil;
    tail = nil;
    nmerges = 0;
    while (p ~= nil) do 
      nmerges = nmerges + 1;
      q = p;
      psize = 0;
      local _g = 0;
      local _g1 = insize;
      while (_g < _g1) do 
        _g = _g + 1;
        local i = _g - 1;
        psize = psize + 1;
        q = q.next;
        if (q == nil) then 
          break;
        end;
      end;
      qsize = insize;
      while ((psize > 0) or ((qsize > 0) and (q ~= nil))) do 
        if (psize == 0) then 
          e = q;
          q = q.next;
          qsize = qsize - 1;
        else
          if (((qsize == 0) or (q == nil)) or ((p.priority > q.priority) or ((p.priority == q.priority) and (p.nextRun <= q.nextRun)))) then 
            e = p;
            p = p.next;
            psize = psize - 1;
          else
            e = q;
            q = q.next;
            qsize = qsize - 1;
          end;
        end;
        if (tail ~= nil) then 
          tail.next = e;
        else
          list = e;
        end;
        e.prev = tail;
        tail = e;
      end;
      p = q;
    end;
    tail.next = nil;
    if (nmerges <= 1) then 
      break;
    end;
    insize = insize * 2;
  end;
  list.prev = nil;
  __haxe_MainLoop.pending = list;
end
__haxe_MainLoop.tick = function() 
  __haxe_MainLoop.sortEvents();
  local e = __haxe_MainLoop.pending;
  local now = Sys.time();
  local wait = 1e9;
  while (e ~= nil) do 
    local next = e.next;
    local wt = e.nextRun - now;
    if (wt <= 0) then 
      wait = 0;
      if (e.f ~= nil) then 
        e:f();
      end;
    else
      if (wait > wt) then 
        wait = wt;
      end;
    end;
    e = next;
  end;
  do return wait end;
end

__haxe_Timer.new = function(time_ms) 
  local self = _hx_new(__haxe_Timer.prototype)
  __haxe_Timer.super(self,time_ms)
  return self
end
__haxe_Timer.super = function(self,time_ms) 
  local _gthis = self;
  local dt = time_ms / 1000;
  self.event = __haxe_MainLoop.add(function() 
    local _gthis1 = _gthis.event;
    _gthis1.nextRun = _gthis1.nextRun + dt;
    _gthis:run();
  end);
  self.event:delay(dt);
end
__haxe_Timer.__name__ = true
__haxe_Timer.delay = function(f,time_ms) 
  local t = __haxe_Timer.new(time_ms);
  t.run = function(self) 
    t:stop();
    f();
   end;
  do return t end;
end
__haxe_Timer.prototype = _hx_a();
__haxe_Timer.prototype.event= nil;
__haxe_Timer.prototype.stop = function(self) 
  if (self.event ~= nil) then 
    self.event:stop();
    self.event = nil;
  end;
end
__haxe_Timer.prototype.run = function(self) 
end

__haxe_Timer.prototype.__class__ =  __haxe_Timer

__haxe_io_Bytes.new = function(length,b) 
  local self = _hx_new(__haxe_io_Bytes.prototype)
  __haxe_io_Bytes.super(self,length,b)
  return self
end
__haxe_io_Bytes.super = function(self,length,b) 
  self.length = length;
  self.b = b;
end
__haxe_io_Bytes.__name__ = true
__haxe_io_Bytes.alloc = function(length) 
  local a = Array.new();
  local _g = 0;
  local _g1 = length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    a:push(0);
  end;
  do return __haxe_io_Bytes.new(length, a) end;
end
__haxe_io_Bytes.ofString = function(s,encoding) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = _G.string.len(s);
  while (_g1 < _g2) do 
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    _g:push(_G.string.byte(s, i + 1));
  end;
  local bytes = _g;
  do return __haxe_io_Bytes.new(bytes.length, bytes) end;
end
__haxe_io_Bytes.ofData = function(b) 
  do return __haxe_io_Bytes.new(b.length, b) end;
end
__haxe_io_Bytes.prototype = _hx_a();
__haxe_io_Bytes.prototype.length= nil;
__haxe_io_Bytes.prototype.b= nil;
__haxe_io_Bytes.prototype.blit = function(self,pos,src,srcpos,len) 
  if (((((pos < 0) or (srcpos < 0)) or (len < 0)) or ((pos + len) > self.length)) or ((srcpos + len) > src.length)) then 
    _G.error(__haxe_io_Error.OutsideBounds,0);
  end;
  local b1 = self.b;
  local b2 = src.b;
  if ((b1 == b2) and (pos > srcpos)) then 
    local i = len;
    while (i > 0) do 
      i = i - 1;
      b1[i + pos] = b2[i + srcpos];
    end;
    do return end;
  end;
  local _g = 0;
  local _g1 = len;
  while (_g < _g1) do 
    _g = _g + 1;
    local i1 = _g - 1;
    b1[i1 + pos] = b2[i1 + srcpos];
  end;
end
__haxe_io_Bytes.prototype.sub = function(self,pos,len) 
  if (((pos < 0) or (len < 0)) or ((pos + len) > self.length)) then 
    _G.error(__haxe_io_Error.OutsideBounds,0);
  end;
  do return __haxe_io_Bytes.new(len, self.b:slice(pos, pos + len)) end
end
__haxe_io_Bytes.prototype.getString = function(self,pos,len,encoding) 
  local tmp = encoding == nil;
  if (((pos < 0) or (len < 0)) or ((pos + len) > self.length)) then 
    _G.error(__haxe_io_Error.OutsideBounds,0);
  end;
  if ((self.b.length - pos) <= __lua_Boot.MAXSTACKSIZE) then 
    local _end = Math.min(self.b.length, pos + len) - 1;
    do return _G.string.char(_hx_table.unpack(self.b, pos, _end)) end;
  else
    local tbl = ({});
    local _g = pos;
    local _g1 = pos + len;
    while (_g < _g1) do 
      _g = _g + 1;
      local idx = _g - 1;
      _G.table.insert(tbl, _G.string.char(self.b[idx]));
    end;
    do return _G.table.concat(tbl, "") end;
  end;
end
__haxe_io_Bytes.prototype.toString = function(self) 
  do return self:getString(0, self.length) end
end

__haxe_io_Bytes.prototype.__class__ =  __haxe_io_Bytes

__haxe_ds_BalancedTree.new = function() 
  local self = _hx_new(__haxe_ds_BalancedTree.prototype)
  __haxe_ds_BalancedTree.super(self)
  return self
end
__haxe_ds_BalancedTree.super = function(self) 
end
__haxe_ds_BalancedTree.__name__ = true
__haxe_ds_BalancedTree.__interfaces__ = {__haxe_IMap}
__haxe_ds_BalancedTree.prototype = _hx_a();
__haxe_ds_BalancedTree.prototype.root= nil;
__haxe_ds_BalancedTree.prototype.set = function(self,key,value) 
  self.root = self:setLoop(key, value, self.root);
end
__haxe_ds_BalancedTree.prototype.get = function(self,key) 
  local node = self.root;
  while (node ~= nil) do 
    local c = self:compare(key, node.key);
    if (c == 0) then 
      do return node.value end;
    end;
    if (c < 0) then 
      node = node.left;
    else
      node = node.right;
    end;
  end;
  do return nil end
end
__haxe_ds_BalancedTree.prototype.exists = function(self,key) 
  local node = self.root;
  while (node ~= nil) do 
    local c = self:compare(key, node.key);
    if (c == 0) then 
      do return true end;
    else
      if (c < 0) then 
        node = node.left;
      else
        node = node.right;
      end;
    end;
  end;
  do return false end
end
__haxe_ds_BalancedTree.prototype.setLoop = function(self,k,v,node) 
  if (node == nil) then 
    do return __haxe_ds_TreeNode.new(nil, k, v, nil) end;
  end;
  local c = self:compare(k, node.key);
  if (c == 0) then 
    do return __haxe_ds_TreeNode.new(node.left, k, v, node.right, (function() 
      local _hx_1
      if (node == nil) then 
      _hx_1 = 0; else 
      _hx_1 = node._height; end
      return _hx_1
    end )()) end;
  else
    if (c < 0) then 
      local nl = self:setLoop(k, v, node.left);
      do return self:balance(nl, node.key, node.value, node.right) end;
    else
      local nr = self:setLoop(k, v, node.right);
      do return self:balance(node.left, node.key, node.value, nr) end;
    end;
  end;
end
__haxe_ds_BalancedTree.prototype.balance = function(self,l,k,v,r) 
  local hl = (function() 
    local _hx_1
    if (l == nil) then 
    _hx_1 = 0; else 
    _hx_1 = l._height; end
    return _hx_1
  end )();
  local hr = (function() 
    local _hx_2
    if (r == nil) then 
    _hx_2 = 0; else 
    _hx_2 = r._height; end
    return _hx_2
  end )();
  if (hl > (hr + 2)) then 
    local _this = l.left;
    local _this1 = l.right;
    if ((function() 
      local _hx_3
      if (_this == nil) then 
      _hx_3 = 0; else 
      _hx_3 = _this._height; end
      return _hx_3
    end )() >= (function() 
      local _hx_4
      if (_this1 == nil) then 
      _hx_4 = 0; else 
      _hx_4 = _this1._height; end
      return _hx_4
    end )()) then 
      do return __haxe_ds_TreeNode.new(l.left, l.key, l.value, __haxe_ds_TreeNode.new(l.right, k, v, r)) end;
    else
      do return __haxe_ds_TreeNode.new(__haxe_ds_TreeNode.new(l.left, l.key, l.value, l.right.left), l.right.key, l.right.value, __haxe_ds_TreeNode.new(l.right.right, k, v, r)) end;
    end;
  else
    if (hr > (hl + 2)) then 
      local _this2 = r.right;
      local _this3 = r.left;
      if ((function() 
        local _hx_5
        if (_this2 == nil) then 
        _hx_5 = 0; else 
        _hx_5 = _this2._height; end
        return _hx_5
      end )() > (function() 
        local _hx_6
        if (_this3 == nil) then 
        _hx_6 = 0; else 
        _hx_6 = _this3._height; end
        return _hx_6
      end )()) then 
        do return __haxe_ds_TreeNode.new(__haxe_ds_TreeNode.new(l, k, v, r.left), r.key, r.value, r.right) end;
      else
        do return __haxe_ds_TreeNode.new(__haxe_ds_TreeNode.new(l, k, v, r.left.left), r.left.key, r.left.value, __haxe_ds_TreeNode.new(r.left.right, r.key, r.value, r.right)) end;
      end;
    else
      do return __haxe_ds_TreeNode.new(l, k, v, r, (function() 
        local _hx_7
        if (hl > hr) then 
        _hx_7 = hl; else 
        _hx_7 = hr; end
        return _hx_7
      end )() + 1) end;
    end;
  end;
end
__haxe_ds_BalancedTree.prototype.compare = function(self,k1,k2) 
  do return Reflect.compare(k1, k2) end
end

__haxe_ds_BalancedTree.prototype.__class__ =  __haxe_ds_BalancedTree

__haxe_ds_TreeNode.new = function(l,k,v,r,h) 
  local self = _hx_new(__haxe_ds_TreeNode.prototype)
  __haxe_ds_TreeNode.super(self,l,k,v,r,h)
  return self
end
__haxe_ds_TreeNode.super = function(self,l,k,v,r,h) 
  if (h == nil) then 
    h = -1;
  end;
  self.left = l;
  self.key = k;
  self.value = v;
  self.right = r;
  if (h == -1) then 
    local tmp;
    local _this = self.left;
    local _this1 = self.right;
    if ((function() 
      local _hx_1
      if (_this == nil) then 
      _hx_1 = 0; else 
      _hx_1 = _this._height; end
      return _hx_1
    end )() > (function() 
      local _hx_2
      if (_this1 == nil) then 
      _hx_2 = 0; else 
      _hx_2 = _this1._height; end
      return _hx_2
    end )()) then 
      local _this2 = self.left;
      tmp = (function() 
        local _hx_3
        if (_this2 == nil) then 
        _hx_3 = 0; else 
        _hx_3 = _this2._height; end
        return _hx_3
      end )();
    else
      local _this3 = self.right;
      tmp = (function() 
        local _hx_4
        if (_this3 == nil) then 
        _hx_4 = 0; else 
        _hx_4 = _this3._height; end
        return _hx_4
      end )();
    end;
    self._height = tmp + 1;
  else
    self._height = h;
  end;
end
__haxe_ds_TreeNode.__name__ = true
__haxe_ds_TreeNode.prototype = _hx_a();
__haxe_ds_TreeNode.prototype.left= nil;
__haxe_ds_TreeNode.prototype.right= nil;
__haxe_ds_TreeNode.prototype.key= nil;
__haxe_ds_TreeNode.prototype.value= nil;
__haxe_ds_TreeNode.prototype._height= nil;

__haxe_ds_TreeNode.prototype.__class__ =  __haxe_ds_TreeNode

__haxe_ds_EnumValueMap.new = function() 
  local self = _hx_new(__haxe_ds_EnumValueMap.prototype)
  __haxe_ds_EnumValueMap.super(self)
  return self
end
__haxe_ds_EnumValueMap.super = function(self) 
  __haxe_ds_BalancedTree.super(self);
end
__haxe_ds_EnumValueMap.__name__ = true
__haxe_ds_EnumValueMap.__interfaces__ = {__haxe_IMap}
__haxe_ds_EnumValueMap.prototype = _hx_a();
__haxe_ds_EnumValueMap.prototype.compare = function(self,k1,k2) 
  local d = k1[1] - k2[1];
  if (d ~= 0) then 
    do return d end;
  end;
  local p1 = k1:slice(2);
  local p2 = k2:slice(2);
  if ((p1.length == 0) and (p2.length == 0)) then 
    do return 0 end;
  end;
  do return self:compareArgs(p1, p2) end
end
__haxe_ds_EnumValueMap.prototype.compareArgs = function(self,a1,a2) 
  local ld = a1.length - a2.length;
  if (ld ~= 0) then 
    do return ld end;
  end;
  local _g = 0;
  local _g1 = a1.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local d = self:compareArg(a1[i], a2[i]);
    if (d ~= 0) then 
      do return d end;
    end;
  end;
  do return 0 end
end
__haxe_ds_EnumValueMap.prototype.compareArg = function(self,v1,v2) 
  if (Reflect.isEnumValue(v1) and Reflect.isEnumValue(v2)) then 
    do return self:compare(v1, v2) end;
  else
    if (__lua_Boot.__instanceof(v1, Array) and __lua_Boot.__instanceof(v2, Array)) then 
      do return self:compareArgs(v1, v2) end;
    else
      do return Reflect.compare(v1, v2) end;
    end;
  end;
end

__haxe_ds_EnumValueMap.prototype.__class__ =  __haxe_ds_EnumValueMap
__haxe_ds_EnumValueMap.__super__ = __haxe_ds_BalancedTree
setmetatable(__haxe_ds_EnumValueMap.prototype,{__index=__haxe_ds_BalancedTree.prototype})
_hxClasses["haxe.ds.Option"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Some","None"},2)}
__haxe_ds_Option = _hxClasses["haxe.ds.Option"];
__haxe_ds_Option.Some = function(v) local _x = _hx_tab_array({[0]="Some",0,v,__enum__=__haxe_ds_Option}, 3); return _x; end 
__haxe_ds_Option.None = _hx_tab_array({[0]="None",1,__enum__ = __haxe_ds_Option},2)


__haxe_ds_StringMap.new = function() 
  local self = _hx_new(__haxe_ds_StringMap.prototype)
  __haxe_ds_StringMap.super(self)
  return self
end
__haxe_ds_StringMap.super = function(self) 
  self.h = ({});
end
__haxe_ds_StringMap.__name__ = true
__haxe_ds_StringMap.__interfaces__ = {__haxe_IMap}
__haxe_ds_StringMap.prototype = _hx_a();
__haxe_ds_StringMap.prototype.h= nil;
__haxe_ds_StringMap.prototype.keys = function(self) 
  local _gthis = self;
  local next = _G.next;
  local cur = next(self.h, nil);
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local ret = cur;
    cur = next(_gthis.h, cur);
    do return ret end;
  end,hasNext=function(self) 
    do return cur ~= nil end;
  end}) end
end

__haxe_ds_StringMap.prototype.__class__ =  __haxe_ds_StringMap

__haxe_format_JsonParser.new = function(str) 
  local self = _hx_new(__haxe_format_JsonParser.prototype)
  __haxe_format_JsonParser.super(self,str)
  return self
end
__haxe_format_JsonParser.super = function(self,str) 
  self.str = str;
  self.pos = 0;
end
__haxe_format_JsonParser.__name__ = true
__haxe_format_JsonParser.prototype = _hx_a();
__haxe_format_JsonParser.prototype.str= nil;
__haxe_format_JsonParser.prototype.pos= nil;
__haxe_format_JsonParser.prototype.doParse = function(self) 
  local result = self:parseRec();
  local c;
  while (true) do 
    local index = (function() 
    local _hx_obj = self;
    local _hx_fld = 'pos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    c = __lua_lib_luautf8_Utf8.byte(self.str, index + 1);
    if (not (c ~= nil)) then 
      break;
    end;
    local c1 = c;
    if (c1) == 9 or (c1) == 10 or (c1) == 13 or (c1) == 32 then else
    self:invalidChar(); end;
  end;
  do return result end
end
__haxe_format_JsonParser.prototype.parseRec = function(self) 
  while (true) do 
    local index = (function() 
    local _hx_obj = self;
    local _hx_fld = 'pos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local c = __lua_lib_luautf8_Utf8.byte(self.str, index + 1);
    local c1 = c;
    if (c1) == 9 or (c1) == 10 or (c1) == 13 or (c1) == 32 then 
    elseif (c1) == 34 then 
      do return self:parseString() end;
    elseif (c1) == 45 or (c1) == 48 or (c1) == 49 or (c1) == 50 or (c1) == 51 or (c1) == 52 or (c1) == 53 or (c1) == 54 or (c1) == 55 or (c1) == 56 or (c1) == 57 then 
      local c2 = c;
      local start = self.pos - 1;
      local minus = c2 == 45;
      local digit = not minus;
      local zero = c2 == 48;
      local point = false;
      local e = false;
      local pm = false;
      local _end = false;
      while (true) do 
        local index1 = (function() 
        local _hx_obj = self;
        local _hx_fld = 'pos';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
        c2 = __lua_lib_luautf8_Utf8.byte(self.str, index1 + 1);
        local c3 = c2;
        if (c3) == 43 or (c3) == 45 then 
          if (not e or pm) then 
            self:invalidNumber(start);
          end;
          digit = false;
          pm = true;
        elseif (c3) == 46 then 
          if ((minus or point) or e) then 
            self:invalidNumber(start);
          end;
          digit = false;
          point = true;
        elseif (c3) == 48 then 
          if (zero and not point) then 
            self:invalidNumber(start);
          end;
          if (minus) then 
            minus = false;
            zero = true;
          end;
          digit = true;
        elseif (c3) == 49 or (c3) == 50 or (c3) == 51 or (c3) == 52 or (c3) == 53 or (c3) == 54 or (c3) == 55 or (c3) == 56 or (c3) == 57 then 
          if (zero and not point) then 
            self:invalidNumber(start);
          end;
          if (minus) then 
            minus = false;
          end;
          digit = true;
          zero = false;
        elseif (c3) == 69 or (c3) == 101 then 
          if ((minus or zero) or e) then 
            self:invalidNumber(start);
          end;
          digit = false;
          e = true;else
        if (not digit) then 
          self:invalidNumber(start);
        end;
        self.pos = self.pos - 1;
        _end = true; end;
        if (_end) then 
          break;
        end;
      end;
      local _this = self.str;
      local pos = start;
      local len = self.pos - start;
      if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(_this)))) then 
        len = __lua_lib_luautf8_Utf8.len(_this);
      else
        if (len < 0) then 
          len = __lua_lib_luautf8_Utf8.len(_this) + len;
        end;
      end;
      if (pos < 0) then 
        pos = __lua_lib_luautf8_Utf8.len(_this) + pos;
      end;
      if (pos < 0) then 
        pos = 0;
      end;
      local f = Std.parseFloat(__lua_lib_luautf8_Utf8.sub(_this, pos + 1, pos + len));
      local i = Std.int(f);
      if (i == f) then 
        do return i end;
      else
        do return f end;
      end;
    elseif (c1) == 91 then 
      local arr = _hx_tab_array({}, 0);
      local comma = nil;
      while (true) do 
        local index2 = (function() 
        local _hx_obj = self;
        local _hx_fld = 'pos';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
        local c4 = __lua_lib_luautf8_Utf8.byte(self.str, index2 + 1);
        local c5 = c4;
        if (c5) == 9 or (c5) == 10 or (c5) == 13 or (c5) == 32 then 
        elseif (c5) == 44 then 
          if (comma) then 
            comma = false;
          else
            self:invalidChar();
          end;
        elseif (c5) == 93 then 
          if (comma == false) then 
            self:invalidChar();
          end;
          do return arr end;else
        if (comma) then 
          self:invalidChar();
        end;
        self.pos = self.pos - 1;
        arr:push(self:parseRec());
        comma = true; end;
      end;
    elseif (c1) == 102 then 
      local save = self.pos;
      local tmp;
      local tmp1;
      local tmp2;
      local index3 = (function() 
      local _hx_obj = self;
      local _hx_fld = 'pos';
      local _ = _hx_obj[_hx_fld];
      _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
       return _;
       end)();
      if (__lua_lib_luautf8_Utf8.byte(self.str, index3 + 1) == 97) then 
        local index4 = (function() 
        local _hx_obj = self;
        local _hx_fld = 'pos';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
        tmp2 = __lua_lib_luautf8_Utf8.byte(self.str, index4 + 1) ~= 108;
      else
        tmp2 = true;
      end;
      if (not tmp2) then 
        local index5 = (function() 
        local _hx_obj = self;
        local _hx_fld = 'pos';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
        tmp1 = __lua_lib_luautf8_Utf8.byte(self.str, index5 + 1) ~= 115;
      else
        tmp1 = true;
      end;
      if (not tmp1) then 
        local index6 = (function() 
        local _hx_obj = self;
        local _hx_fld = 'pos';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
        tmp = __lua_lib_luautf8_Utf8.byte(self.str, index6 + 1) ~= 101;
      else
        tmp = true;
      end;
      if (tmp) then 
        self.pos = save;
        self:invalidChar();
      end;
      do return false end;
    elseif (c1) == 110 then 
      local save1 = self.pos;
      local tmp3;
      local tmp4;
      local index7 = (function() 
      local _hx_obj = self;
      local _hx_fld = 'pos';
      local _ = _hx_obj[_hx_fld];
      _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
       return _;
       end)();
      if (__lua_lib_luautf8_Utf8.byte(self.str, index7 + 1) == 117) then 
        local index8 = (function() 
        local _hx_obj = self;
        local _hx_fld = 'pos';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
        tmp4 = __lua_lib_luautf8_Utf8.byte(self.str, index8 + 1) ~= 108;
      else
        tmp4 = true;
      end;
      if (not tmp4) then 
        local index9 = (function() 
        local _hx_obj = self;
        local _hx_fld = 'pos';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
        tmp3 = __lua_lib_luautf8_Utf8.byte(self.str, index9 + 1) ~= 108;
      else
        tmp3 = true;
      end;
      if (tmp3) then 
        self.pos = save1;
        self:invalidChar();
      end;
      do return nil end;
    elseif (c1) == 116 then 
      local save2 = self.pos;
      local tmp5;
      local tmp6;
      local index10 = (function() 
      local _hx_obj = self;
      local _hx_fld = 'pos';
      local _ = _hx_obj[_hx_fld];
      _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
       return _;
       end)();
      if (__lua_lib_luautf8_Utf8.byte(self.str, index10 + 1) == 114) then 
        local index11 = (function() 
        local _hx_obj = self;
        local _hx_fld = 'pos';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
        tmp6 = __lua_lib_luautf8_Utf8.byte(self.str, index11 + 1) ~= 117;
      else
        tmp6 = true;
      end;
      if (not tmp6) then 
        local index12 = (function() 
        local _hx_obj = self;
        local _hx_fld = 'pos';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
        tmp5 = __lua_lib_luautf8_Utf8.byte(self.str, index12 + 1) ~= 101;
      else
        tmp5 = true;
      end;
      if (tmp5) then 
        self.pos = save2;
        self:invalidChar();
      end;
      do return true end;
    elseif (c1) == 123 then 
      local obj = _hx_e();
      local field = nil;
      local comma1 = nil;
      while (true) do 
        local index13 = (function() 
        local _hx_obj = self;
        local _hx_fld = 'pos';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
        local c6 = __lua_lib_luautf8_Utf8.byte(self.str, index13 + 1);
        local c7 = c6;
        if (c7) == 9 or (c7) == 10 or (c7) == 13 or (c7) == 32 then 
        elseif (c7) == 34 then 
          if ((field ~= nil) or comma1) then 
            self:invalidChar();
          end;
          field = self:parseString();
        elseif (c7) == 44 then 
          if (comma1) then 
            comma1 = false;
          else
            self:invalidChar();
          end;
        elseif (c7) == 58 then 
          if (field == nil) then 
            self:invalidChar();
          end;
          obj[field] = self:parseRec();
          field = nil;
          comma1 = true;
        elseif (c7) == 125 then 
          if ((field ~= nil) or (comma1 == false)) then 
            self:invalidChar();
          end;
          do return obj end;else
        self:invalidChar(); end;
      end;else
    self:invalidChar(); end;
  end;
end
__haxe_format_JsonParser.prototype.parseString = function(self) 
  local start = self.pos;
  local buf = nil;
  local prev = -1;
  while (true) do 
    local index = (function() 
    local _hx_obj = self;
    local _hx_fld = 'pos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local c = __lua_lib_luautf8_Utf8.byte(self.str, index + 1);
    if (c == 34) then 
      break;
    end;
    if (c == 92) then 
      if (buf == nil) then 
        buf = StringBuf.new();
      end;
      local s = self.str;
      local len = (self.pos - start) - 1;
      local part;
      if (len == nil) then 
        local pos = start;
        local len1 = nil;
        if ((len1 == nil) or (len1 > (pos + __lua_lib_luautf8_Utf8.len(s)))) then 
          len1 = __lua_lib_luautf8_Utf8.len(s);
        else
          if (len1 < 0) then 
            len1 = __lua_lib_luautf8_Utf8.len(s) + len1;
          end;
        end;
        if (pos < 0) then 
          pos = __lua_lib_luautf8_Utf8.len(s) + pos;
        end;
        if (pos < 0) then 
          pos = 0;
        end;
        part = __lua_lib_luautf8_Utf8.sub(s, pos + 1, pos + len1);
      else
        local pos1 = start;
        local len2 = len;
        if ((len2 == nil) or (len2 > (pos1 + __lua_lib_luautf8_Utf8.len(s)))) then 
          len2 = __lua_lib_luautf8_Utf8.len(s);
        else
          if (len2 < 0) then 
            len2 = __lua_lib_luautf8_Utf8.len(s) + len2;
          end;
        end;
        if (pos1 < 0) then 
          pos1 = __lua_lib_luautf8_Utf8.len(s) + pos1;
        end;
        if (pos1 < 0) then 
          pos1 = 0;
        end;
        part = __lua_lib_luautf8_Utf8.sub(s, pos1 + 1, pos1 + len2);
      end;
      _G.table.insert(buf.b, part);
      local buf1 = buf;
      buf1.length = buf1.length + __lua_lib_luautf8_Utf8.len(part);
      local index1 = (function() 
      local _hx_obj = self;
      local _hx_fld = 'pos';
      local _ = _hx_obj[_hx_fld];
      _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
       return _;
       end)();
      c = __lua_lib_luautf8_Utf8.byte(self.str, index1 + 1);
      if ((c ~= 117) and (prev ~= -1)) then 
        _G.table.insert(buf.b, __lua_lib_luautf8_Utf8.char(65533));
        local buf2 = buf;
        buf2.length = buf2.length + 1;
        prev = -1;
      end;
      local c1 = c;
      if (c1) == 34 or (c1) == 47 or (c1) == 92 then 
        _G.table.insert(buf.b, __lua_lib_luautf8_Utf8.char(c));
        local buf3 = buf;
        buf3.length = buf3.length + 1;
      elseif (c1) == 98 then 
        _G.table.insert(buf.b, __lua_lib_luautf8_Utf8.char(8));
        local buf4 = buf;
        buf4.length = buf4.length + 1;
      elseif (c1) == 102 then 
        _G.table.insert(buf.b, __lua_lib_luautf8_Utf8.char(12));
        local buf5 = buf;
        buf5.length = buf5.length + 1;
      elseif (c1) == 110 then 
        _G.table.insert(buf.b, __lua_lib_luautf8_Utf8.char(10));
        local buf6 = buf;
        buf6.length = buf6.length + 1;
      elseif (c1) == 114 then 
        _G.table.insert(buf.b, __lua_lib_luautf8_Utf8.char(13));
        local buf7 = buf;
        buf7.length = buf7.length + 1;
      elseif (c1) == 116 then 
        _G.table.insert(buf.b, __lua_lib_luautf8_Utf8.char(9));
        local buf8 = buf;
        buf8.length = buf8.length + 1;
      elseif (c1) == 117 then 
        local _this = self.str;
        local pos2 = self.pos;
        local len3 = 4;
        if ((len3 == nil) or (len3 > (pos2 + __lua_lib_luautf8_Utf8.len(_this)))) then 
          len3 = __lua_lib_luautf8_Utf8.len(_this);
        else
          if (len3 < 0) then 
            len3 = __lua_lib_luautf8_Utf8.len(_this) + len3;
          end;
        end;
        if (pos2 < 0) then 
          pos2 = __lua_lib_luautf8_Utf8.len(_this) + pos2;
        end;
        if (pos2 < 0) then 
          pos2 = 0;
        end;
        local uc = Std.parseInt(Std.string("0x") .. Std.string(__lua_lib_luautf8_Utf8.sub(_this, pos2 + 1, pos2 + len3)));
        local tmp = self;
        tmp.pos = tmp.pos + 4;
        if (prev ~= -1) then 
          if ((uc < 56320) or (uc > 57343)) then 
            _G.table.insert(buf.b, __lua_lib_luautf8_Utf8.char(65533));
            local buf9 = buf;
            buf9.length = buf9.length + 1;
            prev = -1;
          else
            _G.table.insert(buf.b, __lua_lib_luautf8_Utf8.char(((_hx_bit.lshift(prev - 55296,10)) + (uc - 56320)) + 65536));
            local buf10 = buf;
            buf10.length = buf10.length + 1;
            prev = -1;
          end;
        else
          if ((uc >= 55296) and (uc <= 56319)) then 
            prev = uc;
          else
            _G.table.insert(buf.b, __lua_lib_luautf8_Utf8.char(uc));
            local buf11 = buf;
            buf11.length = buf11.length + 1;
          end;
        end;else
      _G.error(Std.string(Std.string(Std.string("Invalid escape sequence \\") .. Std.string(__lua_lib_luautf8_Utf8.char(c))) .. Std.string(" at position ")) .. Std.string((self.pos - 1)),0); end;
      start = self.pos;
    else
      if (c == nil) then 
        _G.error("Unclosed string",0);
      end;
    end;
  end;
  if (prev ~= -1) then 
    _G.table.insert(buf.b, __lua_lib_luautf8_Utf8.char(65533));
    local buf12 = buf;
    buf12.length = buf12.length + 1;
    prev = -1;
  end;
  if (buf == nil) then 
    local _this1 = self.str;
    local pos3 = start;
    local len4 = (self.pos - start) - 1;
    if ((len4 == nil) or (len4 > (pos3 + __lua_lib_luautf8_Utf8.len(_this1)))) then 
      len4 = __lua_lib_luautf8_Utf8.len(_this1);
    else
      if (len4 < 0) then 
        len4 = __lua_lib_luautf8_Utf8.len(_this1) + len4;
      end;
    end;
    if (pos3 < 0) then 
      pos3 = __lua_lib_luautf8_Utf8.len(_this1) + pos3;
    end;
    if (pos3 < 0) then 
      pos3 = 0;
    end;
    do return __lua_lib_luautf8_Utf8.sub(_this1, pos3 + 1, pos3 + len4) end;
  else
    local s1 = self.str;
    local len5 = (self.pos - start) - 1;
    local part1;
    if (len5 == nil) then 
      local pos4 = start;
      local len6 = nil;
      if ((len6 == nil) or (len6 > (pos4 + __lua_lib_luautf8_Utf8.len(s1)))) then 
        len6 = __lua_lib_luautf8_Utf8.len(s1);
      else
        if (len6 < 0) then 
          len6 = __lua_lib_luautf8_Utf8.len(s1) + len6;
        end;
      end;
      if (pos4 < 0) then 
        pos4 = __lua_lib_luautf8_Utf8.len(s1) + pos4;
      end;
      if (pos4 < 0) then 
        pos4 = 0;
      end;
      part1 = __lua_lib_luautf8_Utf8.sub(s1, pos4 + 1, pos4 + len6);
    else
      local pos5 = start;
      local len7 = len5;
      if ((len7 == nil) or (len7 > (pos5 + __lua_lib_luautf8_Utf8.len(s1)))) then 
        len7 = __lua_lib_luautf8_Utf8.len(s1);
      else
        if (len7 < 0) then 
          len7 = __lua_lib_luautf8_Utf8.len(s1) + len7;
        end;
      end;
      if (pos5 < 0) then 
        pos5 = __lua_lib_luautf8_Utf8.len(s1) + pos5;
      end;
      if (pos5 < 0) then 
        pos5 = 0;
      end;
      part1 = __lua_lib_luautf8_Utf8.sub(s1, pos5 + 1, pos5 + len7);
    end;
    _G.table.insert(buf.b, part1);
    local buf13 = buf;
    buf13.length = buf13.length + __lua_lib_luautf8_Utf8.len(part1);
    do return _G.table.concat(buf.b) end;
  end;
end
__haxe_format_JsonParser.prototype.invalidChar = function(self) 
  self.pos = self.pos - 1;
  _G.error(Std.string(Std.string(Std.string("Invalid char ") .. Std.string(__lua_lib_luautf8_Utf8.byte(self.str, self.pos + 1))) .. Std.string(" at position ")) .. Std.string(self.pos),0);
end
__haxe_format_JsonParser.prototype.invalidNumber = function(self,start) 
  local _this = self.str;
  local pos = start;
  local len = self.pos - start;
  if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(_this)))) then 
    len = __lua_lib_luautf8_Utf8.len(_this);
  else
    if (len < 0) then 
      len = __lua_lib_luautf8_Utf8.len(_this) + len;
    end;
  end;
  if (pos < 0) then 
    pos = __lua_lib_luautf8_Utf8.len(_this) + pos;
  end;
  if (pos < 0) then 
    pos = 0;
  end;
  _G.error(Std.string(Std.string(Std.string("Invalid number at position ") .. Std.string(start)) .. Std.string(": ")) .. Std.string(__lua_lib_luautf8_Utf8.sub(_this, pos + 1, pos + len)),0);
end

__haxe_format_JsonParser.prototype.__class__ =  __haxe_format_JsonParser

__haxe_format_JsonPrinter.new = function(replacer,space) 
  local self = _hx_new(__haxe_format_JsonPrinter.prototype)
  __haxe_format_JsonPrinter.super(self,replacer,space)
  return self
end
__haxe_format_JsonPrinter.super = function(self,replacer,space) 
  self.replacer = _hx_funcToField(replacer);
  self.indent = space;
  self.pretty = space ~= nil;
  self.nind = 0;
  self.buf = StringBuf.new();
end
__haxe_format_JsonPrinter.__name__ = true
__haxe_format_JsonPrinter.print = function(o,replacer,space) 
  local printer = __haxe_format_JsonPrinter.new(replacer, space);
  printer:write("", o);
  do return _G.table.concat(printer.buf.b) end;
end
__haxe_format_JsonPrinter.prototype = _hx_a();
__haxe_format_JsonPrinter.prototype.buf= nil;
__haxe_format_JsonPrinter.prototype.replacer= nil;
__haxe_format_JsonPrinter.prototype.indent= nil;
__haxe_format_JsonPrinter.prototype.pretty= nil;
__haxe_format_JsonPrinter.prototype.nind= nil;
__haxe_format_JsonPrinter.prototype.write = function(self,k,v) 
  if (self.replacer ~= nil) then 
    v = self:replacer(k, v);
  end;
  local _g = Type.typeof(v);
  local tmp = _g[1];
  if (tmp) == 0 then 
    local _this = self.buf;
    local str = "null";
    _G.table.insert(_this.b, str);
    local _this1 = _this;
    _this1.length = _this1.length + __lua_lib_luautf8_Utf8.len(str);
  elseif (tmp) == 1 then 
    local _this2 = self.buf;
    local str1 = Std.string(v);
    _G.table.insert(_this2.b, str1);
    local _this3 = _this2;
    _this3.length = _this3.length + __lua_lib_luautf8_Utf8.len(str1);
  elseif (tmp) == 2 then 
    local v1 = (function() 
      local _hx_1
      if (Math.isFinite(v)) then 
      _hx_1 = Std.string(v); else 
      _hx_1 = "null"; end
      return _hx_1
    end )();
    local _this4 = self.buf;
    local str2 = Std.string(v1);
    _G.table.insert(_this4.b, str2);
    local _this5 = _this4;
    _this5.length = _this5.length + __lua_lib_luautf8_Utf8.len(str2);
  elseif (tmp) == 3 then 
    local _this6 = self.buf;
    local str3 = Std.string(v);
    _G.table.insert(_this6.b, str3);
    local _this7 = _this6;
    _this7.length = _this7.length + __lua_lib_luautf8_Utf8.len(str3);
  elseif (tmp) == 4 then 
    self:fieldsString(v, Reflect.fields(v));
  elseif (tmp) == 5 then 
    local _this8 = self.buf;
    local str4 = "\"<fun>\"";
    _G.table.insert(_this8.b, str4);
    local _this9 = _this8;
    _this9.length = _this9.length + __lua_lib_luautf8_Utf8.len(str4);
  elseif (tmp) == 6 then 
    local c = _g[2];
    if (c == String) then 
      self:quote(v);
    else
      if (c == Array) then 
        local v2 = v;
        local _this10 = self.buf;
        _G.table.insert(_this10.b, __lua_lib_luautf8_Utf8.char(91));
        local _this11 = _this10;
        _this11.length = _this11.length + 1;
        local len = v2.length;
        local last = len - 1;
        local _g1 = 0;
        local _g11 = len;
        while (_g1 < _g11) do 
          _g1 = _g1 + 1;
          local i = _g1 - 1;
          if (i > 0) then 
            local _this12 = self.buf;
            _G.table.insert(_this12.b, __lua_lib_luautf8_Utf8.char(44));
            local _this13 = _this12;
            _this13.length = _this13.length + 1;
          else
            self.nind = self.nind + 1;
          end;
          if (self.pretty) then 
            local _this14 = self.buf;
            _G.table.insert(_this14.b, __lua_lib_luautf8_Utf8.char(10));
            local _this15 = _this14;
            _this15.length = _this15.length + 1;
          end;
          if (self.pretty) then 
            local v3 = StringTools.lpad("", self.indent, self.nind * __lua_lib_luautf8_Utf8.len(self.indent));
            local _this16 = self.buf;
            local str5 = Std.string(v3);
            _G.table.insert(_this16.b, str5);
            local _this17 = _this16;
            _this17.length = _this17.length + __lua_lib_luautf8_Utf8.len(str5);
          end;
          self:write(i, v2[i]);
          if (i == last) then 
            self.nind = self.nind - 1;
            if (self.pretty) then 
              local _this18 = self.buf;
              _G.table.insert(_this18.b, __lua_lib_luautf8_Utf8.char(10));
              local _this19 = _this18;
              _this19.length = _this19.length + 1;
            end;
            if (self.pretty) then 
              local v4 = StringTools.lpad("", self.indent, self.nind * __lua_lib_luautf8_Utf8.len(self.indent));
              local _this20 = self.buf;
              local str6 = Std.string(v4);
              _G.table.insert(_this20.b, str6);
              local _this21 = _this20;
              _this21.length = _this21.length + __lua_lib_luautf8_Utf8.len(str6);
            end;
          end;
        end;
        local _this22 = self.buf;
        _G.table.insert(_this22.b, __lua_lib_luautf8_Utf8.char(93));
        local _this23 = _this22;
        _this23.length = _this23.length + 1;
      else
        if (c == __haxe_ds_StringMap) then 
          local v5 = v;
          local o = _hx_e();
          local k1 = v5:keys();
          while (k1:hasNext()) do 
            local k2 = k1:next();
            local ret = v5.h[k2];
            if (ret == __haxe_ds_StringMap.tnull) then 
              ret = nil;
            end;
            o[k2] = ret;
          end;
          local v6 = o;
          self:fieldsString(v6, Reflect.fields(v6));
        else
          if (c == Date) then 
            local v7 = v;
            self:quote(__lua_Boot.dateStr(v7));
          else
            self:classString(v);
          end;
        end;
      end;
    end;
  elseif (tmp) == 7 then 
    local _g12 = _g[2];
    local i1 = v[1];
    local _this24 = self.buf;
    local str7 = Std.string(i1);
    _G.table.insert(_this24.b, str7);
    local _this25 = _this24;
    _this25.length = _this25.length + __lua_lib_luautf8_Utf8.len(str7);
  elseif (tmp) == 8 then 
    local _this26 = self.buf;
    local str8 = "\"???\"";
    _G.table.insert(_this26.b, str8);
    local _this27 = _this26;
    _this27.length = _this27.length + __lua_lib_luautf8_Utf8.len(str8); end;
end
__haxe_format_JsonPrinter.prototype.classString = function(self,v) 
  self:fieldsString(v, Type.getInstanceFields(Type.getClass(v)));
end
__haxe_format_JsonPrinter.prototype.fieldsString = function(self,v,fields) 
  local _this = self.buf;
  _G.table.insert(_this.b, __lua_lib_luautf8_Utf8.char(123));
  local _this1 = _this;
  _this1.length = _this1.length + 1;
  local len = fields.length;
  local last = len - 1;
  local first = true;
  local _g = 0;
  local _g1 = len;
  local _hx_continue_1 = false;
  while (_g < _g1) do repeat 
    _g = _g + 1;
    local i = _g - 1;
    local f = fields[i];
    local value = Reflect.field(v, f);
    if (Reflect.isFunction(value)) then 
      break;
    end;
    if (first) then 
      self.nind = self.nind + 1;
      first = false;
    else
      local _this2 = self.buf;
      _G.table.insert(_this2.b, __lua_lib_luautf8_Utf8.char(44));
      local _this3 = _this2;
      _this3.length = _this3.length + 1;
    end;
    if (self.pretty) then 
      local _this4 = self.buf;
      _G.table.insert(_this4.b, __lua_lib_luautf8_Utf8.char(10));
      local _this5 = _this4;
      _this5.length = _this5.length + 1;
    end;
    if (self.pretty) then 
      local v1 = StringTools.lpad("", self.indent, self.nind * __lua_lib_luautf8_Utf8.len(self.indent));
      local _this6 = self.buf;
      local str = Std.string(v1);
      _G.table.insert(_this6.b, str);
      local _this7 = _this6;
      _this7.length = _this7.length + __lua_lib_luautf8_Utf8.len(str);
    end;
    self:quote(f);
    local _this8 = self.buf;
    _G.table.insert(_this8.b, __lua_lib_luautf8_Utf8.char(58));
    local _this9 = _this8;
    _this9.length = _this9.length + 1;
    if (self.pretty) then 
      local _this10 = self.buf;
      _G.table.insert(_this10.b, __lua_lib_luautf8_Utf8.char(32));
      local _this11 = _this10;
      _this11.length = _this11.length + 1;
    end;
    self:write(f, value);
    if (i == last) then 
      self.nind = self.nind - 1;
      if (self.pretty) then 
        local _this12 = self.buf;
        _G.table.insert(_this12.b, __lua_lib_luautf8_Utf8.char(10));
        local _this13 = _this12;
        _this13.length = _this13.length + 1;
      end;
      if (self.pretty) then 
        local v2 = StringTools.lpad("", self.indent, self.nind * __lua_lib_luautf8_Utf8.len(self.indent));
        local _this14 = self.buf;
        local str1 = Std.string(v2);
        _G.table.insert(_this14.b, str1);
        local _this15 = _this14;
        _this15.length = _this15.length + __lua_lib_luautf8_Utf8.len(str1);
      end;
    end;until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
  local _this16 = self.buf;
  _G.table.insert(_this16.b, __lua_lib_luautf8_Utf8.char(125));
  local _this17 = _this16;
  _this17.length = _this17.length + 1;
end
__haxe_format_JsonPrinter.prototype.quote = function(self,s) 
  local _this = self.buf;
  _G.table.insert(_this.b, __lua_lib_luautf8_Utf8.char(34));
  local _this1 = _this;
  _this1.length = _this1.length + 1;
  local i = 0;
  while (true) do 
    i = i + 1;
    local c = __lua_lib_luautf8_Utf8.byte(s, (i - 1) + 1);
    if (c == nil) then 
      break;
    end;
    local c1 = c;
    if (c1) == 8 then 
      local _this2 = self.buf;
      local str = "\\b";
      _G.table.insert(_this2.b, str);
      local _this3 = _this2;
      _this3.length = _this3.length + __lua_lib_luautf8_Utf8.len(str);
    elseif (c1) == 9 then 
      local _this4 = self.buf;
      local str1 = "\\t";
      _G.table.insert(_this4.b, str1);
      local _this5 = _this4;
      _this5.length = _this5.length + __lua_lib_luautf8_Utf8.len(str1);
    elseif (c1) == 10 then 
      local _this6 = self.buf;
      local str2 = "\\n";
      _G.table.insert(_this6.b, str2);
      local _this7 = _this6;
      _this7.length = _this7.length + __lua_lib_luautf8_Utf8.len(str2);
    elseif (c1) == 12 then 
      local _this8 = self.buf;
      local str3 = "\\f";
      _G.table.insert(_this8.b, str3);
      local _this9 = _this8;
      _this9.length = _this9.length + __lua_lib_luautf8_Utf8.len(str3);
    elseif (c1) == 13 then 
      local _this10 = self.buf;
      local str4 = "\\r";
      _G.table.insert(_this10.b, str4);
      local _this11 = _this10;
      _this11.length = _this11.length + __lua_lib_luautf8_Utf8.len(str4);
    elseif (c1) == 34 then 
      local _this12 = self.buf;
      local str5 = "\\\"";
      _G.table.insert(_this12.b, str5);
      local _this13 = _this12;
      _this13.length = _this13.length + __lua_lib_luautf8_Utf8.len(str5);
    elseif (c1) == 92 then 
      local _this14 = self.buf;
      local str6 = "\\\\";
      _G.table.insert(_this14.b, str6);
      local _this15 = _this14;
      _this15.length = _this15.length + __lua_lib_luautf8_Utf8.len(str6);else
    local _this16 = self.buf;
    _G.table.insert(_this16.b, __lua_lib_luautf8_Utf8.char(c));
    local _this17 = _this16;
    _this17.length = _this17.length + 1; end;
  end;
  local _this18 = self.buf;
  _G.table.insert(_this18.b, __lua_lib_luautf8_Utf8.char(34));
  local _this19 = _this18;
  _this19.length = _this19.length + 1;
end

__haxe_format_JsonPrinter.prototype.__class__ =  __haxe_format_JsonPrinter

__haxe_http_HttpBase.new = function(url) 
  local self = _hx_new(__haxe_http_HttpBase.prototype)
  __haxe_http_HttpBase.super(self,url)
  return self
end
__haxe_http_HttpBase.super = function(self,url) 
  self.url = url;
  self.headers = _hx_tab_array({}, 0);
  self.params = _hx_tab_array({}, 0);
  self.emptyOnData = _hx_funcToField(_hx_bind(self,self.onData));
end
__haxe_http_HttpBase.__name__ = true
__haxe_http_HttpBase.prototype = _hx_a();
__haxe_http_HttpBase.prototype.url= nil;
__haxe_http_HttpBase.prototype.responseBytes= nil;
__haxe_http_HttpBase.prototype.responseAsString= nil;
__haxe_http_HttpBase.prototype.postData= nil;
__haxe_http_HttpBase.prototype.postBytes= nil;
__haxe_http_HttpBase.prototype.headers= nil;
__haxe_http_HttpBase.prototype.params= nil;
__haxe_http_HttpBase.prototype.emptyOnData= nil;
__haxe_http_HttpBase.prototype.setHeader = function(self,name,value) 
  local _g = 0;
  local _g1 = self.headers.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    if (self.headers[i].name == name) then 
      self.headers[i] = _hx_o({__fields__={name=true,value=true},name=name,value=value});
      do return end;
    end;
  end;
  self.headers:push(_hx_o({__fields__={name=true,value=true},name=name,value=value}));
end
__haxe_http_HttpBase.prototype.setPostData = function(self,data) 
  self.postData = data;
  self.postBytes = nil;
end
__haxe_http_HttpBase.prototype.onData = function(self,data) 
end
__haxe_http_HttpBase.prototype.onBytes = function(self,data) 
end
__haxe_http_HttpBase.prototype.onError = function(self,msg) 
end
__haxe_http_HttpBase.prototype.onStatus = function(self,status) 
end
__haxe_http_HttpBase.prototype.hasOnData = function(self) 
  do return not Reflect.compareMethods(_hx_bind(self,self.onData), _hx_bind(self,self.emptyOnData)) end
end
__haxe_http_HttpBase.prototype.success = function(self,data) 
  self.responseBytes = data;
  self.responseAsString = nil;
  if (self:hasOnData()) then 
    self:onData(self:get_responseData());
  end;
  self:onBytes(self.responseBytes);
end
__haxe_http_HttpBase.prototype.get_responseData = function(self) 
  if ((self.responseAsString == nil) and (self.responseBytes ~= nil)) then 
    self.responseAsString = self.responseBytes:getString(0, self.responseBytes.length, __haxe_io_Encoding.UTF8);
  end;
  do return self.responseAsString end
end

__haxe_http_HttpBase.prototype.__class__ =  __haxe_http_HttpBase

__haxe_io_BytesBuffer.new = function() 
  local self = _hx_new(__haxe_io_BytesBuffer.prototype)
  __haxe_io_BytesBuffer.super(self)
  return self
end
__haxe_io_BytesBuffer.super = function(self) 
  self.b = Array.new();
end
__haxe_io_BytesBuffer.__name__ = true
__haxe_io_BytesBuffer.prototype = _hx_a();
__haxe_io_BytesBuffer.prototype.b= nil;
__haxe_io_BytesBuffer.prototype.getBytes = function(self) 
  local bytes = __haxe_io_Bytes.new(self.b.length, self.b);
  self.b = nil;
  do return bytes end
end

__haxe_io_BytesBuffer.prototype.__class__ =  __haxe_io_BytesBuffer

__haxe_io_Input.new = {}
__haxe_io_Input.__name__ = true
__haxe_io_Input.prototype = _hx_a();
__haxe_io_Input.prototype.readByte = function(self) 
  _G.error("Not implemented",0);
end
__haxe_io_Input.prototype.readBytes = function(self,s,pos,len) 
  local k = len;
  local b = s.b;
  if (((pos < 0) or (len < 0)) or ((pos + len) > s.length)) then 
    _G.error(__haxe_io_Error.OutsideBounds,0);
  end;
  local _hx_status, _hx_result = pcall(function() 
  
      while (k > 0) do 
        b[pos] = self:readByte();
        pos = pos + 1;
        k = k - 1;
      end;
    return _hx_pcall_default
  end)
  if not _hx_status and _hx_result == "_hx_pcall_break" then
  elseif not _hx_status then 
  
    local _hx_1 = _hx_result
    if( __lua_Boot.__instanceof(_hx_1,__haxe_io_Eof) ) then 
      local eof = _hx_1
    else _G.error(_hx_1)
    end
  elseif _hx_result ~= _hx_pcall_default then
    return _hx_result
  end;
  do return len - k end
end
__haxe_io_Input.prototype.close = function(self) 
end

__haxe_io_Input.prototype.__class__ =  __haxe_io_Input

__haxe_io_Output.new = {}
__haxe_io_Output.__name__ = true
__haxe_io_Output.prototype = _hx_a();
__haxe_io_Output.prototype.bigEndian= nil;
__haxe_io_Output.prototype.writeByte = function(self,c) 
  _G.error("Not implemented",0);
end
__haxe_io_Output.prototype.writeBytes = function(self,s,pos,len) 
  if (((pos < 0) or (len < 0)) or ((pos + len) > s.length)) then 
    _G.error(__haxe_io_Error.OutsideBounds,0);
  end;
  local b = s.b;
  local k = len;
  while (k > 0) do 
    self:writeByte(b[pos]);
    pos = pos + 1;
    k = k - 1;
  end;
  do return len end
end
__haxe_io_Output.prototype.close = function(self) 
end
__haxe_io_Output.prototype.set_bigEndian = function(self,b) 
  self.bigEndian = b;
  do return b end
end
__haxe_io_Output.prototype.writeFullBytes = function(self,s,pos,len) 
  while (len > 0) do 
    local k = self:writeBytes(s, pos, len);
    pos = pos + k;
    len = len - k;
  end;
end
__haxe_io_Output.prototype.prepare = function(self,nbytes) 
end
__haxe_io_Output.prototype.writeString = function(self,s,encoding) 
  local b = __haxe_io_Bytes.ofString(s, encoding);
  self:writeFullBytes(b, 0, b.length);
end

__haxe_io_Output.prototype.__class__ =  __haxe_io_Output

__haxe_io_BytesOutput.new = function() 
  local self = _hx_new(__haxe_io_BytesOutput.prototype)
  __haxe_io_BytesOutput.super(self)
  return self
end
__haxe_io_BytesOutput.super = function(self) 
  self.b = __haxe_io_BytesBuffer.new();
end
__haxe_io_BytesOutput.__name__ = true
__haxe_io_BytesOutput.prototype = _hx_a();
__haxe_io_BytesOutput.prototype.b= nil;
__haxe_io_BytesOutput.prototype.writeByte = function(self,c) 
  self.b.b:push(c);
end
__haxe_io_BytesOutput.prototype.writeBytes = function(self,buf,pos,len) 
  local _this = self.b;
  if (((pos < 0) or (len < 0)) or ((pos + len) > buf.length)) then 
    _G.error(__haxe_io_Error.OutsideBounds,0);
  end;
  local b1 = _this.b;
  local b2 = buf.b;
  local _g = pos;
  local _g1 = pos + len;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    _this.b:push(b2[i]);
  end;
  do return len end
end
__haxe_io_BytesOutput.prototype.getBytes = function(self) 
  do return self.b:getBytes() end
end

__haxe_io_BytesOutput.prototype.__class__ =  __haxe_io_BytesOutput
__haxe_io_BytesOutput.__super__ = __haxe_io_Output
setmetatable(__haxe_io_BytesOutput.prototype,{__index=__haxe_io_Output.prototype})
_hxClasses["haxe.io.Encoding"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="UTF8","RawNative"},2)}
__haxe_io_Encoding = _hxClasses["haxe.io.Encoding"];
__haxe_io_Encoding.UTF8 = _hx_tab_array({[0]="UTF8",0,__enum__ = __haxe_io_Encoding},2)

__haxe_io_Encoding.RawNative = _hx_tab_array({[0]="RawNative",1,__enum__ = __haxe_io_Encoding},2)


__haxe_io_Eof.new = function() 
  local self = _hx_new(__haxe_io_Eof.prototype)
  __haxe_io_Eof.super(self)
  return self
end
__haxe_io_Eof.super = function(self) 
end
__haxe_io_Eof.__name__ = true
__haxe_io_Eof.prototype = _hx_a();
__haxe_io_Eof.prototype.toString = function(self) 
  do return "Eof" end
end

__haxe_io_Eof.prototype.__class__ =  __haxe_io_Eof
_hxClasses["haxe.io.Error"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Blocked","Overflow","OutsideBounds","Custom"},4)}
__haxe_io_Error = _hxClasses["haxe.io.Error"];
__haxe_io_Error.Blocked = _hx_tab_array({[0]="Blocked",0,__enum__ = __haxe_io_Error},2)

__haxe_io_Error.Overflow = _hx_tab_array({[0]="Overflow",1,__enum__ = __haxe_io_Error},2)

__haxe_io_Error.OutsideBounds = _hx_tab_array({[0]="OutsideBounds",2,__enum__ = __haxe_io_Error},2)

__haxe_io_Error.Custom = function(e) local _x = _hx_tab_array({[0]="Custom",3,e,__enum__=__haxe_io_Error}, 3); return _x; end 

__httpstatus__HttpStatusMessage_HttpStatusMessage_Impl_.new = {}
__httpstatus__HttpStatusMessage_HttpStatusMessage_Impl_.__name__ = true
__httpstatus__HttpStatusMessage_HttpStatusMessage_Impl_.fromCode = function(statusCode) 
  local statusCode1 = statusCode;
  if (statusCode1) == 100 then 
    do return "Continue" end;
  elseif (statusCode1) == 101 then 
    do return "Switching Protocols" end;
  elseif (statusCode1) == 102 then 
    do return "Processing" end;
  elseif (statusCode1) == 200 then 
    do return "OK" end;
  elseif (statusCode1) == 201 then 
    do return "Created" end;
  elseif (statusCode1) == 202 then 
    do return "Accepted" end;
  elseif (statusCode1) == 203 then 
    do return "Non-Authoritative Information" end;
  elseif (statusCode1) == 204 then 
    do return "No Content" end;
  elseif (statusCode1) == 205 then 
    do return "Reset Content" end;
  elseif (statusCode1) == 206 then 
    do return "Partial Content" end;
  elseif (statusCode1) == 207 then 
    do return "Multi-Status" end;
  elseif (statusCode1) == 208 then 
    do return "Already Reported" end;
  elseif (statusCode1) == 226 then 
    do return "IM Used" end;
  elseif (statusCode1) == 300 then 
    do return "Multiple Choices" end;
  elseif (statusCode1) == 301 then 
    do return "Moved Permanently" end;
  elseif (statusCode1) == 302 then 
    do return "Found" end;
  elseif (statusCode1) == 303 then 
    do return "See Other" end;
  elseif (statusCode1) == 304 then 
    do return "Not Modified" end;
  elseif (statusCode1) == 305 then 
    do return "Use Proxy" end;
  elseif (statusCode1) == 306 then 
    do return "Switch Proxy" end;
  elseif (statusCode1) == 307 then 
    do return "Temporary Redirect" end;
  elseif (statusCode1) == 308 then 
    do return "Permanent Redirect" end;
  elseif (statusCode1) == 400 then 
    do return "Bad Request" end;
  elseif (statusCode1) == 401 then 
    do return "Unauthorized" end;
  elseif (statusCode1) == 402 then 
    do return "Payment Required" end;
  elseif (statusCode1) == 403 then 
    do return "Forbidden" end;
  elseif (statusCode1) == 404 then 
    do return "Not Found" end;
  elseif (statusCode1) == 405 then 
    do return "Method Not Allowed" end;
  elseif (statusCode1) == 406 then 
    do return "Not Acceptable" end;
  elseif (statusCode1) == 407 then 
    do return "Proxy Authentication Required" end;
  elseif (statusCode1) == 408 then 
    do return "Request Timeout" end;
  elseif (statusCode1) == 409 then 
    do return "Conflict" end;
  elseif (statusCode1) == 410 then 
    do return "Gone" end;
  elseif (statusCode1) == 411 then 
    do return "Length Required" end;
  elseif (statusCode1) == 412 then 
    do return "Precondition Failed" end;
  elseif (statusCode1) == 413 then 
    do return "Payload Too Large" end;
  elseif (statusCode1) == 414 then 
    do return "URI Too Long" end;
  elseif (statusCode1) == 415 then 
    do return "Unsupported Media Type" end;
  elseif (statusCode1) == 416 then 
    do return "Range Not Satisfiable" end;
  elseif (statusCode1) == 417 then 
    do return "Expectation Failed" end;
  elseif (statusCode1) == 418 then 
    do return "I'm a teapot" end;
  elseif (statusCode1) == 421 then 
    do return "Misdirected Request" end;
  elseif (statusCode1) == 422 then 
    do return "Unprocessable Entity" end;
  elseif (statusCode1) == 423 then 
    do return "Locked" end;
  elseif (statusCode1) == 424 then 
    do return "Failed Dependency" end;
  elseif (statusCode1) == 426 then 
    do return "Upgrade Required" end;
  elseif (statusCode1) == 428 then 
    do return "Precondition Required" end;
  elseif (statusCode1) == 429 then 
    do return "Too Many Requests" end;
  elseif (statusCode1) == 431 then 
    do return "Request Header Fields Too Large" end;
  elseif (statusCode1) == 451 then 
    do return "Unavailable For Legal Reasons" end;
  elseif (statusCode1) == 500 then 
    do return "Internal Server Error" end;
  elseif (statusCode1) == 501 then 
    do return "Not Implemented" end;
  elseif (statusCode1) == 502 then 
    do return "Bad Gateway" end;
  elseif (statusCode1) == 503 then 
    do return "Service Unavailable" end;
  elseif (statusCode1) == 504 then 
    do return "Gateway Timeout" end;
  elseif (statusCode1) == 505 then 
    do return "HTTP Version Not Supported" end;
  elseif (statusCode1) == 506 then 
    do return "Variant Also Negotiates" end;
  elseif (statusCode1) == 507 then 
    do return "Insufficient Storage" end;
  elseif (statusCode1) == 508 then 
    do return "Loop Detected" end;
  elseif (statusCode1) == 510 then 
    do return "Not Extended" end;
  elseif (statusCode1) == 511 then 
    do return "Network Authentication Required" end;else
  do return "Unknown Status" end; end;
end

__lua_Boot.new = {}
__lua_Boot.__name__ = true
__lua_Boot.__instanceof = function(o,cl) 
  if (cl == nil) then 
    do return false end;
  end;
  local cl1 = cl;
  if (cl1) == Array then 
    do return __lua_Boot.isArray(o) end;
  elseif (cl1) == Bool then 
    do return _G.type(o) == "boolean" end;
  elseif (cl1) == Dynamic then 
    do return o ~= nil end;
  elseif (cl1) == Float then 
    do return _G.type(o) == "number" end;
  elseif (cl1) == Int then 
    if (_G.type(o) == "number") then 
      do return _hx_bit_clamp(o) == o end;
    else
      do return false end;
    end;
  elseif (cl1) == String then 
    do return _G.type(o) == "string" end;
  elseif (cl1) == _G.table then 
    do return _G.type(o) == "table" end;
  elseif (cl1) == __lua_Thread then 
    do return _G.type(o) == "thread" end;
  elseif (cl1) == __lua_UserData then 
    do return _G.type(o) == "userdata" end;else
  if (((o ~= nil) and (_G.type(o) == "table")) and (_G.type(cl) == "table")) then 
    local tmp;
    if (__lua_Boot.__instanceof(o, Array)) then 
      tmp = Array;
    else
      if (__lua_Boot.__instanceof(o, String)) then 
        tmp = String;
      else
        local cl2 = o.__class__;
        tmp = (function() 
          local _hx_1
          if (cl2 ~= nil) then 
          _hx_1 = cl2; else 
          _hx_1 = nil; end
          return _hx_1
        end )();
      end;
    end;
    if (__lua_Boot.extendsOrImplements(tmp, cl)) then 
      do return true end;
    end;
    if ((function() 
      local _hx_2
      if (cl == Class) then 
      _hx_2 = o.__name__ ~= nil; else 
      _hx_2 = false; end
      return _hx_2
    end )()) then 
      do return true end;
    end;
    if ((function() 
      local _hx_3
      if (cl == Enum) then 
      _hx_3 = o.__ename__ ~= nil; else 
      _hx_3 = false; end
      return _hx_3
    end )()) then 
      do return true end;
    end;
    do return o.__enum__ == cl end;
  else
    do return false end;
  end; end;
end
__lua_Boot.isArray = function(o) 
  if (_G.type(o) == "table") then 
    if ((o.__enum__ == nil) and (_G.getmetatable(o) ~= nil)) then 
      do return _G.getmetatable(o).__index == Array.prototype end;
    else
      do return false end;
    end;
  else
    do return false end;
  end;
end
__lua_Boot.printEnum = function(o,s) 
  if (o.length == 2) then 
    do return o[0] end;
  else
    local str = Std.string(Std.string(o[0])) .. Std.string("(");
    s = Std.string(s) .. Std.string("\t");
    local _g = 2;
    local _g1 = o.length;
    while (_g < _g1) do 
      _g = _g + 1;
      local i = _g - 1;
      if (i ~= 2) then 
        str = Std.string(str) .. Std.string((Std.string(",") .. Std.string(__lua_Boot.__string_rec(o[i], s))));
      else
        str = Std.string(str) .. Std.string(__lua_Boot.__string_rec(o[i], s));
      end;
    end;
    do return Std.string(str) .. Std.string(")") end;
  end;
end
__lua_Boot.printClassRec = function(c,result,s) 
  if (result == nil) then 
    result = "";
  end;
  local f = __lua_Boot.__string_rec;
  for k,v in pairs(c) do if result ~= '' then result = result .. ', ' end result = result .. k .. ':' .. f(v, s.. '	') end;
  do return result end;
end
__lua_Boot.__string_rec = function(o,s) 
  if (s == nil) then 
    s = "";
  end;
  if (__lua_lib_luautf8_Utf8.len(s) >= 5) then 
    do return "<...>" end;
  end;
  local _g = type(o);
  if (_g) == "boolean" then 
    do return tostring(o) end;
  elseif (_g) == "function" then 
    do return "<function>" end;
  elseif (_g) == "nil" then 
    do return "null" end;
  elseif (_g) == "number" then 
    if (o == _G.math.huge) then 
      do return "Infinity" end;
    else
      if (o == -_G.math.huge) then 
        do return "-Infinity" end;
      else
        if (o == 0) then 
          do return "0" end;
        else
          if (o ~= o) then 
            do return "NaN" end;
          else
            do return tostring(o) end;
          end;
        end;
      end;
    end;
  elseif (_g) == "string" then 
    do return o end;
  elseif (_g) == "table" then 
    if (o.__enum__ ~= nil) then 
      do return __lua_Boot.printEnum(o, s) end;
    else
      if ((_hx_wrap_if_string_field(o,'toString') ~= nil) and not __lua_Boot.isArray(o)) then 
        do return _hx_wrap_if_string_field(o,'toString')(o) end;
      else
        if (__lua_Boot.isArray(o)) then 
          local o2 = o;
          if (__lua_lib_luautf8_Utf8.len(s) > 5) then 
            do return "[...]" end;
          else
            local _g1 = _hx_tab_array({}, 0);
            local _g11 = 0;
            while (_g11 < o2.length) do 
              local i = o2[_g11];
              _g11 = _g11 + 1;
              _g1:push(__lua_Boot.__string_rec(i, Std.string(s) .. Std.string(1)));
            end;
            do return Std.string(Std.string("[") .. Std.string(_g1:join(","))) .. Std.string("]") end;
          end;
        else
          if (o.__class__ ~= nil) then 
            do return Std.string(Std.string("{") .. Std.string(__lua_Boot.printClassRec(o, "", Std.string(s) .. Std.string("\t")))) .. Std.string("}") end;
          else
            local fields = __lua_Boot.fieldIterator(o);
            local buffer = ({});
            local first = true;
            _G.table.insert(buffer, "{ ");
            local f = fields;
            while (f:hasNext()) do 
              local f1 = f:next();
              if (first) then 
                first = false;
              else
                _G.table.insert(buffer, ", ");
              end;
              _G.table.insert(buffer, Std.string(Std.string(Std.string("") .. Std.string(Std.string(f1))) .. Std.string(" : ")) .. Std.string(__lua_Boot.__string_rec(o[f1], Std.string(s) .. Std.string("\t"))));
            end;
            _G.table.insert(buffer, " }");
            do return _G.table.concat(buffer, "") end;
          end;
        end;
      end;
    end;
  elseif (_g) == "thread" then 
    do return "<thread>" end;
  elseif (_g) == "userdata" then 
    local mt = _G.getmetatable(o);
    if ((mt ~= nil) and (mt.__tostring ~= nil)) then 
      do return _G.tostring(o) end;
    else
      do return "<userdata>" end;
    end;else
  _G.error("Unknown Lua type",0); end;
end
__lua_Boot.dateStr = function(date) 
  local m = date:getMonth() + 1;
  local d = date:getDate();
  local h = date:getHours();
  local mi = date:getMinutes();
  local s = date:getSeconds();
  do return Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(date:getFullYear()) .. Std.string("-")) .. Std.string(((function() 
    local _hx_1
    if (m < 10) then 
    _hx_1 = Std.string("0") .. Std.string(m); else 
    _hx_1 = Std.string("") .. Std.string(m); end
    return _hx_1
  end )()))) .. Std.string("-")) .. Std.string(((function() 
    local _hx_2
    if (d < 10) then 
    _hx_2 = Std.string("0") .. Std.string(d); else 
    _hx_2 = Std.string("") .. Std.string(d); end
    return _hx_2
  end )()))) .. Std.string(" ")) .. Std.string(((function() 
    local _hx_3
    if (h < 10) then 
    _hx_3 = Std.string("0") .. Std.string(h); else 
    _hx_3 = Std.string("") .. Std.string(h); end
    return _hx_3
  end )()))) .. Std.string(":")) .. Std.string(((function() 
    local _hx_4
    if (mi < 10) then 
    _hx_4 = Std.string("0") .. Std.string(mi); else 
    _hx_4 = Std.string("") .. Std.string(mi); end
    return _hx_4
  end )()))) .. Std.string(":")) .. Std.string(((function() 
    local _hx_5
    if (s < 10) then 
    _hx_5 = Std.string("0") .. Std.string(s); else 
    _hx_5 = Std.string("") .. Std.string(s); end
    return _hx_5
  end )())) end;
end
__lua_Boot.extendsOrImplements = function(cl1,cl2) 
  if ((cl1 == nil) or (cl2 == nil)) then 
    do return false end;
  else
    if (cl1 == cl2) then 
      do return true end;
    else
      if (cl1.__interfaces__ ~= nil) then 
        local intf = cl1.__interfaces__;
        local _g = 1;
        local _g1 = _hx_table.maxn(intf) + 1;
        while (_g < _g1) do 
          _g = _g + 1;
          local i = _g - 1;
          if (__lua_Boot.extendsOrImplements(intf[i], cl2)) then 
            do return true end;
          end;
        end;
      end;
    end;
  end;
  do return __lua_Boot.extendsOrImplements(cl1.__super__, cl2) end;
end
__lua_Boot.fieldIterator = function(o) 
  if (_G.type(o) ~= "table") then 
    do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
      do return nil end;
    end,hasNext=function(self) 
      do return false end;
    end}) end;
  end;
  local tbl = (function() 
    local _hx_1
    if (o.__fields__ ~= nil) then 
    _hx_1 = o.__fields__; else 
    _hx_1 = o; end
    return _hx_1
  end )();
  local cur = _G.pairs(tbl);
  local next_valid = function(tbl1,val) 
    while (__lua_Boot.hiddenFields[val] ~= nil) do 
      val = cur(tbl1, val);
    end;
    do return val end;
  end;
  local cur_val = next_valid(tbl, cur(tbl, nil));
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local ret = cur_val;
    cur_val = next_valid(tbl, cur(tbl, cur_val));
    do return ret end;
  end,hasNext=function(self) 
    do return cur_val ~= nil end;
  end}) end;
end
__lua_Boot.systemName = function() 
  local os = nil;
  if ((jit ~= nil) and (jit.os ~= nil)) then 
    os = jit.os;
    os = __lua_lib_luautf8_Utf8.lower(os);
  else
    local popen_status = false;
    local popen_result = nil;
    popen_status, popen_result = pcall(_G.io.popen, '');
    if (popen_status) then 
      popen_result:close();
      os = __lua_lib_luautf8_Utf8.lower(_G.io.popen("uname -s", "r"):read("*l"));
    else
      os = __lua_lib_luautf8_Utf8.lower(_G.os.getenv("OS"));
    end;
  end;
  local k = __lua_Boot.os_patterns:keys();
  while (k:hasNext()) do 
    local k1 = k:next();
    local _g = 0;
    local ret = __lua_Boot.os_patterns.h[k1];
    if (ret == __haxe_ds_StringMap.tnull) then 
      ret = nil;
    end;
    local _g1 = ret;
    while (_g < _g1.length) do 
      local p = _g1[_g];
      _g = _g + 1;
      if (_G.string.match(os, p) ~= nil) then 
        do return k1 end;
      end;
    end;
  end;
  do return nil end;
end

__lua_UserData.new = {}
__lua_UserData.__name__ = true

__lua_Thread.new = {}
__lua_Thread.__name__ = true

__sys_FileSystem.new = {}
__sys_FileSystem.__name__ = true
__sys_FileSystem.exists = function(path) 
  if (path == nil) then 
    do return false end;
  else
    local _hx_1_res_result, _hx_1_res_message = __lua_lib_luv_fs_FileSystem.fs_stat(path);
    do return _hx_1_res_result ~= nil end;
  end;
end

__sys_Http.new = function(url) 
  local self = _hx_new(__sys_Http.prototype)
  __sys_Http.super(self,url)
  return self
end
__sys_Http.super = function(self,url) 
  self.cnxTimeout = 10;
  __haxe_http_HttpBase.super(self,url);
end
__sys_Http.__name__ = true
__sys_Http.prototype = _hx_a();
__sys_Http.prototype.noShutdown= nil;
__sys_Http.prototype.cnxTimeout= nil;
__sys_Http.prototype.responseHeaders= nil;
__sys_Http.prototype.chunk_size= nil;
__sys_Http.prototype.chunk_buf= nil;
__sys_Http.prototype.file= nil;
__sys_Http.prototype.request = function(self,post) 
  local _gthis = self;
  local output = __haxe_io_BytesOutput.new();
  local old = _hx_bind(self,self.onError);
  local err = false;
  self.onError = function(self,e) 
    _gthis.responseBytes = output:getBytes();
    err = true;
    _gthis.onError = _hx_funcToField(old);
    _gthis:onError(e);
   end;
  post = (post or (self.postBytes ~= nil)) or (self.postData ~= nil);
  self:customRequest(post, output);
  if (not err) then 
    self:success(output:getBytes());
  end;
end
__sys_Http.prototype.customRequest = function(self,post,api,sock,method) 
  self.responseAsString = nil;
  self.responseBytes = nil;
  local url_regexp = EReg.new("^(https?://)?([a-zA-Z\\.0-9_-]+)(:[0-9]+)?(.*)$", "");
  if (not url_regexp:match(self.url)) then 
    self:onError("Invalid URL");
    do return end;
  end;
  local secure = url_regexp:matched(1) == "https://";
  if (sock == nil) then 
    if (secure) then 
      _G.error("Https support in haxe.Http is not implemented for this target",0);
    else
      sock = __sys_net_Socket.new();
    end;
    local timeout = self.cnxTimeout;
    sock.timeout = timeout;
    if (sock._socket ~= nil) then 
      local client = sock._socket;
      client:settimeout(timeout);
    end;
  end;
  local host = url_regexp:matched(2);
  local portString = url_regexp:matched(3);
  local request = url_regexp:matched(4);
  if (__lua_lib_luautf8_Utf8.sub(request, 1, 1) ~= "/") then 
    request = Std.string("/") .. Std.string(request);
  end;
  local port;
  if ((portString == nil) or (portString == "")) then 
    port = (function() 
      local _hx_1
      if (secure) then 
      _hx_1 = 443; else 
      _hx_1 = 80; end
      return _hx_1
    end )();
  else
    local pos = 1;
    local len = __lua_lib_luautf8_Utf8.len(portString) - 1;
    if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(portString)))) then 
      len = __lua_lib_luautf8_Utf8.len(portString);
    else
      if (len < 0) then 
        len = __lua_lib_luautf8_Utf8.len(portString) + len;
      end;
    end;
    if (pos < 0) then 
      pos = __lua_lib_luautf8_Utf8.len(portString) + pos;
    end;
    if (pos < 0) then 
      pos = 0;
    end;
    port = Std.parseInt(__lua_lib_luautf8_Utf8.sub(portString, pos + 1, pos + len));
  end;
  local multipart = self.file ~= nil;
  local boundary = nil;
  local uri = nil;
  if (multipart) then 
    post = true;
    boundary = Std.string(Std.string(Std.string(Std.string(Std.random(1000))) .. Std.string(Std.string(Std.random(1000)))) .. Std.string(Std.string(Std.random(1000)))) .. Std.string(Std.string(Std.random(1000)));
    while (__lua_lib_luautf8_Utf8.len(boundary) < 38) do 
      boundary = Std.string("-") .. Std.string(boundary);
    end;
    local b_b = ({});
    local b_length = 0;
    local _g = 0;
    local _g1 = self.params;
    while (_g < _g1.length) do 
      local p = _g1[_g];
      _g = _g + 1;
      local str = "--";
      _G.table.insert(b_b, str);
      b_length = b_length + __lua_lib_luautf8_Utf8.len(str);
      local str1 = Std.string(boundary);
      _G.table.insert(b_b, str1);
      b_length = b_length + __lua_lib_luautf8_Utf8.len(str1);
      local str2 = "\r\n";
      _G.table.insert(b_b, str2);
      b_length = b_length + __lua_lib_luautf8_Utf8.len(str2);
      local str3 = "Content-Disposition: form-data; name=\"";
      _G.table.insert(b_b, str3);
      b_length = b_length + __lua_lib_luautf8_Utf8.len(str3);
      local str4 = Std.string(p.name);
      _G.table.insert(b_b, str4);
      b_length = b_length + __lua_lib_luautf8_Utf8.len(str4);
      local str5 = "\"";
      _G.table.insert(b_b, str5);
      b_length = b_length + __lua_lib_luautf8_Utf8.len(str5);
      local str6 = "\r\n";
      _G.table.insert(b_b, str6);
      b_length = b_length + __lua_lib_luautf8_Utf8.len(str6);
      local str7 = "\r\n";
      _G.table.insert(b_b, str7);
      b_length = b_length + __lua_lib_luautf8_Utf8.len(str7);
      local str8 = Std.string(p.value);
      _G.table.insert(b_b, str8);
      b_length = b_length + __lua_lib_luautf8_Utf8.len(str8);
      local str9 = "\r\n";
      _G.table.insert(b_b, str9);
      b_length = b_length + __lua_lib_luautf8_Utf8.len(str9);
    end;
    local str10 = "--";
    _G.table.insert(b_b, str10);
    b_length = b_length + __lua_lib_luautf8_Utf8.len(str10);
    local str11 = Std.string(boundary);
    _G.table.insert(b_b, str11);
    b_length = b_length + __lua_lib_luautf8_Utf8.len(str11);
    local str12 = "\r\n";
    _G.table.insert(b_b, str12);
    b_length = b_length + __lua_lib_luautf8_Utf8.len(str12);
    local str13 = "Content-Disposition: form-data; name=\"";
    _G.table.insert(b_b, str13);
    b_length = b_length + __lua_lib_luautf8_Utf8.len(str13);
    local str14 = Std.string(self.file.param);
    _G.table.insert(b_b, str14);
    b_length = b_length + __lua_lib_luautf8_Utf8.len(str14);
    local str15 = "\"; filename=\"";
    _G.table.insert(b_b, str15);
    b_length = b_length + __lua_lib_luautf8_Utf8.len(str15);
    local str16 = Std.string(self.file.filename);
    _G.table.insert(b_b, str16);
    b_length = b_length + __lua_lib_luautf8_Utf8.len(str16);
    local str17 = "\"";
    _G.table.insert(b_b, str17);
    b_length = b_length + __lua_lib_luautf8_Utf8.len(str17);
    local str18 = "\r\n";
    _G.table.insert(b_b, str18);
    b_length = b_length + __lua_lib_luautf8_Utf8.len(str18);
    local str19 = Std.string(Std.string(Std.string(Std.string("Content-Type: ") .. Std.string(self.file.mimeType)) .. Std.string("\r\n")) .. Std.string("\r\n"));
    _G.table.insert(b_b, str19);
    b_length = b_length + __lua_lib_luautf8_Utf8.len(str19);
    uri = _G.table.concat(b_b);
  else
    local _g2 = 0;
    local _g11 = self.params;
    while (_g2 < _g11.length) do 
      local p1 = _g11[_g2];
      _g2 = _g2 + 1;
      if (uri == nil) then 
        uri = "";
      else
        uri = Std.string(uri) .. Std.string("&");
      end;
      uri = Std.string(uri) .. Std.string((Std.string(Std.string(StringTools.urlEncode(p1.name)) .. Std.string("=")) .. Std.string(StringTools.urlEncode(Std.string("") .. Std.string(p1.value)))));
    end;
  end;
  local b = __haxe_io_BytesOutput.new();
  if (method ~= nil) then 
    b:writeString(method);
    b:writeString(" ");
  else
    if (post) then 
      b:writeString("POST ");
    else
      b:writeString("GET ");
    end;
  end;
  if (__sys_Http.PROXY ~= nil) then 
    b:writeString("http://");
    b:writeString(host);
    if (port ~= 80) then 
      b:writeString(":");
      b:writeString(Std.string("") .. Std.string(port));
    end;
  end;
  b:writeString(request);
  if (not post and (uri ~= nil)) then 
    local startIndex = 0;
    if (startIndex == nil) then 
      startIndex = 1;
    else
      startIndex = startIndex + 1;
    end;
    local r = __lua_lib_luautf8_Utf8.find(request, "?", startIndex, true);
    if ((function() 
      local _hx_2
      if ((r ~= nil) and (r > 0)) then 
      _hx_2 = r - 1; else 
      _hx_2 = -1; end
      return _hx_2
    end )() >= 0) then 
      b:writeString("&");
    else
      b:writeString("?");
    end;
    b:writeString(uri);
  end;
  b:writeString(Std.string(Std.string(" HTTP/1.1\r\nHost: ") .. Std.string(host)) .. Std.string("\r\n"));
  if (self.postData ~= nil) then 
    self.postBytes = __haxe_io_Bytes.ofString(self.postData);
    self.postData = nil;
  end;
  if (self.postBytes ~= nil) then 
    b:writeString(Std.string(Std.string("Content-Length: ") .. Std.string(self.postBytes.length)) .. Std.string("\r\n"));
  else
    if (post and (uri ~= nil)) then 
      if (multipart or not Lambda.exists(self.headers, function(h) 
        do return h.name == "Content-Type" end;
      end)) then 
        b:writeString("Content-Type: ");
        if (multipart) then 
          b:writeString("multipart/form-data");
          b:writeString("; boundary=");
          b:writeString(boundary);
        else
          b:writeString("application/x-www-form-urlencoded");
        end;
        b:writeString("\r\n");
      end;
      if (multipart) then 
        b:writeString(Std.string(Std.string("Content-Length: ") .. Std.string((((__lua_lib_luautf8_Utf8.len(uri) + self.file.size) + __lua_lib_luautf8_Utf8.len(boundary)) + 6))) .. Std.string("\r\n"));
      else
        b:writeString(Std.string(Std.string("Content-Length: ") .. Std.string(__lua_lib_luautf8_Utf8.len(uri))) .. Std.string("\r\n"));
      end;
    end;
  end;
  b:writeString("Connection: close\r\n");
  local _g3 = 0;
  local _g12 = self.headers;
  while (_g3 < _g12.length) do 
    local h1 = _g12[_g3];
    _g3 = _g3 + 1;
    b:writeString(h1.name);
    b:writeString(": ");
    b:writeString(h1.value);
    b:writeString("\r\n");
  end;
  b:writeString("\r\n");
  if (self.postBytes ~= nil) then 
    b:writeFullBytes(self.postBytes, 0, self.postBytes.length);
  else
    if (post and (uri ~= nil)) then 
      b:writeString(uri);
    end;
  end;
  local _hx_status, _hx_result = pcall(function() 
  
      if (__sys_Http.PROXY ~= nil) then 
        sock:connect(__sys_net_Host.new(__sys_Http.PROXY.host), __sys_Http.PROXY.port);
      else
        sock:connect(__sys_net_Host.new(host), port);
      end;
      if (multipart) then 
        self:writeBody(b, self.file.io, self.file.size, boundary, sock);
      else
        self:writeBody(b, nil, 0, nil, sock);
      end;
      self:readHttpResponse(api, sock);
      sock:close();
    return _hx_pcall_default
  end)
  if not _hx_status and _hx_result == "_hx_pcall_break" then
  elseif not _hx_status then 
  
    local _hx_3 = _hx_result
    local e = _hx_3
    local _hx_status, _hx_result = pcall(function() 
    
        sock:close();
      return _hx_pcall_default
    end)
    if not _hx_status and _hx_result == "_hx_pcall_break" then
    elseif not _hx_status then 
    
      local _hx_4 = _hx_result
      local e1 = _hx_4
    elseif _hx_result ~= _hx_pcall_default then
      return _hx_result
    end;
    self:onError(Std.string(e));
  elseif _hx_result ~= _hx_pcall_default then
    return _hx_result
  end;
end
__sys_Http.prototype.writeBody = function(self,body,fileInput,fileSize,boundary,sock) 
  if (body ~= nil) then 
    local bytes = body:getBytes();
    sock.output:writeFullBytes(bytes, 0, bytes.length);
  end;
  if (boundary ~= nil) then 
    local bufsize = 4096;
    local buf = __haxe_io_Bytes.alloc(bufsize);
    while (fileSize > 0) do 
      local size = (function() 
        local _hx_1
        if (fileSize > bufsize) then 
        _hx_1 = bufsize; else 
        _hx_1 = fileSize; end
        return _hx_1
      end )();
      local len = 0;
      local _hx_status, _hx_result = pcall(function() 
      
          len = fileInput:readBytes(buf, 0, size);
        return _hx_pcall_default
      end)
      if not _hx_status and _hx_result == "_hx_pcall_break" then
        break
      elseif not _hx_status then 
      
        local _hx_2 = _hx_result
        if( __lua_Boot.__instanceof(_hx_2,__haxe_io_Eof) ) then 
          local e = _hx_2
          break;
        else _G.error(_hx_2)
        end
      elseif _hx_result ~= _hx_pcall_default then
        return _hx_result
      end;
      sock.output:writeFullBytes(buf, 0, len);
      fileSize = fileSize - len;
    end;
    sock.output:writeString("\r\n");
    sock.output:writeString("--");
    sock.output:writeString(boundary);
    sock.output:writeString("--");
  end;
end
__sys_Http.prototype.readHttpResponse = function(self,api,sock) 
  local b = __haxe_io_BytesBuffer.new();
  local k = 4;
  local s = __haxe_io_Bytes.alloc(4);
  local timeout = self.cnxTimeout;
  sock.timeout = timeout;
  if (sock._socket ~= nil) then 
    local client = sock._socket;
    client:settimeout(timeout);
  end;
  local _hx_continue_1 = false;
  while (true) do repeat 
    local p = sock.input:readBytes(s, 0, k);
    while (p ~= k) do 
      p = p + sock.input:readBytes(s, p, k - p);
    end;
    if ((k < 0) or (k > s.length)) then 
      _G.error(__haxe_io_Error.OutsideBounds,0);
    end;
    local b1 = b.b;
    local b2 = s.b;
    local _g = 0;
    local _g1 = k;
    while (_g < _g1) do 
      _g = _g + 1;
      local i = _g - 1;
      b.b:push(b2[i]);
    end;
    local k1 = k;
    if (k1) == 1 then 
      local c = s.b[0];
      if (c == 10) then 
        _hx_continue_1 = true;break;
      end;
      if (c == 13) then 
        k = 3;
      else
        k = 4;
      end;
    elseif (k1) == 2 then 
      local c1 = s.b[1];
      if (c1 == 10) then 
        if (s.b[0] == 13) then 
          _hx_continue_1 = true;break;
        end;
        k = 4;
      else
        if (c1 == 13) then 
          k = 3;
        else
          k = 4;
        end;
      end;
    elseif (k1) == 3 then 
      local c2 = s.b[2];
      if (c2 == 10) then 
        if (s.b[1] ~= 13) then 
          k = 4;
        else
          if (s.b[0] ~= 10) then 
            k = 2;
          else
            _hx_continue_1 = true;break;
          end;
        end;
      else
        if (c2 == 13) then 
          if ((s.b[1] ~= 10) or (s.b[0] ~= 13)) then 
            k = 1;
          else
            k = 3;
          end;
        else
          k = 4;
        end;
      end;
    elseif (k1) == 4 then 
      local c3 = s.b[3];
      if (c3 == 10) then 
        if (s.b[2] ~= 13) then 
          break;
        else
          if ((s.b[1] ~= 10) or (s.b[0] ~= 13)) then 
            k = 2;
          else
            _hx_continue_1 = true;break;
          end;
        end;
      else
        if (c3 == 13) then 
          if ((s.b[2] ~= 10) or (s.b[1] ~= 13)) then 
            k = 3;
          else
            k = 1;
          end;
        end;
      end; end;until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
  local _this = b:getBytes():toString();
  local idx = 1;
  local ret = _hx_tab_array({}, 0);
  local delim_offset = (function() 
    local _hx_1
    if (__lua_lib_luautf8_Utf8.len("\r\n") > 0) then 
    _hx_1 = __lua_lib_luautf8_Utf8.len("\r\n"); else 
    _hx_1 = 1; end
    return _hx_1
  end )();
  while (idx ~= nil) do 
    local newidx = 0;
    if (__lua_lib_luautf8_Utf8.len("\r\n") > 0) then 
      newidx = __lua_lib_luautf8_Utf8.find(_this, "\r\n", idx, true);
    else
      if (idx >= __lua_lib_luautf8_Utf8.len(_this)) then 
        newidx = nil;
      else
        newidx = idx + 1;
      end;
    end;
    if (newidx ~= nil) then 
      local match = __lua_lib_luautf8_Utf8.sub(_this, idx, newidx - 1);
      ret:push(match);
      idx = newidx + __lua_lib_luautf8_Utf8.len("\r\n");
    else
      ret:push(__lua_lib_luautf8_Utf8.sub(_this, idx, __lua_lib_luautf8_Utf8.len(_this)));
      idx = nil;
    end;
  end;
  local headers = ret;
  local response = headers:shift();
  local idx1 = 1;
  local ret1 = _hx_tab_array({}, 0);
  local delim_offset1 = (function() 
    local _hx_2
    if (__lua_lib_luautf8_Utf8.len(" ") > 0) then 
    _hx_2 = __lua_lib_luautf8_Utf8.len(" "); else 
    _hx_2 = 1; end
    return _hx_2
  end )();
  while (idx1 ~= nil) do 
    local newidx1 = 0;
    if (__lua_lib_luautf8_Utf8.len(" ") > 0) then 
      newidx1 = __lua_lib_luautf8_Utf8.find(response, " ", idx1, true);
    else
      if (idx1 >= __lua_lib_luautf8_Utf8.len(response)) then 
        newidx1 = nil;
      else
        newidx1 = idx1 + 1;
      end;
    end;
    if (newidx1 ~= nil) then 
      local match1 = __lua_lib_luautf8_Utf8.sub(response, idx1, newidx1 - 1);
      ret1:push(match1);
      idx1 = newidx1 + __lua_lib_luautf8_Utf8.len(" ");
    else
      ret1:push(__lua_lib_luautf8_Utf8.sub(response, idx1, __lua_lib_luautf8_Utf8.len(response)));
      idx1 = nil;
    end;
  end;
  local rp = ret1;
  local status = Std.parseInt(rp[1]);
  if ((status == 0) or (status == nil)) then 
    _G.error("Response status error",0);
  end;
  headers:pop();
  headers:pop();
  self.responseHeaders = __haxe_ds_StringMap.new();
  local size = nil;
  local chunked = false;
  local _g2 = 0;
  while (_g2 < headers.length) do 
    local hline = headers[_g2];
    _g2 = _g2 + 1;
    local idx2 = 1;
    local ret2 = _hx_tab_array({}, 0);
    local delim_offset2 = (function() 
      local _hx_3
      if (__lua_lib_luautf8_Utf8.len(": ") > 0) then 
      _hx_3 = __lua_lib_luautf8_Utf8.len(": "); else 
      _hx_3 = 1; end
      return _hx_3
    end )();
    while (idx2 ~= nil) do 
      local newidx2 = 0;
      if (__lua_lib_luautf8_Utf8.len(": ") > 0) then 
        newidx2 = __lua_lib_luautf8_Utf8.find(hline, ": ", idx2, true);
      else
        if (idx2 >= __lua_lib_luautf8_Utf8.len(hline)) then 
          newidx2 = nil;
        else
          newidx2 = idx2 + 1;
        end;
      end;
      if (newidx2 ~= nil) then 
        local match2 = __lua_lib_luautf8_Utf8.sub(hline, idx2, newidx2 - 1);
        ret2:push(match2);
        idx2 = newidx2 + __lua_lib_luautf8_Utf8.len(": ");
      else
        ret2:push(__lua_lib_luautf8_Utf8.sub(hline, idx2, __lua_lib_luautf8_Utf8.len(hline)));
        idx2 = nil;
      end;
    end;
    local a = ret2;
    local hname = a:shift();
    local hval = (function() 
      local _hx_4
      if (a.length == 1) then 
      _hx_4 = a[0]; else 
      _hx_4 = a:join(": "); end
      return _hx_4
    end )();
    hval = StringTools.ltrim(StringTools.rtrim(hval));
    local _this1 = self.responseHeaders;
    if (hval == nil) then 
      _this1.h[hname] = __haxe_ds_StringMap.tnull;
    else
      _this1.h[hname] = hval;
    end;
    local _g3 = __lua_lib_luautf8_Utf8.lower(hname);
    if (_g3) == "content-length" then 
      size = Std.parseInt(hval);
    elseif (_g3) == "transfer-encoding" then 
      chunked = __lua_lib_luautf8_Utf8.lower(hval) == "chunked"; end;
  end;
  self:onStatus(status);
  local chunk_re = EReg.new("^([0-9A-Fa-f]+)[ ]*\r\n", "m");
  self.chunk_size = nil;
  self.chunk_buf = nil;
  local bufsize = 1024;
  local buf = __haxe_io_Bytes.alloc(bufsize);
  if (chunked) then 
    local _hx_status, _hx_result = pcall(function() 
    
        while (true) do 
          local len = sock.input:readBytes(buf, 0, bufsize);
          if (not self:readChunk(chunk_re, api, buf, len)) then 
            break;
          end;
        end;
      return _hx_pcall_default
    end)
    if not _hx_status and _hx_result == "_hx_pcall_break" then
    elseif not _hx_status then 
    
      local _hx_5 = _hx_result
      if( __lua_Boot.__instanceof(_hx_5,__haxe_io_Eof) ) then 
        local e = _hx_5
        _G.error("Transfer aborted",0);
      else _G.error(_hx_5)
      end
    elseif _hx_result ~= _hx_pcall_default then
      return _hx_result
    end;
  else
    if (size == nil) then 
      if (not self.noShutdown) then 
        sock:shutdown(false, true);
      end;
      local _hx_status, _hx_result = pcall(function() 
      
          while (true) do 
            local len1 = sock.input:readBytes(buf, 0, bufsize);
            if (len1 == 0) then 
              break;
            end;
            api:writeBytes(buf, 0, len1);
          end;
        return _hx_pcall_default
      end)
      if not _hx_status and _hx_result == "_hx_pcall_break" then
      elseif not _hx_status then 
      
        local _hx_6 = _hx_result
        if( __lua_Boot.__instanceof(_hx_6,__haxe_io_Eof) ) then 
          local e1 = _hx_6
        else _G.error(_hx_6)
        end
      elseif _hx_result ~= _hx_pcall_default then
        return _hx_result
      end;
    else
      api:prepare(size);
      local _hx_status, _hx_result = pcall(function() 
      
          while (size > 0) do 
            local len2 = sock.input:readBytes(buf, 0, (function() 
              local _hx_7
              if (size > bufsize) then 
              _hx_7 = bufsize; else 
              _hx_7 = size; end
              return _hx_7
            end )());
            api:writeBytes(buf, 0, len2);
            size = size - len2;
          end;
        return _hx_pcall_default
      end)
      if not _hx_status and _hx_result == "_hx_pcall_break" then
      elseif not _hx_status then 
      
        local _hx_8 = _hx_result
        if( __lua_Boot.__instanceof(_hx_8,__haxe_io_Eof) ) then 
          local e2 = _hx_8
          _G.error("Transfer aborted",0);
        else _G.error(_hx_8)
        end
      elseif _hx_result ~= _hx_pcall_default then
        return _hx_result
      end;
    end;
  end;
  if (chunked and ((self.chunk_size ~= nil) or (self.chunk_buf ~= nil))) then 
    _G.error("Invalid chunk",0);
  end;
  if ((status < 200) or (status >= 400)) then 
    _G.error(Std.string("Http Error #") .. Std.string(status),0);
  end;
  api:close();
end
__sys_Http.prototype.readChunk = function(self,chunk_re,api,buf,len) 
  if (self.chunk_size == nil) then 
    if (self.chunk_buf ~= nil) then 
      local b = __haxe_io_BytesBuffer.new();
      local src = self.chunk_buf;
      local b1 = b.b;
      local b2 = src.b;
      local _g = 0;
      local _g1 = src.length;
      while (_g < _g1) do 
        _g = _g + 1;
        local i = _g - 1;
        b.b:push(b2[i]);
      end;
      if ((len < 0) or (len > buf.length)) then 
        _G.error(__haxe_io_Error.OutsideBounds,0);
      end;
      local b11 = b.b;
      local b21 = buf.b;
      local _g2 = 0;
      local _g11 = len;
      while (_g2 < _g11) do 
        _g2 = _g2 + 1;
        local i1 = _g2 - 1;
        b.b:push(b21[i1]);
      end;
      buf = b:getBytes();
      len = len + self.chunk_buf.length;
      self.chunk_buf = nil;
    end;
    if (chunk_re:match(buf:toString())) then 
      local p = chunk_re:matchedPos();
      if (p.len <= len) then 
        local cstr = chunk_re:matched(1);
        self.chunk_size = Std.parseInt(Std.string("0x") .. Std.string(cstr));
        if (self.chunk_size == 0) then 
          self.chunk_size = nil;
          self.chunk_buf = nil;
          do return false end;
        end;
        len = len - p.len;
        do return self:readChunk(chunk_re, api, buf:sub(p.len, len), len) end;
      end;
    end;
    if (len > 10) then 
      self:onError("Invalid chunk");
      do return false end;
    end;
    self.chunk_buf = buf:sub(0, len);
    do return true end;
  end;
  if (self.chunk_size > len) then 
    local tmp = self;
    tmp.chunk_size = tmp.chunk_size - len;
    api:writeBytes(buf, 0, len);
    do return true end;
  end;
  local _end = self.chunk_size + 2;
  if (len >= _end) then 
    if (self.chunk_size > 0) then 
      api:writeBytes(buf, 0, self.chunk_size);
    end;
    len = len - _end;
    self.chunk_size = nil;
    if (len == 0) then 
      do return true end;
    end;
    do return self:readChunk(chunk_re, api, buf:sub(_end, len), len) end;
  end;
  if (self.chunk_size > 0) then 
    api:writeBytes(buf, 0, self.chunk_size);
  end;
  local tmp1 = self;
  tmp1.chunk_size = tmp1.chunk_size - len;
  do return true end
end

__sys_Http.prototype.__class__ =  __sys_Http
__sys_Http.__super__ = __haxe_http_HttpBase
setmetatable(__sys_Http.prototype,{__index=__haxe_http_HttpBase.prototype})

__sys_io_Process.new = function(cmd,args,detached) 
  local self = _hx_new(__sys_io_Process.prototype)
  __sys_io_Process.super(self,cmd,args,detached)
  return self
end
__sys_io_Process.super = function(self,cmd,args,detached) 
  local _gthis = self;
  if (detached) then 
    _G.error("Detached process is not supported on this platform",0);
  end;
  local _stdout = __lua_lib_luv_Pipe.new_pipe(false);
  local _stderr = __lua_lib_luv_Pipe.new_pipe(false);
  local _stdin = __lua_lib_luv_Pipe.new_pipe(false);
  self.stdout = __sys_io__Process_ProcessInput.new(_stdout);
  self.stderr = __sys_io__Process_ProcessInput.new(_stderr);
  self.stdin = __sys_io__Process_ProcessOutput.new(_stdin);
  local stdio = ({_stdin,_stdout,_stderr});
  local opt = _hx_o({__fields__={args=true,stdio=true},args=__sys_io_Process.setArgs(cmd, args),stdio=stdio});
  local _hx_1_p_handle, _hx_1_p_pid = __lua_lib_luv_Process.spawn(__sys_io_Process._shell, opt, function(code,signal) 
    _gthis._code = code;
  end);
  if (_hx_1_p_handle == nil) then 
    _G.error(_hx_1_p_pid,0);
  end;
  self._pid = _hx_1_p_pid;
  self._handle = _hx_1_p_handle;
end
__sys_io_Process.__name__ = true
__sys_io_Process.setArgs = function(cmd,args) 
  local pargs = ({});
  local idx = 1;
  if (__sys_FileSystem.exists(cmd)) then 
    cmd = Std.string(Std.string("\"") .. Std.string(cmd)) .. Std.string("\"");
  end;
  local all = _hx_tab_array({[0]=cmd}, 1);
  if (args ~= nil) then 
    local _g = 0;
    while (_g < args.length) do 
      local a = args[_g];
      _g = _g + 1;
      all:push(__sys_io_Process.argQuote(a));
    end;
  end;
  if (Sys.systemName() == "Windows") then 
    idx = idx + 1;
    pargs[idx - 1] = "/s";
    idx = idx + 1;
    pargs[idx - 1] = "/c";
    idx = idx + 1;
    pargs[idx - 1] = all:join(" ");
  else
    idx = idx + 1;
    pargs[idx - 1] = "-c";
    idx = idx + 1;
    pargs[idx - 1] = all:join(" ");
  end;
  do return pargs end;
end
__sys_io_Process.prototype = _hx_a();
__sys_io_Process.prototype._pid= nil;
__sys_io_Process.prototype._handle= nil;
__sys_io_Process.prototype._code= nil;
__sys_io_Process.prototype.stdout= nil;
__sys_io_Process.prototype.stderr= nil;
__sys_io_Process.prototype.stdin= nil;

__sys_io_Process.prototype.__class__ =  __sys_io_Process

__sys_io__Process_ProcessInput.new = function(pipe) 
  local self = _hx_new(__sys_io__Process_ProcessInput.prototype)
  __sys_io__Process_ProcessInput.super(self,pipe)
  return self
end
__sys_io__Process_ProcessInput.super = function(self,pipe) 
  self.b = pipe;
  self._eof = false;
end
__sys_io__Process_ProcessInput.__name__ = true
__sys_io__Process_ProcessInput.prototype = _hx_a();
__sys_io__Process_ProcessInput.prototype.b= nil;
__sys_io__Process_ProcessInput.prototype.buf= nil;
__sys_io__Process_ProcessInput.prototype.idx= nil;
__sys_io__Process_ProcessInput.prototype._eof= nil;
__sys_io__Process_ProcessInput.prototype.readBytes = function(self,s,pos,len) 
  if (self._eof) then 
    _G.error(__haxe_io_Eof.new(),0);
  end;
  do return __haxe_io_Input.prototype.readBytes(self,s,pos,len) end
end
__sys_io__Process_ProcessInput.prototype.readByte = function(self) 
  local _gthis = self;
  local err_str = nil;
  if ((self.buf == nil) or (self.idx >= _G.string.len(self.buf))) then 
    self.buf = nil;
    self.idx = 0;
    local pending = true;
    self.b:read_start(function(err,chunk) 
      if (chunk ~= nil) then 
        if (_gthis.buf ~= nil) then 
          _gthis.buf = Std.string(_gthis.buf) .. Std.string(chunk);
        else
          _gthis.buf = chunk;
        end;
      end;
      if (err ~= nil) then 
        err_str = err;
      end;
      pending = false;
    end);
    while (pending) do 
      __lua_lib_luv_Loop.run();
    end;
  end;
  if (self.buf == nil) then 
    self._eof = true;
    _G.error(__haxe_io_Eof.new(),0);
  end;
  if (err_str ~= nil) then 
    _G.error(err_str,0);
  end;
  local code = _G.string.byte(self.buf, (function() 
  local _hx_obj = self;
  local _hx_fld = 'idx';
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _hx_obj[_hx_fld];
   end)());
  do return code end
end
__sys_io__Process_ProcessInput.prototype.close = function(self) 
  self.b:close();
end

__sys_io__Process_ProcessInput.prototype.__class__ =  __sys_io__Process_ProcessInput
__sys_io__Process_ProcessInput.__super__ = __haxe_io_Input
setmetatable(__sys_io__Process_ProcessInput.prototype,{__index=__haxe_io_Input.prototype})

__sys_io__Process_ProcessOutput.new = function(pipe) 
  local self = _hx_new(__sys_io__Process_ProcessOutput.prototype)
  __sys_io__Process_ProcessOutput.super(self,pipe)
  return self
end
__sys_io__Process_ProcessOutput.super = function(self,pipe) 
  self.b = pipe;
  self:set_bigEndian(__lua_Boot.platformBigEndian);
end
__sys_io__Process_ProcessOutput.__name__ = true
__sys_io__Process_ProcessOutput.prototype = _hx_a();
__sys_io__Process_ProcessOutput.prototype.b= nil;
__sys_io__Process_ProcessOutput.prototype.writeByte = function(self,c) 
  self.b:write(_G.string.char(c));
end
__sys_io__Process_ProcessOutput.prototype.close = function(self) 
  self.b:close();
end

__sys_io__Process_ProcessOutput.prototype.__class__ =  __sys_io__Process_ProcessOutput
__sys_io__Process_ProcessOutput.__super__ = __haxe_io_Output
setmetatable(__sys_io__Process_ProcessOutput.prototype,{__index=__haxe_io_Output.prototype})

__sys_net_Host.new = function(name) 
  local self = _hx_new(__sys_net_Host.prototype)
  __sys_net_Host.super(self,name)
  return self
end
__sys_net_Host.super = function(self,name) 
  self.host = name;
  if (_G.string.find(name, "(%d+)%.(%d+)%.(%d+)%.(%d+)") ~= nil) then 
    self._ip = name;
  else
    local _hx_1_res_result, _hx_1_res_message = __lua_lib_luv_net_Dns.getaddrinfo(name);
    if (_hx_1_res_result == nil) then 
      _G.error("Unrecognized node name",0);
    end;
    self._ip = _hx_funcToField(_hx_1_res_result[1].addr);
    if (self._ip == "::1") then 
      self._ip = "127.0.0.0";
    end;
  end;
  local num = 0;
  local _g = 0;
  local _this = self._ip;
  local idx = 1;
  local ret = _hx_tab_array({}, 0);
  local delim_offset = (function() 
    local _hx_2
    if (__lua_lib_luautf8_Utf8.len(".") > 0) then 
    _hx_2 = __lua_lib_luautf8_Utf8.len("."); else 
    _hx_2 = 1; end
    return _hx_2
  end )();
  while (idx ~= nil) do 
    local newidx = 0;
    if (__lua_lib_luautf8_Utf8.len(".") > 0) then 
      newidx = __lua_lib_luautf8_Utf8.find(_this, ".", idx, true);
    else
      if (idx >= __lua_lib_luautf8_Utf8.len(_this)) then 
        newidx = nil;
      else
        newidx = idx + 1;
      end;
    end;
    if (newidx ~= nil) then 
      local match = __lua_lib_luautf8_Utf8.sub(_this, idx, newidx - 1);
      ret:push(match);
      idx = newidx + __lua_lib_luautf8_Utf8.len(".");
    else
      ret:push(__lua_lib_luautf8_Utf8.sub(_this, idx, __lua_lib_luautf8_Utf8.len(_this)));
      idx = nil;
    end;
  end;
  local _g1 = ret;
  while (_g < _g1.length) do 
    local a = _g1[_g];
    _g = _g + 1;
    num = (num * 256) + _G.tonumber(a);
  end;
  self.ip = num;
end
__sys_net_Host.__name__ = true
__sys_net_Host.prototype = _hx_a();
__sys_net_Host.prototype.host= nil;
__sys_net_Host.prototype.ip= nil;
__sys_net_Host.prototype._ip= nil;

__sys_net_Host.prototype.__class__ =  __sys_net_Host

__sys_net_Socket.new = function() 
  local self = _hx_new(__sys_net_Socket.prototype)
  __sys_net_Socket.super(self)
  return self
end
__sys_net_Socket.super = function(self) 
  self.timeout = nil;
end
__sys_net_Socket.__name__ = true
__sys_net_Socket.prototype = _hx_a();
__sys_net_Socket.prototype.input= nil;
__sys_net_Socket.prototype.output= nil;
__sys_net_Socket.prototype._socket= nil;
__sys_net_Socket.prototype.timeout= nil;
__sys_net_Socket.prototype.close = function(self) 
  self._socket:close();
end
__sys_net_Socket.prototype.connect = function(self,host,port) 
  local _hx_1_res_result, _hx_1_res_message = __lua_lib_luasocket_Socket.connect(host.host, port);
  if (_hx_1_res_message ~= nil) then 
    _G.error(Std.string("Socket Error : ") .. Std.string(_hx_1_res_message),0);
  end;
  self.input = __sys_net__Socket_SocketInput.new(_hx_1_res_result);
  self.output = __sys_net__Socket_SocketOutput.new(_hx_1_res_result);
  self._socket = _hx_1_res_result;
  self._socket:settimeout(self.timeout);
end
__sys_net_Socket.prototype.shutdown = function(self,read,write) 
  local client = self._socket;
  if (read) then 
    if (write) then 
      _hx_box_mr(_hx_table.pack(client:shutdown("both")), {"result", "message"});
    else
      _hx_box_mr(_hx_table.pack(client:shutdown("receive")), {"result", "message"});
    end;
  else
    if (write == true) then 
      _hx_box_mr(_hx_table.pack(client:shutdown("send")), {"result", "message"});
    end;
  end;
end

__sys_net_Socket.prototype.__class__ =  __sys_net_Socket

__sys_net__Socket_SocketInput.new = function(tcp) 
  local self = _hx_new(__sys_net__Socket_SocketInput.prototype)
  __sys_net__Socket_SocketInput.super(self,tcp)
  return self
end
__sys_net__Socket_SocketInput.super = function(self,tcp) 
  self.tcp = tcp;
end
__sys_net__Socket_SocketInput.__name__ = true
__sys_net__Socket_SocketInput.prototype = _hx_a();
__sys_net__Socket_SocketInput.prototype.tcp= nil;
__sys_net__Socket_SocketInput.prototype.readByte = function(self) 
  local _hx_1_res_result, _hx_1_res_message = self.tcp:receive(1);
  if (_hx_1_res_message == "closed") then 
    _G.error(__haxe_io_Eof.new(),0);
  else
    if (_hx_1_res_message ~= nil) then 
      _G.error(Std.string("Error : ") .. Std.string(_hx_1_res_message),0);
    end;
  end;
  do return __lua_lib_luautf8_Utf8.byte(_hx_1_res_result, 1) end
end
__sys_net__Socket_SocketInput.prototype.readBytes = function(self,s,pos,len) 
  local leftToRead = len;
  local b = s.b;
  if (((pos < 0) or (len < 0)) or ((pos + len) > s.length)) then 
    _G.error(__haxe_io_Error.OutsideBounds,0);
  end;
  local readCount = 0;
  local _hx_status, _hx_result = pcall(function() 
  
      while (leftToRead > 0) do 
        b[pos] = self:readByte();
        pos = pos + 1;
        readCount = readCount + 1;
        leftToRead = leftToRead - 1;
      end;
    return _hx_pcall_default
  end)
  if not _hx_status and _hx_result == "_hx_pcall_break" then
  elseif not _hx_status then 
  
    local _hx_1 = _hx_result
    if( __lua_Boot.__instanceof(_hx_1,__haxe_io_Eof) ) then 
      local e = _hx_1
      if (readCount == 0) then 
        _G.error(e,0);
      end;
    else _G.error(_hx_1)
    end
  elseif _hx_result ~= _hx_pcall_default then
    return _hx_result
  end;
  do return readCount end
end

__sys_net__Socket_SocketInput.prototype.__class__ =  __sys_net__Socket_SocketInput
__sys_net__Socket_SocketInput.__super__ = __haxe_io_Input
setmetatable(__sys_net__Socket_SocketInput.prototype,{__index=__haxe_io_Input.prototype})

__sys_net__Socket_SocketOutput.new = function(tcp) 
  local self = _hx_new(__sys_net__Socket_SocketOutput.prototype)
  __sys_net__Socket_SocketOutput.super(self,tcp)
  return self
end
__sys_net__Socket_SocketOutput.super = function(self,tcp) 
  self.tcp = tcp;
end
__sys_net__Socket_SocketOutput.__name__ = true
__sys_net__Socket_SocketOutput.prototype = _hx_a();
__sys_net__Socket_SocketOutput.prototype.tcp= nil;
__sys_net__Socket_SocketOutput.prototype.writeByte = function(self,c) 
  local char = _G.string.char(c);
  local _hx_1_res_result, _hx_1_res_message = self.tcp:send(char);
  if (_hx_1_res_message ~= nil) then 
    _G.error(Std.string("Error : Socket writeByte : ") .. Std.string(_hx_1_res_message),0);
  end;
end
__sys_net__Socket_SocketOutput.prototype.writeBytes = function(self,s,pos,len) 
  if (((pos < 0) or (len < 0)) or ((pos + len) > s.length)) then 
    _G.error(__haxe_io_Error.OutsideBounds,0);
  end;
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = s.b:slice(pos, pos + len);
  while (_g1 < _g2.length) do 
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(_G.string.char(i));
  end;
  local b = _g;
  local encoded = _G.table.concat(b, nil, 0);
  local _hx_1_res_result, _hx_1_res_message = self.tcp:send(encoded);
  if (_hx_1_res_message ~= nil) then 
    _G.error(Std.string("Error : Socket writeByte : ") .. Std.string(_hx_1_res_message),0);
  end;
  do return len end
end

__sys_net__Socket_SocketOutput.prototype.__class__ =  __sys_net__Socket_SocketOutput
__sys_net__Socket_SocketOutput.__super__ = __haxe_io_Output
setmetatable(__sys_net__Socket_SocketOutput.prototype,{__index=__haxe_io_Output.prototype})

__tink_chunk_ChunkBase.new = {}
__tink_chunk_ChunkBase.__name__ = true
__tink_chunk_ChunkBase.prototype = _hx_a();
__tink_chunk_ChunkBase.prototype.flattened= nil;
__tink_chunk_ChunkBase.prototype.getCursor = function(self) 
  if (self.flattened == nil) then 
    self:flatten((function() 
    self.flattened = _hx_tab_array({}, 0); return self.flattened end)());
  end;
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self.flattened;
  while (_g1 < _g2.length) do 
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  do return __tink_chunk_ChunkCursor.create(_g) end
end
__tink_chunk_ChunkBase.prototype.flatten = function(self,into) 
end

__tink_chunk_ChunkBase.prototype.__class__ =  __tink_chunk_ChunkBase

__tink_chunk_ChunkObject.new = {}
__tink_chunk_ChunkObject.__name__ = true
__tink_chunk_ChunkObject.prototype = _hx_a();
__tink_chunk_ChunkObject.prototype.getCursor= nil;
__tink_chunk_ChunkObject.prototype.flatten= nil;
__tink_chunk_ChunkObject.prototype.getLength= nil;
__tink_chunk_ChunkObject.prototype.slice= nil;
__tink_chunk_ChunkObject.prototype.toString= nil;
__tink_chunk_ChunkObject.prototype.toBytes= nil;
__tink_chunk_ChunkObject.prototype.blitTo= nil;

__tink_chunk_ChunkObject.prototype.__class__ =  __tink_chunk_ChunkObject

__tink__Chunk_EmptyChunk.new = function() 
  local self = _hx_new(__tink__Chunk_EmptyChunk.prototype)
  __tink__Chunk_EmptyChunk.super(self)
  return self
end
__tink__Chunk_EmptyChunk.super = function(self) 
end
__tink__Chunk_EmptyChunk.__name__ = true
__tink__Chunk_EmptyChunk.__interfaces__ = {__tink_chunk_ChunkObject}
__tink__Chunk_EmptyChunk.prototype = _hx_a();
__tink__Chunk_EmptyChunk.prototype.getLength = function(self) 
  do return 0 end
end
__tink__Chunk_EmptyChunk.prototype.slice = function(self,from,to) 
  do return self end
end
__tink__Chunk_EmptyChunk.prototype.blitTo = function(self,target,offset) 
end
__tink__Chunk_EmptyChunk.prototype.toString = function(self) 
  do return "" end
end
__tink__Chunk_EmptyChunk.prototype.toBytes = function(self) 
  do return __tink__Chunk_EmptyChunk.EMPTY end
end

__tink__Chunk_EmptyChunk.prototype.__class__ =  __tink__Chunk_EmptyChunk
__tink__Chunk_EmptyChunk.__super__ = __tink_chunk_ChunkBase
setmetatable(__tink__Chunk_EmptyChunk.prototype,{__index=__tink_chunk_ChunkBase.prototype})

__tink__Chunk_CompoundChunk.new = function(left,right) 
  local self = _hx_new(__tink__Chunk_CompoundChunk.prototype)
  __tink__Chunk_CompoundChunk.super(self,left,right)
  return self
end
__tink__Chunk_CompoundChunk.super = function(self,left,right) 
  self.left = left;
  self.right = right;
  self.split = left:getLength();
  self.length = self.split + right:getLength();
end
__tink__Chunk_CompoundChunk.__name__ = true
__tink__Chunk_CompoundChunk.__interfaces__ = {__tink_chunk_ChunkObject}
__tink__Chunk_CompoundChunk.prototype = _hx_a();
__tink__Chunk_CompoundChunk.prototype.left= nil;
__tink__Chunk_CompoundChunk.prototype.right= nil;
__tink__Chunk_CompoundChunk.prototype.split= nil;
__tink__Chunk_CompoundChunk.prototype.length= nil;
__tink__Chunk_CompoundChunk.prototype.getLength = function(self) 
  do return self.length end
end
__tink__Chunk_CompoundChunk.prototype.flatten = function(self,into) 
  self.left:flatten(into);
  self.right:flatten(into);
end
__tink__Chunk_CompoundChunk.prototype.slice = function(self,from,to) 
  do return __tink__Chunk_Chunk_Impl_.concat(self.left:slice(from, to), self.right:slice(from - self.split, to - self.split)) end
end
__tink__Chunk_CompoundChunk.prototype.blitTo = function(self,target,offset) 
  self.left:blitTo(target, offset);
  self.right:blitTo(target, offset + self.split);
end
__tink__Chunk_CompoundChunk.prototype.toString = function(self) 
  do return self:toBytes():toString() end
end
__tink__Chunk_CompoundChunk.prototype.toBytes = function(self) 
  local ret = __haxe_io_Bytes.alloc(self.length);
  self:blitTo(ret, 0);
  do return ret end
end

__tink__Chunk_CompoundChunk.prototype.__class__ =  __tink__Chunk_CompoundChunk
__tink__Chunk_CompoundChunk.__super__ = __tink_chunk_ChunkBase
setmetatable(__tink__Chunk_CompoundChunk.prototype,{__index=__tink_chunk_ChunkBase.prototype})

__tink__Chunk_Chunk_Impl_.new = {}
__tink__Chunk_Chunk_Impl_.__name__ = true
__tink__Chunk_Chunk_Impl_.concat = function(this1,that) 
  local _g = that:getLength();
  if (this1:getLength() == 0) then 
    if (_g == 0) then 
      do return __tink__Chunk_Chunk_Impl_.EMPTY end;
    else
      do return that end;
    end;
  else
    if (_g == 0) then 
      do return this1 end;
    else
      do return __tink__Chunk_CompoundChunk.new(this1, that) end;
    end;
  end;
end
__tink__Chunk_Chunk_Impl_.join = function(chunks) 
  if (chunks == nil) then 
    do return __tink__Chunk_Chunk_Impl_.EMPTY end;
  else
    local chunks1 = chunks.length;
    if (chunks1) == 0 then 
      do return __tink__Chunk_Chunk_Impl_.EMPTY end;
    elseif (chunks1) == 1 then 
      local v = chunks[0];
      do return v end;else
    local v1 = chunks;
    local ret = __tink__Chunk_Chunk_Impl_.catChunk(v1[0], v1[1]);
    local _g = 2;
    local _g1 = v1.length;
    while (_g < _g1) do 
      _g = _g + 1;
      local i = _g - 1;
      ret = __tink__Chunk_Chunk_Impl_.catChunk(ret, v1[i]);
    end;
    do return ret end; end;
  end;
end
__tink__Chunk_Chunk_Impl_.catChunk = function(a,b) 
  do return __tink__Chunk_Chunk_Impl_.concat(a, b) end;
end

__tink__Url_Url_Impl_.new = {}
__tink__Url_Url_Impl_.__name__ = true
__tink__Url_Url_Impl_.resolve = function(this1,that) 
  if (that.scheme ~= nil) then 
    do return that end;
  else
    if (that.host ~= nil) then 
      if (that.scheme ~= nil) then 
        do return that end;
      else
        local copy = Reflect.copy(that);
        copy.scheme = _hx_funcToField(this1.scheme);
        do return copy end;
      end;
    else
      local parts = _hx_o({__fields__={path=true,payload=true,scheme=true,query=true,auth=true,host=true,hash=true},path=__tink_url__Path_Path_Impl_.join(this1.path, that.path),payload="",scheme=this1.scheme,query=that.query,auth=this1.auth,host=this1.host,hash=that.hash});
      __tink__Url_Url_Impl_.makePayload(parts);
      local this2 = parts;
      do return this2 end;
    end;
  end;
end
__tink__Url_Url_Impl_.makePayload = function(parts) 
  local payload = "";
  local _g7 = parts.scheme;
  local _g6 = parts.query;
  local _g5 = parts.payload;
  local _g4 = parts.path;
  local _g3 = parts.hosts;
  local _g2 = parts.host;
  local _g1 = parts.hash;
  local _g = parts.auth;
  if (_g == nil) then 
    if (_g2 ~= nil) then 
      local host = _g2;
      payload = Std.string(payload) .. Std.string((Std.string("//") .. Std.string(host)));
    end;
  else
    if (_g2 == nil) then 
      local auth = _g;
      payload = Std.string(payload) .. Std.string((Std.string("//") .. Std.string(((function() 
        local _hx_1
        if (auth == nil) then 
        _hx_1 = ""; else 
        _hx_1 = Std.string(Std.string("") .. Std.string(auth)) .. Std.string("@"); end
        return _hx_1
      end )()))));
    else
      local auth1 = _g;
      local host1 = _g2;
      payload = Std.string(payload) .. Std.string((Std.string(Std.string("//") .. Std.string(((function() 
        local _hx_2
        if (auth1 == nil) then 
        _hx_2 = ""; else 
        _hx_2 = Std.string(Std.string("") .. Std.string(auth1)) .. Std.string("@"); end
        return _hx_2
      end )()))) .. Std.string(host1)));
    end;
  end;
  payload = Std.string(payload) .. Std.string(parts.path);
  local _g8 = parts.query;
  if (_g8 ~= nil) then 
    local v = _g8;
    payload = Std.string(payload) .. Std.string((Std.string("?") .. Std.string(v)));
  end;
  local _g9 = parts.hash;
  if (_g9 ~= nil) then 
    local v1 = _g9;
    payload = Std.string(payload) .. Std.string((Std.string("#") .. Std.string(v1)));
  end;
  parts.payload = payload;
end
__tink__Url_Url_Impl_.toString = function(this1) 
  if (this1.scheme == nil) then 
    do return this1.payload end;
  else
    do return Std.string(Std.string(Std.string("") .. Std.string(this1.scheme)) .. Std.string(":")) .. Std.string(this1.payload) end;
  end;
end
__tink__Url_Url_Impl_.fromString = function(s) 
  do return __tink__Url_Url_Impl_.parse(s) end;
end
__tink__Url_Url_Impl_.noop = function(_) 
end
__tink__Url_Url_Impl_.parse = function(s,onError) 
  if (s == nil) then 
    do return __tink__Url_Url_Impl_.parse("") end;
  end;
  if (onError == nil) then 
    onError = __tink__Url_Url_Impl_.noop;
  end;
  s = StringTools.trim(s);
  if (StringTools.startsWith(s, "data:")) then 
    local pos = 5;
    local len = nil;
    if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(s)))) then 
      len = __lua_lib_luautf8_Utf8.len(s);
    else
      if (len < 0) then 
        len = __lua_lib_luautf8_Utf8.len(s) + len;
      end;
    end;
    if (pos < 0) then 
      pos = __lua_lib_luautf8_Utf8.len(s) + pos;
    end;
    if (pos < 0) then 
      pos = 0;
    end;
    local this1 = _hx_o({__fields__={scheme=true,payload=true},scheme="data",payload=__lua_lib_luautf8_Utf8.sub(s, pos + 1, pos + len)});
    do return this1 end;
  end;
  local FORMAT = EReg.new("^(([a-zA-Z][a-zA-Z0-9\\-+.]*):)?((//(([^@/]+)@)?([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?)$", "");
  local HOST = EReg.new("^(\\[(.*)\\]|([^:]*))(:(.*))?$", "");
  FORMAT:match(s);
  local hosts;
  local _g = FORMAT:matched(7);
  if (_g == nil) then 
    hosts = _hx_tab_array({}, 0);
  else
    local v = _g;
    local _g1 = _hx_tab_array({}, 0);
    local _g11 = 0;
    local idx = 1;
    local ret = _hx_tab_array({}, 0);
    local delim_offset = (function() 
      local _hx_1
      if (__lua_lib_luautf8_Utf8.len(",") > 0) then 
      _hx_1 = __lua_lib_luautf8_Utf8.len(","); else 
      _hx_1 = 1; end
      return _hx_1
    end )();
    while (idx ~= nil) do 
      local newidx = 0;
      if (__lua_lib_luautf8_Utf8.len(",") > 0) then 
        newidx = __lua_lib_luautf8_Utf8.find(v, ",", idx, true);
      else
        if (idx >= __lua_lib_luautf8_Utf8.len(v)) then 
          newidx = nil;
        else
          newidx = idx + 1;
        end;
      end;
      if (newidx ~= nil) then 
        local match = __lua_lib_luautf8_Utf8.sub(v, idx, newidx - 1);
        ret:push(match);
        idx = newidx + __lua_lib_luautf8_Utf8.len(",");
      else
        ret:push(__lua_lib_luautf8_Utf8.sub(v, idx, __lua_lib_luautf8_Utf8.len(v)));
        idx = nil;
      end;
    end;
    local _g2 = ret;
    while (_g11 < _g2.length) do 
      local host = _g2[_g11];
      _g11 = _g11 + 1;
      HOST:match(host);
      local host1;
      local _g12 = HOST:matched(2);
      local _g21 = HOST:matched(3);
      if (_g12 == nil) then 
        local ipv4 = _g21;
        host1 = ipv4;
      else
        if (_g21 == nil) then 
          local ipv6 = _g12;
          host1 = Std.string(Std.string("[") .. Std.string(ipv6)) .. Std.string("]");
        else
          onError(Std.string("invalid host ") .. Std.string(host));
          host1 = nil;
        end;
      end;
      local port;
      local _g3 = HOST:matched(5);
      if (_g3 == nil) then 
        port = nil;
      else
        local v1 = _g3;
        local _g31 = Std.parseInt(v1);
        if (_g31 == nil) then 
          onError(Std.string("invalid port ") .. Std.string(v1));
          port = nil;
        else
          local p = _g31;
          port = p;
        end;
      end;
      _g1:push(__tink_url__Host_Host_Impl_._new(host1, port));
    end;
    hosts = _g1;
  end;
  local path = FORMAT:matched(8);
  if ((hosts.length > 0) and (__lua_lib_luautf8_Utf8.sub(path, 1, 1) ~= "/")) then 
    path = Std.string("/") .. Std.string(path);
  end;
  local this2 = _hx_o({__fields__={scheme=true,payload=true,host=true,hosts=true,auth=true,path=true,query=true,hash=true},scheme=FORMAT:matched(2),payload=FORMAT:matched(3),host=hosts[0],hosts=hosts,auth=FORMAT:matched(6),path=__tink_url__Path_Path_Impl_.ofString(path),query=FORMAT:matched(10),hash=FORMAT:matched(12)});
  do return this2 end;
end

__tink_chunk_ByteChunk.new = function(data,from,to) 
  local self = _hx_new(__tink_chunk_ByteChunk.prototype)
  __tink_chunk_ByteChunk.super(self,data,from,to)
  return self
end
__tink_chunk_ByteChunk.super = function(self,data,from,to) 
  self.data = data;
  self.from = from;
  self.to = to;
end
__tink_chunk_ByteChunk.__name__ = true
__tink_chunk_ByteChunk.__interfaces__ = {__tink_chunk_ChunkObject}
__tink_chunk_ByteChunk.of = function(b) 
  if (b.length == 0) then 
    do return __tink__Chunk_Chunk_Impl_.EMPTY end;
  end;
  local ret = __tink_chunk_ByteChunk.new(b.b, 0, b.length);
  ret.wrapped = b;
  do return ret end;
end
__tink_chunk_ByteChunk.prototype = _hx_a();
__tink_chunk_ByteChunk.prototype.data= nil;
__tink_chunk_ByteChunk.prototype.from= nil;
__tink_chunk_ByteChunk.prototype.to= nil;
__tink_chunk_ByteChunk.prototype.wrapped= nil;
__tink_chunk_ByteChunk.prototype.flatten = function(self,into) 
  into:push(self);
end
__tink_chunk_ByteChunk.prototype.getLength = function(self) 
  do return self.to - self.from end
end
__tink_chunk_ByteChunk.prototype.getSlice = function(self,from,to) 
  if (to > (self.to - self.from)) then 
    to = self.to - self.from;
  end;
  if (from < 0) then 
    from = 0;
  end;
  if (to <= from) then 
    do return nil end;
  else
    if ((to == (self.to - self.from)) and (from == 0)) then 
      do return self end;
    else
      do return __tink_chunk_ByteChunk.new(self.data, self.from + from, to + self.from) end;
    end;
  end;
end
__tink_chunk_ByteChunk.prototype.slice = function(self,from,to) 
  local _g = self:getSlice(from, to);
  if (_g == nil) then 
    do return __tink__Chunk_Chunk_Impl_.EMPTY end;
  else
    local v = _g;
    do return v end;
  end;
end
__tink_chunk_ByteChunk.prototype.blitTo = function(self,target,offset) 
  if (self.wrapped == nil) then 
    self.wrapped = __haxe_io_Bytes.ofData(self.data);
  end;
  target:blit(offset, self.wrapped, self.from, self.to - self.from);
end
__tink_chunk_ByteChunk.prototype.toBytes = function(self) 
  if (self.wrapped == nil) then 
    self.wrapped = __haxe_io_Bytes.ofData(self.data);
  end;
  do return self.wrapped:sub(self.from, self.to - self.from) end
end
__tink_chunk_ByteChunk.prototype.toString = function(self) 
  if (self.wrapped == nil) then 
    self.wrapped = __haxe_io_Bytes.ofData(self.data);
  end;
  do return self.wrapped:getString(self.from, self.to - self.from) end
end

__tink_chunk_ByteChunk.prototype.__class__ =  __tink_chunk_ByteChunk
__tink_chunk_ByteChunk.__super__ = __tink_chunk_ChunkBase
setmetatable(__tink_chunk_ByteChunk.prototype,{__index=__tink_chunk_ChunkBase.prototype})

__tink_chunk_ChunkCursor.new = function() 
  local self = _hx_new(__tink_chunk_ChunkCursor.prototype)
  __tink_chunk_ChunkCursor.super(self)
  return self
end
__tink_chunk_ChunkCursor.super = function(self) 
  self.currentByte = -1;
  self.currentPos = 0;
  self.length = 0;
  self.curLength = 0;
  self.curOffset = 0;
  self.curPartIndex = 0;
end
__tink_chunk_ChunkCursor.__name__ = true
__tink_chunk_ChunkCursor.create = function(parts) 
  local ret = __tink_chunk_ChunkCursor.new();
  ret.parts = parts;
  ret:reset();
  do return ret end;
end
__tink_chunk_ChunkCursor.prototype = _hx_a();
__tink_chunk_ChunkCursor.prototype.parts= nil;
__tink_chunk_ChunkCursor.prototype.curPart= nil;
__tink_chunk_ChunkCursor.prototype.curPartIndex= nil;
__tink_chunk_ChunkCursor.prototype.curOffset= nil;
__tink_chunk_ChunkCursor.prototype.curLength= nil;
__tink_chunk_ChunkCursor.prototype.length= nil;
__tink_chunk_ChunkCursor.prototype.currentPos= nil;
__tink_chunk_ChunkCursor.prototype.currentByte= nil;
__tink_chunk_ChunkCursor.prototype.reset = function(self) 
  self.length = 0;
  self.currentPos = 0;
  self.currentByte = -1;
  self.curOffset = 0;
  local _g = 0;
  local _g1 = self.parts;
  while (_g < _g1.length) do 
    local p = _g1[_g];
    _g = _g + 1;
    local tmp = self;
    tmp.length = tmp.length + (p.to - p.from);
  end;
  self.curPart = self.parts[(function() 
  self.curPartIndex = 0; return self.curPartIndex end)()];
  if (self.curPart ~= nil) then 
    local _this = self.curPart;
    self.curLength = _this.to - _this.from;
    local _this1 = self.curPart;
    self.currentByte = _this1.data[_this1.from];
  end;
end
__tink_chunk_ChunkCursor.prototype.flush = function(self) 
  local ret = self:left();
  self:shift();
  do return ret end
end
__tink_chunk_ChunkCursor.prototype.add = function(self,chunk) 
  chunk:flatten(self.parts);
  self:reset();
end
__tink_chunk_ChunkCursor.prototype.shift = function(self,chunk) 
  self.parts:splice(0, self.curPartIndex);
  local _g = self.parts[0];
  if (_g ~= nil) then 
    local chunk1 = _g;
    local _g1 = chunk1:getSlice(self.curOffset, self.curLength);
    if (_g1 == nil) then 
      self.parts:shift();
    else
      local rest = _g1;
      self.parts[0] = rest;
    end;
  end;
  if (chunk ~= nil) then 
    self:add(chunk);
  else
    self:reset();
  end;
end
__tink_chunk_ChunkCursor.prototype.left = function(self) 
  if (self.curPart == nil) then 
    do return __tink__Chunk_Chunk_Impl_.EMPTY end;
  end;
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self.curPartIndex;
  while (_g1 < _g2) do 
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    _g:push(self.parts[i]);
  end;
  local left = _g;
  left:push(self.curPart:slice(0, self.curOffset));
  do return __tink__Chunk_Chunk_Impl_.join(left) end
end
__tink_chunk_ChunkCursor.prototype.right = function(self) 
  if (self.curPart == nil) then 
    do return __tink__Chunk_Chunk_Impl_.EMPTY end;
  end;
  local _g = _hx_tab_array({}, 0);
  local _g1 = self.curPartIndex;
  local _g2 = self.parts.length;
  while (_g1 < _g2) do 
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    _g:push(self.parts[i]);
  end;
  local right = _g;
  if (right.length > 0) then 
    right[0] = self.curPart:slice(self.curOffset, self.curLength);
  end;
  do return __tink__Chunk_Chunk_Impl_.join(right) end
end
__tink_chunk_ChunkCursor.prototype.ffwd = function(self) 
  self.currentByte = -1;
  self.curLength = 0;
  self.curOffset = 0;
  self.curPart = nil;
  self.curPartIndex = self.parts.length;
end
__tink_chunk_ChunkCursor.prototype.next = function(self) 
  if (self.currentPos == self.length) then 
    do return false end;
  end;
  self.currentPos = self.currentPos + 1;
  if (self.currentPos == self.length) then 
    self:ffwd();
    do return false end;
  end;
  if (self.curOffset == (self.curLength - 1)) then 
    self.curOffset = 0;
    self.curPart = self.parts[(function() 
    local _hx_obj = self;
    local _hx_fld = 'curPartIndex';
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _hx_obj[_hx_fld];
     end)()];
    local _this = self.curPart;
    self.curLength = _this.to - _this.from;
    local _this1 = self.curPart;
    self.currentByte = _this1.data[_this1.from];
  else
    local _this2 = self.curPart;
    local index = (function() 
    local _hx_obj = self;
    local _hx_fld = 'curOffset';
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _hx_obj[_hx_fld];
     end)();
    self.currentByte = _this2.data[_this2.from + index];
  end;
  do return true end
end

__tink_chunk_ChunkCursor.prototype.__class__ =  __tink_chunk_ChunkCursor

__tink_core__Callback_Callback_Impl_.new = {}
__tink_core__Callback_Callback_Impl_.__name__ = true
__tink_core__Callback_Callback_Impl_.invoke = function(this1,data) 
  if (__tink_core__Callback_Callback_Impl_.depth < 500) then 
    __tink_core__Callback_Callback_Impl_.depth = __tink_core__Callback_Callback_Impl_.depth + 1;
    this1(data);
    __tink_core__Callback_Callback_Impl_.depth = __tink_core__Callback_Callback_Impl_.depth - 1;
  else
    local _e = this1;
    local f = function(data1) 
      __tink_core__Callback_Callback_Impl_.invoke(_e, data1);
    end;
    local data2 = data;
    __tink_core__Callback_Callback_Impl_.defer(function() 
      f(data2);
    end);
  end;
end
__tink_core__Callback_Callback_Impl_.fromNiladic = function(f) 
  do return function(_) 
    f();
  end end;
end
__tink_core__Callback_Callback_Impl_.defer = function(f) 
  __haxe_Timer.delay(f, 0);
end

__tink_core_LinkObject.new = {}
__tink_core_LinkObject.__name__ = true

__tink_core__Callback_ListCell.new = function(cb,list) 
  local self = _hx_new(__tink_core__Callback_ListCell.prototype)
  __tink_core__Callback_ListCell.super(self,cb,list)
  return self
end
__tink_core__Callback_ListCell.super = function(self,cb,list) 
  if (cb == nil) then 
    _G.error("callback expected but null received",0);
  end;
  self.cb = cb;
  self.list = list;
end
__tink_core__Callback_ListCell.__name__ = true
__tink_core__Callback_ListCell.__interfaces__ = {__tink_core_LinkObject}
__tink_core__Callback_ListCell.prototype = _hx_a();
__tink_core__Callback_ListCell.prototype.list= nil;
__tink_core__Callback_ListCell.prototype.cb= nil;
__tink_core__Callback_ListCell.prototype.clear = function(self) 
  self.list = nil;
  self.cb = nil;
end

__tink_core__Callback_ListCell.prototype.__class__ =  __tink_core__Callback_ListCell

__tink_core__Callback_CallbackList_Impl_.new = {}
__tink_core__Callback_CallbackList_Impl_.__name__ = true
__tink_core__Callback_CallbackList_Impl_.add = function(this1,cb) 
  local node = __tink_core__Callback_ListCell.new(cb, this1);
  this1:push(node);
  do return node end;
end
__tink_core__Callback_CallbackList_Impl_.invoke = function(this1,data) 
  local _g = 0;
  local _g1 = _hx_tab_array({}, 0);
  local _g11 = 0;
  local _g2 = this1;
  while (_g11 < _g2.length) do 
    local i = _g2[_g11];
    _g11 = _g11 + 1;
    _g1:push(i);
  end;
  local _g12 = _g1;
  while (_g < _g12.length) do 
    local cell = _g12[_g];
    _g = _g + 1;
    if (cell.cb ~= nil) then 
      __tink_core__Callback_Callback_Impl_.invoke(cell.cb, data);
    end;
  end;
end
__tink_core__Callback_CallbackList_Impl_.clear = function(this1) 
  local _g = 0;
  local _g1 = this1:splice(0, this1.length);
  while (_g < _g1.length) do 
    local cell = _g1[_g];
    _g = _g + 1;
    cell:clear();
  end;
end

__tink_core_TypedError.new = function(code,message,pos) 
  local self = _hx_new(__tink_core_TypedError.prototype)
  __tink_core_TypedError.super(self,code,message,pos)
  return self
end
__tink_core_TypedError.super = function(self,code,message,pos) 
  if (code == nil) then 
    code = 500;
  end;
  self.code = code;
  self.message = message;
  self.pos = pos;
  self.exceptionStack = _hx_tab_array({}, 0);
  self.callStack = _hx_tab_array({}, 0);
end
__tink_core_TypedError.__name__ = true
__tink_core_TypedError.withData = function(code,message,data,pos) 
  do return __tink_core_TypedError.typed(code, message, data, pos) end;
end
__tink_core_TypedError.typed = function(code,message,data,pos) 
  local ret = __tink_core_TypedError.new(code, message, pos);
  ret.data = data;
  do return ret end;
end
__tink_core_TypedError.prototype = _hx_a();
__tink_core_TypedError.prototype.message= nil;
__tink_core_TypedError.prototype.code= nil;
__tink_core_TypedError.prototype.data= nil;
__tink_core_TypedError.prototype.pos= nil;
__tink_core_TypedError.prototype.callStack= nil;
__tink_core_TypedError.prototype.exceptionStack= nil;

__tink_core_TypedError.prototype.__class__ =  __tink_core_TypedError

__tink_core__Future_FutureObject.new = {}
__tink_core__Future_FutureObject.__name__ = true
__tink_core__Future_FutureObject.prototype = _hx_a();
__tink_core__Future_FutureObject.prototype.map= nil;
__tink_core__Future_FutureObject.prototype.flatMap= nil;
__tink_core__Future_FutureObject.prototype.handle= nil;
__tink_core__Future_FutureObject.prototype.gather= nil;
__tink_core__Future_FutureObject.prototype.eager= nil;

__tink_core__Future_FutureObject.prototype.__class__ =  __tink_core__Future_FutureObject
_hxClasses["tink.core.Noise"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Noise"},1)}
__tink_core_Noise = _hxClasses["tink.core.Noise"];
__tink_core_Noise.Noise = _hx_tab_array({[0]="Noise",0,__enum__ = __tink_core_Noise},2)


__tink_core__Lazy_LazyObject.new = {}
__tink_core__Lazy_LazyObject.__name__ = true
__tink_core__Lazy_LazyObject.prototype = _hx_a();
__tink_core__Lazy_LazyObject.prototype.get= nil;
__tink_core__Lazy_LazyObject.prototype.map= nil;

__tink_core__Lazy_LazyObject.prototype.__class__ =  __tink_core__Lazy_LazyObject

__tink_core__Lazy_LazyConst.new = function(value) 
  local self = _hx_new(__tink_core__Lazy_LazyConst.prototype)
  __tink_core__Lazy_LazyConst.super(self,value)
  return self
end
__tink_core__Lazy_LazyConst.super = function(self,value) 
  self.value = value;
end
__tink_core__Lazy_LazyConst.__name__ = true
__tink_core__Lazy_LazyConst.__interfaces__ = {__tink_core__Lazy_LazyObject}
__tink_core__Lazy_LazyConst.prototype = _hx_a();
__tink_core__Lazy_LazyConst.prototype.value= nil;
__tink_core__Lazy_LazyConst.prototype.get = function(self) 
  do return self.value end
end
__tink_core__Lazy_LazyConst.prototype.map = function(self,f) 
  local _gthis = self;
  do return __tink_core__Lazy_LazyFunc.new(function() 
    do return f(_gthis.value) end;
  end) end
end

__tink_core__Lazy_LazyConst.prototype.__class__ =  __tink_core__Lazy_LazyConst

__tink_core__Future_SyncFuture.new = function(value) 
  local self = _hx_new(__tink_core__Future_SyncFuture.prototype)
  __tink_core__Future_SyncFuture.super(self,value)
  return self
end
__tink_core__Future_SyncFuture.super = function(self,value) 
  self.value = value;
end
__tink_core__Future_SyncFuture.__name__ = true
__tink_core__Future_SyncFuture.__interfaces__ = {__tink_core__Future_FutureObject}
__tink_core__Future_SyncFuture.prototype = _hx_a();
__tink_core__Future_SyncFuture.prototype.value= nil;
__tink_core__Future_SyncFuture.prototype.map = function(self,f) 
  do return __tink_core__Future_SyncFuture.new(self.value:map(f)) end
end
__tink_core__Future_SyncFuture.prototype.flatMap = function(self,f) 
  local l = self.value:map(f);
  do return __tink_core__Future_SimpleFuture.new(function(cb) 
    do return l:get():handle(cb) end;
  end) end
end
__tink_core__Future_SyncFuture.prototype.handle = function(self,cb) 
  __tink_core__Callback_Callback_Impl_.invoke(cb, self.value:get());
  do return nil end
end
__tink_core__Future_SyncFuture.prototype.eager = function(self) 
  do return self end
end
__tink_core__Future_SyncFuture.prototype.gather = function(self) 
  do return self end
end

__tink_core__Future_SyncFuture.prototype.__class__ =  __tink_core__Future_SyncFuture

__tink_core__Future_Future_Impl_.new = {}
__tink_core__Future_Future_Impl_.__name__ = true
__tink_core__Future_Future_Impl_.next = function(this1,n) 
  do return this1:flatMap(function(v) 
    do return n(v) end;
  end) end;
end
__tink_core__Future_Future_Impl_.flatten = function(f) 
  do return __tink_core__Future_NestedFuture.new(f) end;
end
__tink_core__Future_Future_Impl_.async = function(f,lazy) 
  if (lazy == nil) then 
    lazy = false;
  end;
  if (lazy) then 
    do return __tink_core__Future_LazyTrigger.new(f) end;
  else
    local op = __tink_core_FutureTrigger.new();
    local wrapped = f;
    __tink_core__Callback_Callback_Impl_.invoke(wrapped, _hx_bind(op,op.trigger));
    do return op end;
  end;
end

__tink_core__Future_SimpleFuture.new = function(f) 
  local self = _hx_new(__tink_core__Future_SimpleFuture.prototype)
  __tink_core__Future_SimpleFuture.super(self,f)
  return self
end
__tink_core__Future_SimpleFuture.super = function(self,f) 
  self.f = _hx_funcToField(f);
end
__tink_core__Future_SimpleFuture.__name__ = true
__tink_core__Future_SimpleFuture.__interfaces__ = {__tink_core__Future_FutureObject}
__tink_core__Future_SimpleFuture.prototype = _hx_a();
__tink_core__Future_SimpleFuture.prototype.f= nil;
__tink_core__Future_SimpleFuture.prototype.gathered= nil;
__tink_core__Future_SimpleFuture.prototype.handle = function(self,callback) 
  do return self:f(callback) end
end
__tink_core__Future_SimpleFuture.prototype.map = function(self,f) 
  local _gthis = self;
  do return __tink_core__Future_SimpleFuture.new(function(cb) 
    do return _gthis:f(function(v) 
      local tmp = f(v);
      __tink_core__Callback_Callback_Impl_.invoke(cb, tmp);
    end) end;
  end) end
end
__tink_core__Future_SimpleFuture.prototype.flatMap = function(self,f) 
  local f1 = f;
  local _gthis = self;
  do return __tink_core__Future_Future_Impl_.flatten(__tink_core__Future_SimpleFuture.new(function(cb) 
    do return _gthis:f(function(v) 
      local tmp = f1(v);
      __tink_core__Callback_Callback_Impl_.invoke(cb, tmp);
    end) end;
  end)) end
end
__tink_core__Future_SimpleFuture.prototype.gather = function(self) 
  if (self.gathered ~= nil) then 
    do return self.gathered end;
  else
    self.gathered = __tink_core_FutureTrigger.gatherFuture(self) do return self.gathered end;
  end;
end
__tink_core__Future_SimpleFuture.prototype.eager = function(self) 
  local ret = (function() 
    local _hx_1
    if (self.gathered ~= nil) then 
    _hx_1 = self.gathered; else 
    self.gathered = __tink_core_FutureTrigger.gatherFuture(self)
    _hx_1 = self.gathered; end
    return _hx_1
  end )();
  ret:handle(__tink_core__Callback_Callback_Impl_.fromNiladic(function() 
  end));
  do return ret end
end

__tink_core__Future_SimpleFuture.prototype.__class__ =  __tink_core__Future_SimpleFuture

__tink_core__Future_NestedFuture.new = function(outer) 
  local self = _hx_new(__tink_core__Future_NestedFuture.prototype)
  __tink_core__Future_NestedFuture.super(self,outer)
  return self
end
__tink_core__Future_NestedFuture.super = function(self,outer) 
  self.outer = outer;
end
__tink_core__Future_NestedFuture.__name__ = true
__tink_core__Future_NestedFuture.__interfaces__ = {__tink_core__Future_FutureObject}
__tink_core__Future_NestedFuture.prototype = _hx_a();
__tink_core__Future_NestedFuture.prototype.outer= nil;
__tink_core__Future_NestedFuture.prototype.gathered= nil;
__tink_core__Future_NestedFuture.prototype.map = function(self,f) 
  local ret = self.outer:flatMap(function(inner) 
    local ret1 = inner:map(f);
    do return ret1:gather() end;
  end);
  do return ret:gather() end
end
__tink_core__Future_NestedFuture.prototype.flatMap = function(self,f) 
  local ret = self.outer:flatMap(function(inner) 
    local ret1 = inner:flatMap(f);
    do return ret1:gather() end;
  end);
  do return ret:gather() end
end
__tink_core__Future_NestedFuture.prototype.gather = function(self) 
  if (self.gathered ~= nil) then 
    do return self.gathered end;
  else
    self.gathered = __tink_core_FutureTrigger.gatherFuture(self) do return self.gathered end;
  end;
end
__tink_core__Future_NestedFuture.prototype.eager = function(self) 
  local ret = (function() 
    local _hx_1
    if (self.gathered ~= nil) then 
    _hx_1 = self.gathered; else 
    self.gathered = __tink_core_FutureTrigger.gatherFuture(self)
    _hx_1 = self.gathered; end
    return _hx_1
  end )();
  ret:handle(__tink_core__Callback_Callback_Impl_.fromNiladic(function() 
  end));
  do return ret end
end
__tink_core__Future_NestedFuture.prototype.handle = function(self,cb) 
  local ret = nil;
  ret = self.outer:handle(function(inner) 
    ret = inner:handle(function(result) 
      __tink_core__Callback_Callback_Impl_.invoke(cb, result);
    end);
  end);
  do return ret end
end

__tink_core__Future_NestedFuture.prototype.__class__ =  __tink_core__Future_NestedFuture

__tink_core_FutureTrigger.new = function() 
  local self = _hx_new(__tink_core_FutureTrigger.prototype)
  __tink_core_FutureTrigger.super(self)
  return self
end
__tink_core_FutureTrigger.super = function(self) 
  local this1 = _hx_tab_array({}, 0);
  self.list = this1;
end
__tink_core_FutureTrigger.__name__ = true
__tink_core_FutureTrigger.__interfaces__ = {__tink_core__Future_FutureObject}
__tink_core_FutureTrigger.gatherFuture = function(f) 
  local op = nil;
  local this1 = __tink_core__Future_SimpleFuture.new(function(cb) 
    if (op == nil) then 
      op = __tink_core_FutureTrigger.new();
      f:handle(_hx_bind(op,op.trigger));
      f = nil;
    end;
    do return op:handle(cb) end;
  end);
  do return this1 end;
end
__tink_core_FutureTrigger.prototype = _hx_a();
__tink_core_FutureTrigger.prototype.result= nil;
__tink_core_FutureTrigger.prototype.list= nil;
__tink_core_FutureTrigger.prototype.handle = function(self,callback) 
  local _g = self.list;
  if (_g == nil) then 
    __tink_core__Callback_Callback_Impl_.invoke(callback, self.result);
    do return nil end;
  else
    local v = _g;
    do return __tink_core__Callback_CallbackList_Impl_.add(v, callback) end;
  end;
end
__tink_core_FutureTrigger.prototype.map = function(self,f) 
  local _g = self.list;
  if (_g == nil) then 
    do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(f(self.result))) end;
  else
    local v = _g;
    local ret = __tink_core_FutureTrigger.new();
    __tink_core__Callback_CallbackList_Impl_.add(self.list, function(v1) 
      local tmp = f(v1);
      ret:trigger(tmp);
    end);
    do return ret end;
  end;
end
__tink_core_FutureTrigger.prototype.flatMap = function(self,f) 
  local _g = self.list;
  if (_g == nil) then 
    do return f(self.result) end;
  else
    local v = _g;
    local ret = __tink_core_FutureTrigger.new();
    __tink_core__Callback_CallbackList_Impl_.add(self.list, function(v1) 
      f(v1):handle(_hx_bind(ret,ret.trigger));
    end);
    do return ret end;
  end;
end
__tink_core_FutureTrigger.prototype.gather = function(self) 
  do return self end
end
__tink_core_FutureTrigger.prototype.eager = function(self) 
  do return self end
end
__tink_core_FutureTrigger.prototype.trigger = function(self,result) 
  if (self.list == nil) then 
    do return false end;
  else
    local list = self.list;
    self.list = nil;
    self.result = result;
    __tink_core__Callback_CallbackList_Impl_.invoke(list, result);
    __tink_core__Callback_CallbackList_Impl_.clear(list);
    do return true end;
  end;
end

__tink_core_FutureTrigger.prototype.__class__ =  __tink_core_FutureTrigger

__tink_core__Future_LazyTrigger.new = function(op) 
  local self = _hx_new(__tink_core__Future_LazyTrigger.prototype)
  __tink_core__Future_LazyTrigger.super(self,op)
  return self
end
__tink_core__Future_LazyTrigger.super = function(self,op) 
  self.op = op;
  __tink_core_FutureTrigger.super(self);
end
__tink_core__Future_LazyTrigger.__name__ = true
__tink_core__Future_LazyTrigger.prototype = _hx_a();
__tink_core__Future_LazyTrigger.prototype.op= nil;
__tink_core__Future_LazyTrigger.prototype.eager = function(self) 
  if (self.op ~= nil) then 
    local op = self.op;
    self.op = nil;
    __tink_core__Callback_Callback_Impl_.invoke(op, _hx_bind(self,self.trigger));
  end;
  do return self end
end
__tink_core__Future_LazyTrigger.prototype.map = function(self,f) 
  local _gthis = self;
  if (self.op == nil) then 
    do return __tink_core_FutureTrigger.prototype.map(self,f) end;
  else
    do return __tink_core__Future_Future_Impl_.async(function(cb) 
      _gthis:handle(function(v) 
        local tmp = f(v);
        cb(tmp);
      end);
    end, true) end;
  end;
end
__tink_core__Future_LazyTrigger.prototype.flatMap = function(self,f) 
  local _gthis = self;
  if (self.op == nil) then 
    do return __tink_core_FutureTrigger.prototype.flatMap(self,f) end;
  else
    do return __tink_core__Future_Future_Impl_.async(function(cb) 
      _gthis:handle(function(v) 
        f(v):handle(cb);
      end);
    end, true) end;
  end;
end
__tink_core__Future_LazyTrigger.prototype.handle = function(self,cb) 
  self:eager();
  do return __tink_core_FutureTrigger.prototype.handle(self,cb) end
end

__tink_core__Future_LazyTrigger.prototype.__class__ =  __tink_core__Future_LazyTrigger
__tink_core__Future_LazyTrigger.__super__ = __tink_core_FutureTrigger
setmetatable(__tink_core__Future_LazyTrigger.prototype,{__index=__tink_core_FutureTrigger.prototype})

__tink_core__Lazy_LazyFunc.new = function(f) 
  local self = _hx_new(__tink_core__Lazy_LazyFunc.prototype)
  __tink_core__Lazy_LazyFunc.super(self,f)
  return self
end
__tink_core__Lazy_LazyFunc.super = function(self,f) 
  self.f = _hx_funcToField(f);
end
__tink_core__Lazy_LazyFunc.__name__ = true
__tink_core__Lazy_LazyFunc.__interfaces__ = {__tink_core__Lazy_LazyObject}
__tink_core__Lazy_LazyFunc.prototype = _hx_a();
__tink_core__Lazy_LazyFunc.prototype.f= nil;
__tink_core__Lazy_LazyFunc.prototype.result= nil;
__tink_core__Lazy_LazyFunc.prototype.get = function(self) 
  if (self.f ~= nil) then 
    self.result = self:f();
    self.f = nil;
  end;
  do return self.result end
end
__tink_core__Lazy_LazyFunc.prototype.map = function(self,f) 
  local _gthis = self;
  do return __tink_core__Lazy_LazyFunc.new(function() 
    local tmp = _gthis:get();
    do return f(tmp) end;
  end) end
end

__tink_core__Lazy_LazyFunc.prototype.__class__ =  __tink_core__Lazy_LazyFunc

__tink_core_NamedWith.new = function(name,value) 
  local self = _hx_new(__tink_core_NamedWith.prototype)
  __tink_core_NamedWith.super(self,name,value)
  return self
end
__tink_core_NamedWith.super = function(self,name,value) 
  self.name = name;
  self.value = value;
end
__tink_core_NamedWith.__name__ = true
__tink_core_NamedWith.prototype = _hx_a();
__tink_core_NamedWith.prototype.name= nil;
__tink_core_NamedWith.prototype.value= nil;

__tink_core_NamedWith.prototype.__class__ =  __tink_core_NamedWith
_hxClasses["tink.core.Outcome"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Success","Failure"},2)}
__tink_core_Outcome = _hxClasses["tink.core.Outcome"];
__tink_core_Outcome.Success = function(data) local _x = _hx_tab_array({[0]="Success",0,data,__enum__=__tink_core_Outcome}, 3); return _x; end 
__tink_core_Outcome.Failure = function(failure) local _x = _hx_tab_array({[0]="Failure",1,failure,__enum__=__tink_core_Outcome}, 3); return _x; end 

__tink_core_MPair.new = function(a,b) 
  local self = _hx_new(__tink_core_MPair.prototype)
  __tink_core_MPair.super(self,a,b)
  return self
end
__tink_core_MPair.super = function(self,a,b) 
  self.a = a;
  self.b = b;
end
__tink_core_MPair.__name__ = true
__tink_core_MPair.prototype = _hx_a();
__tink_core_MPair.prototype.a= nil;
__tink_core_MPair.prototype.b= nil;

__tink_core_MPair.prototype.__class__ =  __tink_core_MPair

__tink_core__Promise_Promise_Impl_.new = {}
__tink_core__Promise_Promise_Impl_.__name__ = true
__tink_core__Promise_Promise_Impl_.next = function(this1,f,gather) 
  if (gather == nil) then 
    gather = true;
  end;
  local gather1 = gather;
  if (gather1 == nil) then 
    gather1 = true;
  end;
  local ret = this1:flatMap(function(o) 
    local ret1 = o[1];
    if (ret1) == 0 then 
      local d = o[2];
      do return f(d) end;
    elseif (ret1) == 1 then 
      local f1 = o[2];
      do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(__tink_core_Outcome.Failure(f1))) end; end;
  end);
  if (gather1) then 
    do return ret:gather() end;
  else
    do return ret end;
  end;
end

__tink_io_StreamParserObject.new = {}
__tink_io_StreamParserObject.__name__ = true
__tink_io_StreamParserObject.prototype = _hx_a();
__tink_io_StreamParserObject.prototype.progress= nil;
__tink_io_StreamParserObject.prototype.eof= nil;

__tink_io_StreamParserObject.prototype.__class__ =  __tink_io_StreamParserObject

__tink_http_ClientObject.new = {}
__tink_http_ClientObject.__name__ = true
__tink_http_ClientObject.prototype = _hx_a();
__tink_http_ClientObject.prototype.request= nil;

__tink_http_ClientObject.prototype.__class__ =  __tink_http_ClientObject

__tink_http__Client_CustomClient.new = function(preprocessors,postprocessors,real) 
  local self = _hx_new(__tink_http__Client_CustomClient.prototype)
  __tink_http__Client_CustomClient.super(self,preprocessors,postprocessors,real)
  return self
end
__tink_http__Client_CustomClient.super = function(self,preprocessors,postprocessors,real) 
  self.preprocessors = preprocessors;
  self.postprocessors = postprocessors;
  self.real = real;
end
__tink_http__Client_CustomClient.__name__ = true
__tink_http__Client_CustomClient.__interfaces__ = {__tink_http_ClientObject}
__tink_http__Client_CustomClient.concat = function(a,b) 
  if (a == nil) then 
    local v = b;
    do return v end;
  else
    if (b == nil) then 
      local v1 = a;
      do return v1 end;
    else
      do return a:concat(b) end;
    end;
  end;
end
__tink_http__Client_CustomClient.create = function(c,preprocessors,postprocessors) 
  local _g = (function() 
    local _hx_1
    if (__lua_Boot.__instanceof(c, __tink_http__Client_CustomClient)) then 
    _hx_1 = c; else 
    _hx_1 = nil; end
    return _hx_1
  end )();
  if (_g == nil) then 
    do return __tink_http__Client_CustomClient.new(preprocessors, postprocessors, c) end;
  else
    local v = _g;
    do return __tink_http__Client_CustomClient.new(__tink_http__Client_CustomClient.concat(preprocessors, v.preprocessors), __tink_http__Client_CustomClient.concat(v.postprocessors, postprocessors), v.real) end;
  end;
end
__tink_http__Client_CustomClient.prototype = _hx_a();
__tink_http__Client_CustomClient.prototype.preprocessors= nil;
__tink_http__Client_CustomClient.prototype.postprocessors= nil;
__tink_http__Client_CustomClient.prototype.real= nil;
__tink_http__Client_CustomClient.prototype.pipe = function(self,value,transforms,index) 
  if (index == nil) then 
    index = 0;
  end;
  if ((transforms ~= nil) and (index < transforms.length)) then 
    local f = _hx_bind(self,self.pipe);
    local transforms1 = transforms;
    local index1 = index + 1;
    local tmp = function(value1) 
      do return f(value1, transforms1, index1) end;
    end;
    do return __tink_core__Promise_Promise_Impl_.next(transforms[index](value), tmp) end;
  else
    do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(__tink_core_Outcome.Success(value))) end;
  end;
end
__tink_http__Client_CustomClient.prototype.request = function(self,req) 
  local _gthis = self;
  do return __tink_core__Promise_Promise_Impl_.next(self:pipe(req, self.preprocessors), function(req1) 
    local tmp = _gthis.real:request(req1);
    local f = _hx_bind(_gthis,_gthis.pipe);
    local transforms;
    if (_gthis.postprocessors == nil) then 
      transforms = nil;
    else
      local _g = _hx_tab_array({}, 0);
      local _g1 = 0;
      local _g2 = _gthis.postprocessors;
      while (_g1 < _g2.length) do 
        local p = _g2[_g1];
        _g1 = _g1 + 1;
        _g:push(p(req1));
      end;
      transforms = _g;
    end;
    do return __tink_core__Promise_Promise_Impl_.next(tmp, function(value) 
      do return f(value, transforms) end;
    end) end;
  end) end
end

__tink_http__Client_CustomClient.prototype.__class__ =  __tink_http__Client_CustomClient

__tink_http_Container.new = {}
__tink_http_Container.__name__ = true

__tink_http_Fetch.new = {}
__tink_http_Fetch.__name__ = true
__tink_http_Fetch.fetch = function(url,options) 
  do return __tink_core__Future_Future_Impl_.async(function(cb) 
    local uri = url.path;
    if (url.query ~= nil) then 
      uri = Std.string(uri) .. Std.string((Std.string("?") .. Std.string(url.query)));
    end;
    local method = "GET";
    local headers = nil;
    local body = __tink_io__Source_Source_Impl_.EMPTY;
    local type = __tink_http_ClientType.Default;
    local followRedirect = true;
    if (options ~= nil) then 
      if (options.method ~= nil) then 
        method = options.method;
      end;
      if (options.headers ~= nil) then 
        headers = options.headers;
      end;
      if (options.body ~= nil) then 
        body = options.body;
      end;
      if (options.client ~= nil) then 
        type = options.client;
      end;
      if (options.followRedirect == false) then 
        followRedirect = false;
      end;
    end;
    local client = __tink_http_Fetch.getClient(type, url.scheme == "https");
    if ((options ~= nil) and (options.augment ~= nil)) then 
      local pipeline = options.augment;
      client = __tink_http__Client_CustomClient.create(client, pipeline.before, pipeline.after);
    end;
    client:request(__tink_http_OutgoingRequest.new(__tink_http_OutgoingRequestHeader.new(method, url, nil, headers), body)):handle(function(res) 
      local tmp = res[1];
      if (tmp) == 0 then 
        local res1 = res[2];
        local _g = res1.header.statusCode;
        local _g1 = _g;
        if (_g1) == 301 or (_g1) == 302 or (_g1) == 303 or (_g1) == 307 or (_g1) == 308 then 
          local code = _g;
          if (followRedirect) then 
            local res2 = res1.header;
            local this1 = __lua_lib_luautf8_Utf8.lower("location");
            __tink_core__Promise_Promise_Impl_.next(__tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(res2:byName(this1))), function(location) 
              local this2 = __tink__Url_Url_Impl_.resolve(url, __tink__Url_Url_Impl_.fromString(location));
              local this3;
              if (code == 303) then 
                local __ret = _hx_o({__fields__={method=true},method="GET"});
                local _g2 = options.augment;
                if (_g2 ~= nil) then 
                  local v = _g2;
                  __ret.augment = v;
                end;
                local _g11 = options.body;
                if (_g11 ~= nil) then 
                  local v1 = _g11;
                  __ret.body = v1;
                end;
                local _g21 = options.client;
                if (_g21 ~= nil) then 
                  local v2 = _g21;
                  __ret.client = v2;
                end;
                local _g3 = options.followRedirect;
                if (_g3 ~= nil) then 
                  local v3 = _g3;
                  __ret.followRedirect = v3;
                end;
                local _g4 = options.headers;
                if (_g4 ~= nil) then 
                  local v4 = _g4;
                  __ret.headers = v4;
                end;
                this3 = __ret;
              else
                this3 = options;
              end;
              do return __tink_http_Fetch.fetch(this2, this3) end;
            end):handle(cb);
          else
            cb(__tink_core_Outcome.Success(res1));
          end;else
        cb(__tink_core_Outcome.Success(res1)); end;
      elseif (tmp) == 1 then 
        local e = res[2];
        cb(__tink_core_Outcome.Failure(e)); end;
    end);
  end) end;
end
__tink_http_Fetch.getClient = function(type,secure) 
  local cache = (function() 
    local _hx_1
    if (secure) then 
    _hx_1 = __tink_http_Fetch.sclient; else 
    _hx_1 = __tink_http_Fetch.client; end
    return _hx_1
  end )();
  if (not cache:exists(type)) then 
    local c;
    local c1 = type[1];
    if (c1) == 0 then 
      c = (function() 
        local _hx_2
        if (secure) then 
        _hx_2 = __tink_http_clients_SecureSocketClient.new(); else 
        _hx_2 = __tink_http_clients_SocketClient.new(); end
        return _hx_2
      end )();
    elseif (c1) == 1 then 
      local c2 = type[2];
      c = __tink_http_clients_LocalContainerClient.new(c2);
    elseif (c1) == 2 then 
      c = (function() 
        local _hx_3
        if (secure) then 
        _hx_3 = __tink_http_clients_SecureCurlClient.new(); else 
        _hx_3 = __tink_http_clients_CurlClient.new(); end
        return _hx_3
      end )();
    elseif (c1) == 3 then 
      c = (function() 
        local _hx_4
        if (secure) then 
        _hx_4 = __tink_http_clients_StdClient.new(); else 
        _hx_4 = __tink_http_clients_StdClient.new(); end
        return _hx_4
      end )();
    elseif (c1) == 4 then 
      local c3 = type[2];
      c = c3; end;
    cache:set(type, c);
  end;
  do return cache:get(type) end;
end
_hxClasses["tink.http.ClientType"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Default","Local","Curl","StdLib","Custom"},5)}
__tink_http_ClientType = _hxClasses["tink.http.ClientType"];
__tink_http_ClientType.Default = _hx_tab_array({[0]="Default",0,__enum__ = __tink_http_ClientType},2)

__tink_http_ClientType.Local = function(container) local _x = _hx_tab_array({[0]="Local",1,container,__enum__=__tink_http_ClientType}, 3); return _x; end 
__tink_http_ClientType.Curl = _hx_tab_array({[0]="Curl",2,__enum__ = __tink_http_ClientType},2)

__tink_http_ClientType.StdLib = _hx_tab_array({[0]="StdLib",3,__enum__ = __tink_http_ClientType},2)

__tink_http_ClientType.Custom = function(v) local _x = _hx_tab_array({[0]="Custom",4,v,__enum__=__tink_http_ClientType}, 3); return _x; end 

__tink_http__Fetch_FetchResponse_Impl_.new = {}
__tink_http__Fetch_FetchResponse_Impl_.__name__ = true
__tink_http__Fetch_FetchResponse_Impl_.all = function(this1) 
  do return __tink_core__Promise_Promise_Impl_.next(this1, function(r) 
    do return __tink_core__Promise_Promise_Impl_.next(__tink_io_RealSourceTools.all(r.body), function(chunk) 
      if (r.header.statusCode >= 400) then 
        do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(__tink_core_Outcome.Failure(__tink_core_TypedError.withData(r.header.statusCode, r.header.reason, chunk:toString(), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="tink/http/Fetch.hx",lineNumber=138,className="tink.http._Fetch.FetchResponse_Impl_",methodName="all"}))))) end;
      else
        do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(__tink_core_Outcome.Success(__tink_http_Message.new(r.header, chunk)))) end;
      end;
    end) end;
  end) end;
end

__tink_http_HandlerObject.new = {}
__tink_http_HandlerObject.__name__ = true
__tink_http_HandlerObject.prototype = _hx_a();
__tink_http_HandlerObject.prototype.process= nil;

__tink_http_HandlerObject.prototype.__class__ =  __tink_http_HandlerObject

__tink_http_Header.new = function(fields) 
  local self = _hx_new(__tink_http_Header.prototype)
  __tink_http_Header.super(self,fields)
  return self
end
__tink_http_Header.super = function(self,fields) 
  local tmp;
  if (fields == nil) then 
    tmp = _hx_tab_array({}, 0);
  else
    local v = fields;
    tmp = v;
  end;
  self.fields = tmp;
end
__tink_http_Header.__name__ = true
__tink_http_Header.prototype = _hx_a();
__tink_http_Header.prototype.fields= nil;
__tink_http_Header.prototype.get = function(self,name) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self.fields;
  while (_g1 < _g2.length) do 
    local f = _g2[_g1];
    _g1 = _g1 + 1;
    if (f.name == name) then 
      _g:push(f.value);
    end;
  end;
  do return _g end
end
__tink_http_Header.prototype.byName = function(self,name) 
  local _g = self:get(name);
  local _g1 = _g.length;
  if (_g1) == 0 then 
    do return __tink_core_Outcome.Failure(__tink_core_TypedError.new(422, Std.string(Std.string("No ") .. Std.string(name)) .. Std.string(" header found"), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="tink/http/Header.hx",lineNumber=91,className="tink.http.Header",methodName="byName"}))) end;
  elseif (_g1) == 1 then 
    local v = _g[0];
    do return __tink_core_Outcome.Success(v) end;else
  local v1 = _g;
  do return __tink_core_Outcome.Failure(__tink_core_TypedError.new(422, Std.string(Std.string("Multiple entries for ") .. Std.string(name)) .. Std.string(" header"), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="tink/http/Header.hx",lineNumber=95,className="tink.http.Header",methodName="byName"}))) end; end;
end
__tink_http_Header.prototype.getContentLength = function(self) 
  local _g = self:byName("content-length");
  local tmp = _g[1];
  if (tmp) == 0 then 
    local _hx_tmp = Std.parseInt(_g[2]);
    if (_hx_tmp == nil) then 
      do return __tink_core_Outcome.Failure(__tink_core_TypedError.new(422, "Invalid Content-Length Header", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="tink/http/Header.hx",lineNumber=120,className="tink.http.Header",methodName="getContentLength"}))) end;
    else
      local v = _hx_tmp;
      do return __tink_core_Outcome.Success(v) end;
    end;
  elseif (tmp) == 1 then 
    local e = _g[2];
    do return __tink_core_Outcome.Failure(e) end; end;
end
__tink_http_Header.prototype.toString = function(self) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self.fields;
  while (_g1 < _g2.length) do 
    local f = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(f:toString());
  end;
  do return Std.string(Std.string(_g:join("\r\n")) .. Std.string("\r\n")) .. Std.string("\r\n") end
end

__tink_http_Header.prototype.__class__ =  __tink_http_Header

__tink_http__Header_HeaderValue_Impl_.new = {}
__tink_http__Header_HeaderValue_Impl_.__name__ = true
__tink_http__Header_HeaderValue_Impl_.ofInt = function(i) 
  do return Std.string(i) end;
end

__tink_http_HeaderField.new = function(name,value) 
  local self = _hx_new(__tink_http_HeaderField.prototype)
  __tink_http_HeaderField.super(self,name,value)
  return self
end
__tink_http_HeaderField.super = function(self,name,value) 
  __tink_core_NamedWith.super(self,name,value);
end
__tink_http_HeaderField.__name__ = true
__tink_http_HeaderField.ofString = function(s) 
  local startIndex = nil;
  if (startIndex == nil) then 
    startIndex = 1;
  else
    startIndex = startIndex + 1;
  end;
  local r = __lua_lib_luautf8_Utf8.find(s, ":", startIndex, true);
  local _g = (function() 
    local _hx_1
    if ((r ~= nil) and (r > 0)) then 
    _hx_1 = r - 1; else 
    _hx_1 = -1; end
    return _hx_1
  end )();
  if (_g == -1) then 
    local this1 = __lua_lib_luautf8_Utf8.lower(s);
    do return __tink_http_HeaderField.new(this1, nil) end;
  else
    local v = _g;
    local pos = 0;
    local len = v;
    if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(s)))) then 
      len = __lua_lib_luautf8_Utf8.len(s);
    else
      if (len < 0) then 
        len = __lua_lib_luautf8_Utf8.len(s) + len;
      end;
    end;
    if (pos < 0) then 
      pos = __lua_lib_luautf8_Utf8.len(s) + pos;
    end;
    if (pos < 0) then 
      pos = 0;
    end;
    local name = __lua_lib_luautf8_Utf8.sub(s, pos + 1, pos + len);
    local this2 = __lua_lib_luautf8_Utf8.lower(name);
    local pos1 = v + 1;
    local len1 = nil;
    if ((len1 == nil) or (len1 > (pos1 + __lua_lib_luautf8_Utf8.len(s)))) then 
      len1 = __lua_lib_luautf8_Utf8.len(s);
    else
      if (len1 < 0) then 
        len1 = __lua_lib_luautf8_Utf8.len(s) + len1;
      end;
    end;
    if (pos1 < 0) then 
      pos1 = __lua_lib_luautf8_Utf8.len(s) + pos1;
    end;
    if (pos1 < 0) then 
      pos1 = 0;
    end;
    do return __tink_http_HeaderField.new(this2, StringTools.trim(__lua_lib_luautf8_Utf8.sub(s, pos1 + 1, pos1 + len1))) end;
  end;
end
__tink_http_HeaderField.prototype = _hx_a();
__tink_http_HeaderField.prototype.toString = function(self) 
  if (self.value == nil) then 
    do return self.name end;
  else
    do return Std.string(Std.string(Std.string("") .. Std.string(self.name)) .. Std.string(": ")) .. Std.string(self.value) end;
  end;
end

__tink_http_HeaderField.prototype.__class__ =  __tink_http_HeaderField
__tink_http_HeaderField.__super__ = __tink_core_NamedWith
setmetatable(__tink_http_HeaderField.prototype,{__index=__tink_core_NamedWith.prototype})

__tink_io_BytewiseParser.new = {}
__tink_io_BytewiseParser.__name__ = true
__tink_io_BytewiseParser.__interfaces__ = {__tink_io_StreamParserObject}
__tink_io_BytewiseParser.prototype = _hx_a();
__tink_io_BytewiseParser.prototype.read = function(self,char) 
  _G.error("abstract",0);
end
__tink_io_BytewiseParser.prototype.progress = function(self,cursor) 
  while (true) do 
    local _g = self:read(cursor.currentByte);
    local tmp = _g[1];
    if (tmp) == 0 then 
    elseif (tmp) == 1 then 
      local r = _g[2];
      cursor:next();
      do return __tink_io_ParseStep.Done(r) end;
    elseif (tmp) == 2 then 
      local e = _g[2];
      do return __tink_io_ParseStep.Failed(e) end; end;
    if (not cursor:next()) then 
      break;
    end;
  end;
  do return __tink_io_ParseStep.Progressed end
end
__tink_io_BytewiseParser.prototype.eof = function(self,rest) 
  local _g = self:read(-1);
  local tmp = _g[1];
  if (tmp) == 0 then 
    do return __tink_core_Outcome.Failure(__tink_core_TypedError.new(422, "Unexpected end of input", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="tink/io/StreamParser.hx",lineNumber=180,className="tink.io.BytewiseParser",methodName="eof"}))) end;
  elseif (tmp) == 1 then 
    local r = _g[2];
    do return __tink_core_Outcome.Success(r) end;
  elseif (tmp) == 2 then 
    local e = _g[2];
    do return __tink_core_Outcome.Failure(e) end; end;
end

__tink_io_BytewiseParser.prototype.__class__ =  __tink_io_BytewiseParser
_hxClasses["tink.io.ParseStep"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Progressed","Done","Failed"},3)}
__tink_io_ParseStep = _hxClasses["tink.io.ParseStep"];
__tink_io_ParseStep.Progressed = _hx_tab_array({[0]="Progressed",0,__enum__ = __tink_io_ParseStep},2)

__tink_io_ParseStep.Done = function(r) local _x = _hx_tab_array({[0]="Done",1,r,__enum__=__tink_io_ParseStep}, 3); return _x; end 
__tink_io_ParseStep.Failed = function(e) local _x = _hx_tab_array({[0]="Failed",2,e,__enum__=__tink_io_ParseStep}, 3); return _x; end 

__tink_http_HeaderParser.new = function(makeHeader) 
  local self = _hx_new(__tink_http_HeaderParser.prototype)
  __tink_http_HeaderParser.super(self,makeHeader)
  return self
end
__tink_http_HeaderParser.super = function(self,makeHeader) 
  self.last = -1;
  self.buf = StringBuf.new();
  self.makeHeader = _hx_funcToField(makeHeader);
end
__tink_http_HeaderParser.__name__ = true
__tink_http_HeaderParser.prototype = _hx_a();
__tink_http_HeaderParser.prototype.header= nil;
__tink_http_HeaderParser.prototype.fields= nil;
__tink_http_HeaderParser.prototype.buf= nil;
__tink_http_HeaderParser.prototype.last= nil;
__tink_http_HeaderParser.prototype.makeHeader= nil;
__tink_http_HeaderParser.prototype.read = function(self,c) 
  local _g = self.last;
  local c1 = c;
  if (c1) == -1 then 
    do return self:nextLine() end;
  elseif (c1) == 10 then 
    if (_g == 13) then 
      do return self:nextLine() end;
    else
      local other = c;
      self.last = other;
      local _this = self.buf;
      _G.table.insert(_this.b, __lua_lib_luautf8_Utf8.char(other));
      local _this1 = _this;
      _this1.length = _this1.length + 1;
      do return __tink_io_ParseStep.Progressed end;
    end;
  elseif (c1) == 13 then 
    if (_g == 13) then 
      local _this2 = self.buf;
      _G.table.insert(_this2.b, __lua_lib_luautf8_Utf8.char(self.last));
      local _this3 = _this2;
      _this3.length = _this3.length + 1;
      do return __tink_io_ParseStep.Progressed end;
    else
      self.last = 13;
      do return __tink_io_ParseStep.Progressed end;
    end;else
  if (_g == 13) then 
    local other1 = c;
    local _this4 = self.buf;
    _G.table.insert(_this4.b, __lua_lib_luautf8_Utf8.char(self.last));
    local _this5 = _this4;
    _this5.length = _this5.length + 1;
    local _this6 = self.buf;
    _G.table.insert(_this6.b, __lua_lib_luautf8_Utf8.char(other1));
    local _this7 = _this6;
    _this7.length = _this7.length + 1;
    self.last = -1;
    do return __tink_io_ParseStep.Progressed end;
  else
    local other2 = c;
    self.last = other2;
    local _this8 = self.buf;
    _G.table.insert(_this8.b, __lua_lib_luautf8_Utf8.char(other2));
    local _this9 = _this8;
    _this9.length = _this9.length + 1;
    do return __tink_io_ParseStep.Progressed end;
  end; end;
end
__tink_http_HeaderParser.prototype.nextLine = function(self) 
  local line = _G.table.concat(self.buf.b);
  self.buf = StringBuf.new();
  self.last = -1;
  if (line == "") then 
    if (self.header == nil) then 
      do return __tink_io_ParseStep.Progressed end;
    else
      do return __tink_io_ParseStep.Done(self.header) end;
    end;
  else
    if (self.header == nil) then 
      local _g = self:makeHeader(line, (function() 
      self.fields = _hx_tab_array({}, 0); return self.fields end)());
      local tmp = _g[1];
      if (tmp) == 0 then 
        local _g1 = _g[2];
        if (_g1 == nil) then 
          do return __tink_io_ParseStep.Done((function() 
          self.header = nil; return self.header end)()) end;
        else
          local v = _g1;
          self.header = v;
          do return __tink_io_ParseStep.Progressed end;
        end;
      elseif (tmp) == 1 then 
        local e = _g[2];
        do return __tink_io_ParseStep.Failed(e) end; end;
    else
      self.fields:push(__tink_http_HeaderField.ofString(line));
      do return __tink_io_ParseStep.Progressed end;
    end;
  end;
end

__tink_http_HeaderParser.prototype.__class__ =  __tink_http_HeaderParser
__tink_http_HeaderParser.__super__ = __tink_io_BytewiseParser
setmetatable(__tink_http_HeaderParser.prototype,{__index=__tink_io_BytewiseParser.prototype})

__tink_http_Message.new = function(header,body) 
  local self = _hx_new(__tink_http_Message.prototype)
  __tink_http_Message.super(self,header,body)
  return self
end
__tink_http_Message.super = function(self,header,body) 
  self.header = header;
  self.body = body;
end
__tink_http_Message.__name__ = true
__tink_http_Message.prototype = _hx_a();
__tink_http_Message.prototype.header= nil;
__tink_http_Message.prototype.body= nil;

__tink_http_Message.prototype.__class__ =  __tink_http_Message

__tink_http_RequestHeader.new = function(method,url,protocol,fields) 
  local self = _hx_new(__tink_http_RequestHeader.prototype)
  __tink_http_RequestHeader.super(self,method,url,protocol,fields)
  return self
end
__tink_http_RequestHeader.super = function(self,method,url,protocol,fields) 
  if (protocol == nil) then 
    protocol = "HTTP/1.1";
  end;
  self.method = method;
  self.url = url;
  self.protocol = protocol;
  __tink_http_Header.super(self,fields);
end
__tink_http_RequestHeader.__name__ = true
__tink_http_RequestHeader.prototype = _hx_a();
__tink_http_RequestHeader.prototype.method= nil;
__tink_http_RequestHeader.prototype.url= nil;
__tink_http_RequestHeader.prototype.protocol= nil;
__tink_http_RequestHeader.prototype.toString = function(self) 
  local this1 = self.url;
  do return Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string("") .. Std.string(self.method)) .. Std.string(" ")) .. Std.string(((function() 
    local _hx_1
    if (this1.query == nil) then 
    _hx_1 = this1.path; else 
    _hx_1 = Std.string(Std.string(this1.path) .. Std.string("?")) .. Std.string(this1.query); end
    return _hx_1
  end )()))) .. Std.string(" ")) .. Std.string(self.protocol)) .. Std.string("\r\n")) .. Std.string(__tink_http_Header.prototype.toString(self)) end
end

__tink_http_RequestHeader.prototype.__class__ =  __tink_http_RequestHeader
__tink_http_RequestHeader.__super__ = __tink_http_Header
setmetatable(__tink_http_RequestHeader.prototype,{__index=__tink_http_Header.prototype})

__tink_http_IncomingRequestHeader.new = function(method,url,protocol,fields) 
  local self = _hx_new(__tink_http_IncomingRequestHeader.prototype)
  __tink_http_IncomingRequestHeader.super(self,method,url,protocol,fields)
  return self
end
__tink_http_IncomingRequestHeader.super = function(self,method,url,protocol,fields) 
  __tink_http_RequestHeader.super(self,method,url,protocol,fields);
end
__tink_http_IncomingRequestHeader.__name__ = true
__tink_http_IncomingRequestHeader.prototype = _hx_a();

__tink_http_IncomingRequestHeader.prototype.__class__ =  __tink_http_IncomingRequestHeader
__tink_http_IncomingRequestHeader.__super__ = __tink_http_RequestHeader
setmetatable(__tink_http_IncomingRequestHeader.prototype,{__index=__tink_http_RequestHeader.prototype})

__tink_http_OutgoingRequestHeader.new = function(method,url,protocol,fields) 
  local self = _hx_new(__tink_http_OutgoingRequestHeader.prototype)
  __tink_http_OutgoingRequestHeader.super(self,method,url,protocol,fields)
  return self
end
__tink_http_OutgoingRequestHeader.super = function(self,method,url,protocol,fields) 
  __tink_http_RequestHeader.super(self,method,url,protocol,fields);
end
__tink_http_OutgoingRequestHeader.__name__ = true
__tink_http_OutgoingRequestHeader.prototype = _hx_a();
__tink_http_OutgoingRequestHeader.prototype.concat = function(self,fields) 
  do return __tink_http_OutgoingRequestHeader.new(self.method, self.url, self.protocol, self.fields:concat(fields)) end
end

__tink_http_OutgoingRequestHeader.prototype.__class__ =  __tink_http_OutgoingRequestHeader
__tink_http_OutgoingRequestHeader.__super__ = __tink_http_RequestHeader
setmetatable(__tink_http_OutgoingRequestHeader.prototype,{__index=__tink_http_RequestHeader.prototype})

__tink_http_OutgoingRequest.new = function(header,body) 
  local self = _hx_new(__tink_http_OutgoingRequest.prototype)
  __tink_http_OutgoingRequest.super(self,header,body)
  return self
end
__tink_http_OutgoingRequest.super = function(self,header,body) 
  __tink_http_Message.super(self,header,body);
end
__tink_http_OutgoingRequest.__name__ = true
__tink_http_OutgoingRequest.prototype = _hx_a();

__tink_http_OutgoingRequest.prototype.__class__ =  __tink_http_OutgoingRequest
__tink_http_OutgoingRequest.__super__ = __tink_http_Message
setmetatable(__tink_http_OutgoingRequest.prototype,{__index=__tink_http_Message.prototype})

__tink_http_IncomingRequest.new = function(clientIp,header,body) 
  local self = _hx_new(__tink_http_IncomingRequest.prototype)
  __tink_http_IncomingRequest.super(self,clientIp,header,body)
  return self
end
__tink_http_IncomingRequest.super = function(self,clientIp,header,body) 
  self.clientIp = clientIp;
  __tink_http_Message.super(self,header,body);
end
__tink_http_IncomingRequest.__name__ = true
__tink_http_IncomingRequest.prototype = _hx_a();
__tink_http_IncomingRequest.prototype.clientIp= nil;

__tink_http_IncomingRequest.prototype.__class__ =  __tink_http_IncomingRequest
__tink_http_IncomingRequest.__super__ = __tink_http_Message
setmetatable(__tink_http_IncomingRequest.prototype,{__index=__tink_http_Message.prototype})
_hxClasses["tink.http.IncomingRequestBody"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Plain","Parsed"},2)}
__tink_http_IncomingRequestBody = _hxClasses["tink.http.IncomingRequestBody"];
__tink_http_IncomingRequestBody.Plain = function(source) local _x = _hx_tab_array({[0]="Plain",0,source,__enum__=__tink_http_IncomingRequestBody}, 3); return _x; end 
__tink_http_IncomingRequestBody.Parsed = function(parts) local _x = _hx_tab_array({[0]="Parsed",1,parts,__enum__=__tink_http_IncomingRequestBody}, 3); return _x; end 

__tink_http_ResponseHeaderBase.new = function(statusCode,reason,fields,protocol) 
  local self = _hx_new(__tink_http_ResponseHeaderBase.prototype)
  __tink_http_ResponseHeaderBase.super(self,statusCode,reason,fields,protocol)
  return self
end
__tink_http_ResponseHeaderBase.super = function(self,statusCode,reason,fields,protocol) 
  if (protocol == nil) then 
    protocol = "HTTP/1.1";
  end;
  self.statusCode = statusCode;
  local tmp;
  if (reason == nil) then 
    local this1 = __httpstatus__HttpStatusMessage_HttpStatusMessage_Impl_.fromCode(statusCode);
    tmp = this1;
  else
    tmp = reason;
  end;
  self.reason = tmp;
  self.protocol = protocol;
  __tink_http_Header.super(self,fields);
end
__tink_http_ResponseHeaderBase.__name__ = true
__tink_http_ResponseHeaderBase.parser = function() 
  do return __tink_http_HeaderParser.new(function(line,headers) 
    local idx = 1;
    local ret = _hx_tab_array({}, 0);
    local delim_offset = (function() 
      local _hx_1
      if (__lua_lib_luautf8_Utf8.len(" ") > 0) then 
      _hx_1 = __lua_lib_luautf8_Utf8.len(" "); else 
      _hx_1 = 1; end
      return _hx_1
    end )();
    while (idx ~= nil) do 
      local newidx = 0;
      if (__lua_lib_luautf8_Utf8.len(" ") > 0) then 
        newidx = __lua_lib_luautf8_Utf8.find(line, " ", idx, true);
      else
        if (idx >= __lua_lib_luautf8_Utf8.len(line)) then 
          newidx = nil;
        else
          newidx = idx + 1;
        end;
      end;
      if (newidx ~= nil) then 
        local match = __lua_lib_luautf8_Utf8.sub(line, idx, newidx - 1);
        ret:push(match);
        idx = newidx + __lua_lib_luautf8_Utf8.len(" ");
      else
        ret:push(__lua_lib_luautf8_Utf8.sub(line, idx, __lua_lib_luautf8_Utf8.len(line)));
        idx = nil;
      end;
    end;
    local v = ret;
    if (v.length >= 3) then 
      local statusCode = Std.parseInt(v[1]);
      local reason = v:slice(2):join(" ");
      local protocol = v[0];
      if (protocol == nil) then 
        protocol = "HTTP/1.1";
      end;
      local this1 = __tink_http_ResponseHeaderBase.new(statusCode, reason, headers, protocol);
      do return __tink_core_Outcome.Success(this1) end;
    else
      do return __tink_core_Outcome.Failure(__tink_core_TypedError.new(422, "Invalid HTTP response header", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="tink/http/Response.hx",lineNumber=56,className="tink.http.ResponseHeaderBase",methodName="parser"}))) end;
    end;
  end) end;
end
__tink_http_ResponseHeaderBase.prototype = _hx_a();
__tink_http_ResponseHeaderBase.prototype.statusCode= nil;
__tink_http_ResponseHeaderBase.prototype.reason= nil;
__tink_http_ResponseHeaderBase.prototype.protocol= nil;
__tink_http_ResponseHeaderBase.prototype.toString = function(self) 
  do return Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string("") .. Std.string(self.protocol)) .. Std.string(" ")) .. Std.string(self.statusCode)) .. Std.string(" ")) .. Std.string(self.reason)) .. Std.string("\r\n")) .. Std.string(__tink_http_Header.prototype.toString(self)) end
end

__tink_http_ResponseHeaderBase.prototype.__class__ =  __tink_http_ResponseHeaderBase
__tink_http_ResponseHeaderBase.__super__ = __tink_http_Header
setmetatable(__tink_http_ResponseHeaderBase.prototype,{__index=__tink_http_Header.prototype})

__tink_http__Response_OutgoingResponseData.new = function(header,body) 
  local self = _hx_new(__tink_http__Response_OutgoingResponseData.prototype)
  __tink_http__Response_OutgoingResponseData.super(self,header,body)
  return self
end
__tink_http__Response_OutgoingResponseData.super = function(self,header,body) 
  __tink_http_Message.super(self,header,body);
end
__tink_http__Response_OutgoingResponseData.__name__ = true
__tink_http__Response_OutgoingResponseData.prototype = _hx_a();

__tink_http__Response_OutgoingResponseData.prototype.__class__ =  __tink_http__Response_OutgoingResponseData
__tink_http__Response_OutgoingResponseData.__super__ = __tink_http_Message
setmetatable(__tink_http__Response_OutgoingResponseData.prototype,{__index=__tink_http_Message.prototype})

__tink_http_IncomingResponse.new = function(header,body) 
  local self = _hx_new(__tink_http_IncomingResponse.prototype)
  __tink_http_IncomingResponse.super(self,header,body)
  return self
end
__tink_http_IncomingResponse.super = function(self,header,body) 
  __tink_http_Message.super(self,header,body);
end
__tink_http_IncomingResponse.__name__ = true
__tink_http_IncomingResponse.prototype = _hx_a();

__tink_http_IncomingResponse.prototype.__class__ =  __tink_http_IncomingResponse
__tink_http_IncomingResponse.__super__ = __tink_http_Message
setmetatable(__tink_http_IncomingResponse.prototype,{__index=__tink_http_Message.prototype})
_hxClasses["tink.http.BodyPart"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Value","File"},2)}
__tink_http_BodyPart = _hxClasses["tink.http.BodyPart"];
__tink_http_BodyPart.Value = function(v) local _x = _hx_tab_array({[0]="Value",0,v,__enum__=__tink_http_BodyPart}, 3); return _x; end 
__tink_http_BodyPart.File = function(handle) local _x = _hx_tab_array({[0]="File",1,handle,__enum__=__tink_http_BodyPart}, 3); return _x; end 

__tink_http_clients_CurlClient.new = function(curl) 
  local self = _hx_new(__tink_http_clients_CurlClient.prototype)
  __tink_http_clients_CurlClient.super(self,curl)
  return self
end
__tink_http_clients_CurlClient.super = function(self,curl) 
  self.protocol = "http";
  if (curl ~= nil) then 
    self.curl = _hx_funcToField(curl);
  end;
end
__tink_http_clients_CurlClient.__name__ = true
__tink_http_clients_CurlClient.__interfaces__ = {__tink_http_ClientObject}
__tink_http_clients_CurlClient.prototype = _hx_a();
__tink_http_clients_CurlClient.prototype.protocol= nil;
__tink_http_clients_CurlClient.prototype.request = function(self,req) 
  local args = _hx_tab_array({}, 0);
  args:push("-is");
  args:push("-X");
  args:push(req.header.method);
  local _g = req.header.protocol;
  if (_g) == "HTTP/1.0" then 
    args:push("--http1.0");
  elseif (_g) == "HTTP/1.1" then 
    args:push("--http1.1");
  elseif (_g) == "HTTP/2" then 
    args:push("--http2");else end;
  local _gthis = req.header.fields;
  local cur_length = 0;
  local header = _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self) 
    do return cur_length < _gthis.length end;
  end,next=function(self) 
    cur_length = cur_length + 1;
    do return _gthis[cur_length - 1] end;
  end});
  while (header:hasNext()) do 
    local header1 = header:next();
    args:push("-H");
    args:push(Std.string(Std.string(Std.string("") .. Std.string(header1.name)) .. Std.string(": ")) .. Std.string(header1.value));
  end;
  args:push(_hx_wrap_if_string_field(__tink__Url_Url_Impl_,'toString')(req.header.url));
  do return __tink_core__Promise_Promise_Impl_.next(__tink_io_RealSourceTools.parse(self:curl(args, req.body), __tink_http_ResponseHeaderBase.parser()), function(p) 
    do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(__tink_core_Outcome.Success(__tink_http_IncomingResponse.new(p.a, p.b)))) end;
  end) end
end
__tink_http_clients_CurlClient.prototype.curl = function(self,args,body) 
  args:push("--data-binary");
  args:push("@-");
  local process = __sys_io_Process.new("curl", args);
  local sink = __tink_io__Sink_SinkYielding_Impl_.ofOutput("stdin", process.stdin);
  __tink_io__Source_Source_Impl_.pipeTo(body, sink, _hx_o({__fields__={['end']=true},['end']=true})):eager();
  local input = process.stdout;
  local options = nil;
  if (options == nil) then 
    options = _hx_e();
  end;
  local tmp = __tink_io__Worker_Worker_Impl_.ensure(options.worker);
  local _g = options.chunkSize;
  local tmp1;
  if (_g == nil) then 
    tmp1 = 65536;
  else
    local v = _g;
    tmp1 = v;
  end;
  do return __tink_io_std_InputSource.new("stdout", input, tmp, __haxe_io_Bytes.alloc(tmp1), 0) end
end

__tink_http_clients_CurlClient.prototype.__class__ =  __tink_http_clients_CurlClient

__tink_http_clients_LocalContainerClient.new = function(container) 
  local self = _hx_new(__tink_http_clients_LocalContainerClient.prototype)
  __tink_http_clients_LocalContainerClient.super(self,container)
  return self
end
__tink_http_clients_LocalContainerClient.super = function(self,container) 
  self.container = container;
end
__tink_http_clients_LocalContainerClient.__name__ = true
__tink_http_clients_LocalContainerClient.__interfaces__ = {__tink_http_ClientObject}
__tink_http_clients_LocalContainerClient.prototype = _hx_a();
__tink_http_clients_LocalContainerClient.prototype.container= nil;
__tink_http_clients_LocalContainerClient.prototype.request = function(self,req) 
  local this1 = req.header.url;
  do return __tink_core__Future_Future_Impl_.next(self.container:serve(__tink_http_IncomingRequest.new("127.0.0.1", __tink_http_IncomingRequestHeader.new(req.header.method, __tink__Url_Url_Impl_.fromString((function() 
    local _hx_1
    if (this1.query == nil) then 
    _hx_1 = this1.path; else 
    _hx_1 = Std.string(Std.string(this1.path) .. Std.string("?")) .. Std.string(this1.query); end
    return _hx_1
  end )()), "HTTP/1.1", req.header.fields), __tink_http_IncomingRequestBody.Plain(req.body))), function(res) 
    do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(__tink_core_Outcome.Success(__tink_http_IncomingResponse.new(res.header, res.body)))) end;
  end) end
end

__tink_http_clients_LocalContainerClient.prototype.__class__ =  __tink_http_clients_LocalContainerClient

__tink_http_clients_SecureCurlClient.new = function(curl) 
  local self = _hx_new(__tink_http_clients_SecureCurlClient.prototype)
  __tink_http_clients_SecureCurlClient.super(self,curl)
  return self
end
__tink_http_clients_SecureCurlClient.super = function(self,curl) 
  __tink_http_clients_CurlClient.super(self,curl);
  self.protocol = "https";
end
__tink_http_clients_SecureCurlClient.__name__ = true
__tink_http_clients_SecureCurlClient.prototype = _hx_a();

__tink_http_clients_SecureCurlClient.prototype.__class__ =  __tink_http_clients_SecureCurlClient
__tink_http_clients_SecureCurlClient.__super__ = __tink_http_clients_CurlClient
setmetatable(__tink_http_clients_SecureCurlClient.prototype,{__index=__tink_http_clients_CurlClient.prototype})

__tink_http_clients_SocketClient.new = function(worker) 
  local self = _hx_new(__tink_http_clients_SocketClient.prototype)
  __tink_http_clients_SocketClient.super(self,worker)
  return self
end
__tink_http_clients_SocketClient.super = function(self,worker) 
  self.secure = false;
  self.worker = __tink_io__Worker_Worker_Impl_.ensure(worker);
end
__tink_http_clients_SocketClient.__name__ = true
__tink_http_clients_SocketClient.__interfaces__ = {__tink_http_ClientObject}
__tink_http_clients_SocketClient.prototype = _hx_a();
__tink_http_clients_SocketClient.prototype.worker= nil;
__tink_http_clients_SocketClient.prototype.secure= nil;
__tink_http_clients_SocketClient.prototype.request = function(self,req) 
  local _gthis = self;
  do return __tink_core__Future_Future_Impl_.async(function(cb) 
    local addHeaders = function(headers) 
      req = __tink_http_OutgoingRequest.new(req.header:concat(headers), req.body);
    end;
    local req1 = req.header;
    local this1 = __lua_lib_luautf8_Utf8.lower("connection");
    local _g = req1:byName(this1);
    local tmp = _g[1];
    if (tmp) == 0 then 
      local _g1 = _g[2];
      if (__lua_lib_luautf8_Utf8.lower(_g1) ~= "close") then 
        local v = _g1;
        local tmp1 = __tink_core_Outcome.Failure(__tink_core_TypedError.new(nil, Std.string(Std.string("Only \"Connection: Close\" is supported. But specified as \"") .. Std.string(v)) .. Std.string("\""), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="tink/http/clients/SocketClient.hx",lineNumber=33,className="tink.http.clients.SocketClient",methodName="request"})));
        cb(tmp1);
        do return end;
      end;
    elseif (tmp) == 1 then 
      local _g2 = _g[2];
      local this2 = __lua_lib_luautf8_Utf8.lower("connection");
      addHeaders(_hx_tab_array({[0]=__tink_http_HeaderField.new(this2, "close")}, 1)); end;
    local req2 = req.header;
    local this3 = __lua_lib_luautf8_Utf8.lower("host");
    local _g3 = req2:byName(this3);
    local tmp2 = _g3[1];
    if (tmp2) == 0 then 
      local _g4 = _g3[2];
    elseif (tmp2) == 1 then 
      local _g5 = _g3[2];
      local this4 = __lua_lib_luautf8_Utf8.lower("host");
      addHeaders(_hx_tab_array({[0]=__tink_http_HeaderField.new(this4, __tink_url__Host_Host_Impl_.get_name(req.header.url.host))}, 1)); end;
    local socket;
    if (_gthis.secure) then 
      _G.error("Https is only supported with -lib hxssl",0);
    else
      socket = __sys_net_Socket.new();
    end;
    local port;
    local _g6 = __tink_url__Host_Host_Impl_.get_port(req.header.url.host);
    if (_g6 == nil) then 
      port = (function() 
        local _hx_1
        if (_gthis.secure) then 
        _hx_1 = 443; else 
        _hx_1 = 80; end
        return _hx_1
      end )();
    else
      local v1 = _g6;
      port = v1;
    end;
    __tink_io__Worker_Worker_Impl_.work(_gthis.worker, __tink_core__Lazy_LazyFunc.new(function() 
      local tmp3 = __tink_url__Host_Host_Impl_.get_name(req.header.url.host);
      socket:connect(__sys_net_Host.new(tmp3), port);
      do return __tink_core_Noise.Noise end;
    end)):handle(function(_) 
      local sink = __tink_io__Sink_SinkYielding_Impl_.ofOutput(Std.string("Request to ") .. Std.string(_hx_wrap_if_string_field(__tink__Url_Url_Impl_,'toString')(req.header.url)), socket.output, _hx_o({__fields__={worker=true},worker=_gthis.worker}));
      local name = Std.string("Response from ") .. Std.string(_hx_wrap_if_string_field(__tink__Url_Url_Impl_,'toString')(req.header.url));
      local input = socket.input;
      local options = _hx_o({__fields__={worker=true},worker=_gthis.worker});
      if (options == nil) then 
        options = _hx_e();
      end;
      local source = __tink_io__Worker_Worker_Impl_.ensure(options.worker);
      local _g7 = options.chunkSize;
      local source1;
      if (_g7 == nil) then 
        source1 = 65536;
      else
        local v2 = _g7;
        source1 = v2;
      end;
      local source2 = __tink_io_std_InputSource.new(name, input, source, __haxe_io_Bytes.alloc(source1), 0);
      __tink_io__Source_Source_Impl_.pipeTo(req.body:prepend(__tink_streams_Single.new(__tink_core__Lazy_LazyConst.new(__tink_chunk_ByteChunk.of(__haxe_io_Bytes.ofString(req.header:toString()))))), sink):handle(function(r) 
        local tmp4 = r[1];
        if (tmp4) == 0 then 
          local this5 = __tink_http_ResponseHeaderBase.parser();
          __tink_io_RealSourceTools.parse(source2, this5):handle(function(o) 
            local tmp5 = o[1];
            if (tmp5) == 0 then 
              local parsed = o[2];
              local _g71 = parsed.a:getContentLength();
              local tmp6 = _g71[1];
              if (tmp6) == 0 then 
                local len = _g71[2];
                local tmp7 = __tink_core_Outcome.Success(__tink_http_IncomingResponse.new(parsed.a, __tink_io__Source_Source_Impl_.limit(parsed.b, len)));
                cb(tmp7);
              elseif (tmp6) == 1 then 
                local e = _g71[2];
                local tmp8 = __tink_core_Outcome.Failure(__tink_core_TypedError.new(nil, "Chunked encoding is not supported and the content-length header is required.", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="tink/http/clients/SocketClient.hx",lineNumber=74,className="tink.http.clients.SocketClient",methodName="request"})));
                cb(tmp8); end;
            elseif (tmp5) == 1 then 
              local e1 = o[2];
              cb(__tink_core_Outcome.Failure(e1)); end;
          end);
        elseif (tmp4) == 1 then 
          local _g10 = r[3];
          local _g9 = r[2];
          local tmp9 = __tink_core_Outcome.Failure(__tink_core_TypedError.new(nil, "Sink ended unexpectedly", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="tink/http/clients/SocketClient.hx",lineNumber=79,className="tink.http.clients.SocketClient",methodName="request"})));
          cb(tmp9);
        elseif (tmp4) == 2 then 
          local _g8 = r[3];
          local e2 = r[2];
          cb(__tink_core_Outcome.Failure(e2)); end;
      end);
    end);
  end) end
end

__tink_http_clients_SocketClient.prototype.__class__ =  __tink_http_clients_SocketClient

__tink_http_clients_SecureSocketClient.new = function(worker) 
  local self = _hx_new(__tink_http_clients_SecureSocketClient.prototype)
  __tink_http_clients_SecureSocketClient.super(self,worker)
  return self
end
__tink_http_clients_SecureSocketClient.super = function(self,worker) 
  __tink_http_clients_SocketClient.super(self,worker);
  self.secure = true;
end
__tink_http_clients_SecureSocketClient.__name__ = true
__tink_http_clients_SecureSocketClient.prototype = _hx_a();

__tink_http_clients_SecureSocketClient.prototype.__class__ =  __tink_http_clients_SecureSocketClient
__tink_http_clients_SecureSocketClient.__super__ = __tink_http_clients_SocketClient
setmetatable(__tink_http_clients_SecureSocketClient.prototype,{__index=__tink_http_clients_SocketClient.prototype})

__tink_http_clients_StdClient.new = function(worker) 
  local self = _hx_new(__tink_http_clients_StdClient.prototype)
  __tink_http_clients_StdClient.super(self,worker)
  return self
end
__tink_http_clients_StdClient.super = function(self,worker) 
  self.worker = __tink_io__Worker_Worker_Impl_.ensure(worker);
end
__tink_http_clients_StdClient.__name__ = true
__tink_http_clients_StdClient.__interfaces__ = {__tink_http_ClientObject}
__tink_http_clients_StdClient.prototype = _hx_a();
__tink_http_clients_StdClient.prototype.worker= nil;
__tink_http_clients_StdClient.prototype.request = function(self,req) 
  local _gthis = self;
  do return __tink_core__Future_Future_Impl_.async(function(cb) 
    local r = __sys_Http.new(_hx_wrap_if_string_field(__tink__Url_Url_Impl_,'toString')(req.header.url));
    local send = function(post) 
      local code = 200;
      r.onStatus = function(self,c) 
        code = c;
       end;
      local headers = function() 
        local _g = r.responseHeaders;
        if (_g == nil) then 
          do return _hx_tab_array({}, 0) end;
        else
          local v = _g;
          local _g1 = _hx_tab_array({}, 0);
          local name = v:keys();
          while (name:hasNext()) do 
            local name1 = name:next();
            local this1 = __lua_lib_luautf8_Utf8.lower(name1);
            local ret = v.h[name1];
            if (ret == __haxe_ds_StringMap.tnull) then 
              ret = nil;
            end;
            _g1:push(__tink_http_HeaderField.new(this1, ret));
          end;
          do return _g1 end;
        end;
      end;
      r.onError = function(self,msg) 
        if (code == 200) then 
          code = 500;
        end;
        __tink_io__Worker_Worker_Impl_.work(_gthis.worker, __tink_core__Lazy_LazyConst.new(true)):handle(__tink_core__Callback_Callback_Impl_.fromNiladic(function() 
          local send1 = __tink_core_Outcome.Failure(__tink_core_TypedError.new(code, msg, _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="tink/http/clients/StdClient.hx",lineNumber=44,className="tink.http.clients.StdClient",methodName="request"})));
          cb(send1);
        end));
       end;
      r.onData = function(self,data) 
        __tink_io__Worker_Worker_Impl_.work(_gthis.worker, __tink_core__Lazy_LazyConst.new(true)):handle(__tink_core__Callback_Callback_Impl_.fromNiladic(function() 
          local fields = headers();
          local this2 = __tink_http_ResponseHeaderBase.new(code, "OK", fields, "HTTP/1.1");
          local send2 = __tink_core_Outcome.Success(__tink_http_IncomingResponse.new(this2, __tink_streams_Single.new(__tink_core__Lazy_LazyConst.new(__tink_chunk_ByteChunk.of(__haxe_io_Bytes.ofString(data))))));
          cb(send2);
        end));
       end;
      __tink_io__Worker_Worker_Impl_.work(_gthis.worker, __tink_core__Lazy_LazyFunc.new(function() 
        r:request(post);
      end));
    end;
    local _gthis1 = req.header.fields;
    local cur_length = 0;
    local h = _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self) 
      do return cur_length < _gthis1.length end;
    end,next=function(self) 
      cur_length = cur_length + 1;
      do return _gthis1[cur_length - 1] end;
    end});
    while (h:hasNext()) do 
      local h1 = h:next();
      r:setHeader(h1.name, h1.value);
    end;
    local _g2 = req.header.method;
    if (_g2) == "GET" or (_g2) == "HEAD" or (_g2) == "OPTIONS" then 
      send(false);else
    __tink_io_IdealSourceTools.all(req.body):handle(function(bytes) 
      local tmp = bytes:toString();
      r:setPostData(tmp);
      send(true);
    end); end;
  end) end
end

__tink_http_clients_StdClient.prototype.__class__ =  __tink_http_clients_StdClient

__tink_http_containers_LocalContainer.new = function() 
  local self = _hx_new(__tink_http_containers_LocalContainer.prototype)
  __tink_http_containers_LocalContainer.super(self)
  return self
end
__tink_http_containers_LocalContainer.super = function(self) 
end
__tink_http_containers_LocalContainer.__name__ = true
__tink_http_containers_LocalContainer.__interfaces__ = {__tink_http_Container}
__tink_http_containers_LocalContainer.prototype = _hx_a();
__tink_http_containers_LocalContainer.prototype.handler= nil;
__tink_http_containers_LocalContainer.prototype.running= nil;
__tink_http_containers_LocalContainer.prototype.serve = function(self,req) 
  if (not self.running) then 
    local this1 = __tink_http_ResponseHeaderBase.new(503, "Server stopped", _hx_tab_array({}, 0), "HTTP/1.1");
    local this2 = __tink_http__Response_OutgoingResponseData.new(this1, __tink_io__Source_Source_Impl_.EMPTY);
    do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(this2)) end;
  end;
  do return self.handler:process(req) end
end

__tink_http_containers_LocalContainer.prototype.__class__ =  __tink_http_containers_LocalContainer
_hxClasses["tink.io.PipeResult"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="AllWritten","SinkEnded","SinkFailed","SourceFailed"},4)}
__tink_io_PipeResult = _hxClasses["tink.io.PipeResult"];
__tink_io_PipeResult.AllWritten = _hx_tab_array({[0]="AllWritten",0,__enum__ = __tink_io_PipeResult},2)

__tink_io_PipeResult.SinkEnded = function(result,rest) local _x = _hx_tab_array({[0]="SinkEnded",1,result,rest,__enum__=__tink_io_PipeResult}, 4); return _x; end 
__tink_io_PipeResult.SinkFailed = function(e,rest) local _x = _hx_tab_array({[0]="SinkFailed",2,e,rest,__enum__=__tink_io_PipeResult}, 4); return _x; end 
__tink_io_PipeResult.SourceFailed = function(e) local _x = _hx_tab_array({[0]="SourceFailed",3,e,__enum__=__tink_io_PipeResult}, 3); return _x; end 

__tink_io_PipeResultTools.new = {}
__tink_io_PipeResultTools.__name__ = true
__tink_io_PipeResultTools.toResult = function(c,result,buffered) 
  local mk = function(s) 
    if (buffered == nil) then 
      do return s end;
    else
      local v = buffered;
      do return s:prepend(__tink_streams_Single.new(__tink_core__Lazy_LazyConst.new(v))) end;
    end;
  end;
  local tmp = c[1];
  if (tmp) == 0 then 
    local rest = c[2];
    do return __tink_io_PipeResult.SinkEnded(result, mk(rest)) end;
  elseif (tmp) == 1 then 
    local rest1 = c[3];
    local e = c[2];
    do return __tink_io_PipeResult.SinkFailed(e, mk(rest1)) end;
  elseif (tmp) == 2 then 
    local e1 = c[2];
    do return __tink_io_PipeResult.SourceFailed(e1) end;
  elseif (tmp) == 3 then 
    do return __tink_io_PipeResult.AllWritten end; end;
end

__tink_io_SinkObject.new = {}
__tink_io_SinkObject.__name__ = true
__tink_io_SinkObject.prototype = _hx_a();
__tink_io_SinkObject.prototype.consume= nil;

__tink_io_SinkObject.prototype.__class__ =  __tink_io_SinkObject

__tink_io_SinkBase.new = {}
__tink_io_SinkBase.__name__ = true
__tink_io_SinkBase.__interfaces__ = {__tink_io_SinkObject}
__tink_io_SinkBase.prototype = _hx_a();
__tink_io_SinkBase.prototype.consume = function(self,source,options) 
  _G.error("not implemented",0);
end

__tink_io_SinkBase.prototype.__class__ =  __tink_io_SinkBase

__tink_io__Sink_SinkYielding_Impl_.new = {}
__tink_io__Sink_SinkYielding_Impl_.__name__ = true
__tink_io__Sink_SinkYielding_Impl_.ofOutput = function(name,target,options) 
  local tmp;
  if (options == nil) then 
    tmp = __tink_io__Worker_Worker_Impl_.get();
  else
    local _g = options.worker;
    if (_g == nil) then 
      tmp = __tink_io__Worker_Worker_Impl_.get();
    else
      local w = _g;
      tmp = w;
    end;
  end;
  do return __tink_io_std_OutputSink.new(name, target, tmp) end;
end

__tink_streams_StreamObject.new = {}
__tink_streams_StreamObject.__name__ = true
__tink_streams_StreamObject.prototype = _hx_a();
__tink_streams_StreamObject.prototype.get_depleted= nil;
__tink_streams_StreamObject.prototype.regroup= nil;
__tink_streams_StreamObject.prototype.prepend= nil;
__tink_streams_StreamObject.prototype.decompose= nil;
__tink_streams_StreamObject.prototype.forEach= nil;
__tink_streams_StreamObject.prototype.reduce= nil;

__tink_streams_StreamObject.prototype.__class__ =  __tink_streams_StreamObject

__tink_streams_StreamBase.new = function() 
  local self = _hx_new(__tink_streams_StreamBase.prototype)
  __tink_streams_StreamBase.super(self)
  return self
end
__tink_streams_StreamBase.super = function(self) 
end
__tink_streams_StreamBase.__name__ = true
__tink_streams_StreamBase.__interfaces__ = {__tink_streams_StreamObject}
__tink_streams_StreamBase.prototype = _hx_a();
__tink_streams_StreamBase.prototype.get_depleted = function(self) 
  do return false end
end
__tink_streams_StreamBase.prototype.regroup = function(self,f) 
  do return __tink_streams__Stream_RegroupStream.new(self, f) end
end
__tink_streams_StreamBase.prototype.prepend = function(self,other) 
  if (self:get_depleted()) then 
    do return other end;
  else
    do return __tink_streams__Stream_CompoundStream.of(_hx_tab_array({[0]=other, self}, 2)) end;
  end;
end
__tink_streams_StreamBase.prototype.decompose = function(self,into) 
  if (not self:get_depleted()) then 
    into:push(self);
  end;
end
__tink_streams_StreamBase.prototype.reduce = function(self,initial,reducer) 
  local _gthis = self;
  do return __tink_core__Future_Future_Impl_.async(function(cb) 
    _gthis:forEach(__tink_streams__Stream_Handler_Impl_.ofUnknown(function(item) 
      local ret = reducer(initial, item):map(function(o) 
        local ret1 = o[1];
        if (ret1) == 0 then 
          local v = o[2];
          initial = v;
          do return __tink_streams_Handled.Resume end;
        elseif (ret1) == 1 then 
          local e = o[2];
          do return __tink_streams_Handled.Clog(e) end; end;
      end);
      do return ret:gather() end;
    end)):handle(function(c) 
      local tmp = c[1];
      if (tmp) == 0 then 
        local _g3 = c[2];
        _G.error("assert",0);
      elseif (tmp) == 1 then 
        local rest = c[3];
        local e1 = c[2];
        cb(__tink_streams_Reduction.Crashed(e1, rest));
      elseif (tmp) == 2 then 
        local e2 = c[2];
        cb(__tink_streams_Reduction.Failed(e2));
      elseif (tmp) == 3 then 
        cb(__tink_streams_Reduction.Reduced(initial)); end;
    end);
  end, true) end
end
__tink_streams_StreamBase.prototype.forEach = function(self,handler) 
  _G.error("not implemented",0);
end

__tink_streams_StreamBase.prototype.__class__ =  __tink_streams_StreamBase

__tink_streams_Empty.new = function() 
  local self = _hx_new(__tink_streams_Empty.prototype)
  __tink_streams_Empty.super(self)
  return self
end
__tink_streams_Empty.super = function(self) 
  __tink_streams_StreamBase.super(self);
end
__tink_streams_Empty.__name__ = true
__tink_streams_Empty.make = function() 
  do return __tink_streams_Empty.inst end;
end
__tink_streams_Empty.prototype = _hx_a();
__tink_streams_Empty.prototype.get_depleted = function(self) 
  do return true end
end
__tink_streams_Empty.prototype.forEach = function(self,handler) 
  do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(__tink_streams_Conclusion.Depleted)) end
end

__tink_streams_Empty.prototype.__class__ =  __tink_streams_Empty
__tink_streams_Empty.__super__ = __tink_streams_StreamBase
setmetatable(__tink_streams_Empty.prototype,{__index=__tink_streams_StreamBase.prototype})

__tink_io__Source_Source_Impl_.new = {}
__tink_io__Source_Source_Impl_.__name__ = true
__tink_io__Source_Source_Impl_.concatAll = function(s) 
  do return s:reduce(__tink__Chunk_Chunk_Impl_.EMPTY, __tink_streams__Stream_Reducer_Impl_.ofSafe(function(res,cur) 
    do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(__tink_streams_ReductionStep.Progress(__tink__Chunk_Chunk_Impl_.catChunk(res, cur)))) end;
  end)) end;
end
__tink_io__Source_Source_Impl_.pipeTo = function(this1,target,options) 
  do return target:consume(this1, options) end;
end
__tink_io__Source_Source_Impl_.limit = function(this1,len) 
  if (len == 0) then 
    do return __tink_io__Source_Source_Impl_.EMPTY end;
  end;
  do return this1:regroup(__tink_streams__Stream_Regrouper_Impl_.ofIgnoranceSync(function(chunks) 
    if (len <= 0) then 
      do return __tink_streams_RegroupResult.Terminated(__haxe_ds_Option.None) end;
    end;
    local chunk = chunks[0];
    local length = chunk:getLength();
    local out = (function() 
      local _hx_1
      if (len == length) then 
      _hx_1 = __tink_streams_RegroupResult.Terminated(__haxe_ds_Option.Some(__tink_streams__Stream_Stream_Impl_.single(chunk))); else 
      _hx_1 = __tink_streams_RegroupResult.Converted(__tink_streams__Stream_Stream_Impl_.single((function() 
        local _hx_2
        if (len < length) then 
        _hx_2 = chunk:slice(0, len); else 
        _hx_2 = chunk; end
        return _hx_2
      end )())); end
      return _hx_1
    end )();
    len = len - length;
    do return out end;
  end)) end;
end

__tink_io_RealSourceTools.new = {}
__tink_io_RealSourceTools.__name__ = true
__tink_io_RealSourceTools.all = function(s) 
  local ret = __tink_io__Source_Source_Impl_.concatAll(s):map(function(o) 
    local ret1 = o[1];
    if (ret1) == 1 then 
      local e = o[2];
      do return __tink_core_Outcome.Failure(e) end;
    elseif (ret1) == 2 then 
      local c = o[2];
      do return __tink_core_Outcome.Success(c) end; end;
  end);
  do return ret:gather() end;
end
__tink_io_RealSourceTools.parse = function(s,p) 
  local ret = __tink_io__StreamParser_StreamParser_Impl_.parse(s, p):map(function(r) 
    local ret1 = r[1];
    if (ret1) == 0 then 
      local rest = r[3];
      local data = r[2];
      local this1 = __tink_core_MPair.new(data, rest);
      do return __tink_core_Outcome.Success(this1) end;
    elseif (ret1) == 1 then 
      local _g1 = r[3];
      local e = r[2];
      do return __tink_core_Outcome.Failure(e) end;
    elseif (ret1) == 2 then 
      local e1 = r[2];
      do return __tink_core_Outcome.Failure(e1) end; end;
  end);
  do return ret:gather() end;
end

__tink_io_IdealSourceTools.new = {}
__tink_io_IdealSourceTools.__name__ = true
__tink_io_IdealSourceTools.all = function(s) 
  local ret = __tink_io__Source_Source_Impl_.concatAll(s):map(function(o) 
    local c = o[2];
    do return c end;
  end);
  do return ret:gather() end;
end
_hxClasses["tink.io.ParseResult"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Parsed","Invalid","Broke"},3)}
__tink_io_ParseResult = _hxClasses["tink.io.ParseResult"];
__tink_io_ParseResult.Parsed = function(data,rest) local _x = _hx_tab_array({[0]="Parsed",0,data,rest,__enum__=__tink_io_ParseResult}, 4); return _x; end 
__tink_io_ParseResult.Invalid = function(e,rest) local _x = _hx_tab_array({[0]="Invalid",1,e,rest,__enum__=__tink_io_ParseResult}, 4); return _x; end 
__tink_io_ParseResult.Broke = function(e) local _x = _hx_tab_array({[0]="Broke",2,e,__enum__=__tink_io_ParseResult}, 3); return _x; end 

__tink_io__StreamParser_StreamParser_Impl_.new = {}
__tink_io__StreamParser_StreamParser_Impl_.__name__ = true
__tink_io__StreamParser_StreamParser_Impl_.doParse = function(source,p,consume,finish) 
  local cursor = __tink__Chunk_Chunk_Impl_.EMPTY:getCursor();
  local resume = true;
  local mk = function(source1) 
    if (cursor.currentPos < cursor.length) then 
      do return source1:prepend(__tink_streams_Single.new(__tink_core__Lazy_LazyConst.new(cursor:right()))) end;
    else
      do return source1 end;
    end;
  end;
  local flush = function() 
    local _g = cursor:flush();
    local c = _g;
    if (c:getLength() == 0) then 
      do return __tink_io__Source_Source_Impl_.EMPTY end;
    else
      local c1 = _g;
      do return __tink_streams_Single.new(__tink_core__Lazy_LazyConst.new(c1)) end;
    end;
  end;
  local ret = source:forEach(__tink_streams__Stream_Handler_Impl_.ofUnknown(function(chunk) 
    if (chunk:getLength() == 0) then 
      do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(__tink_streams_Handled.Resume)) end;
    end;
    cursor:shift(chunk);
    do return __tink_core__Future_Future_Impl_.async(function(cb) 
      local next = nil;
      next = function() 
        cursor:shift();
        local lastPos = cursor.currentPos;
        local _g1 = p:progress(cursor);
        local next1 = _g1[1];
        if (next1) == 0 then 
          if ((lastPos ~= cursor.currentPos) and (cursor.currentPos < cursor.length)) then 
            next();
          else
            cb(__tink_streams_Handled.Resume);
          end;
        elseif (next1) == 1 then 
          local v = _g1[2];
          consume(v):handle(function(o) 
            resume = o.resume;
            if (resume) then 
              if ((lastPos ~= cursor.currentPos) and (cursor.currentPos < cursor.length)) then 
                next();
              else
                cb(__tink_streams_Handled.Resume);
              end;
            else
              cb(__tink_streams_Handled.Finish);
            end;
          end);
        elseif (next1) == 2 then 
          local e = _g1[2];
          cb(__tink_streams_Handled.Clog(e)); end;
      end;
      next();
    end) end;
  end)):flatMap(function(c2) 
    local ret1 = c2[1];
    if (ret1) == 0 then 
      local rest = c2[2];
      do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(__tink_io_ParseResult.Parsed(finish(), mk(rest)))) end;
    elseif (ret1) == 1 then 
      local rest1 = c2[3];
      local e1 = c2[2];
      do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(__tink_io_ParseResult.Invalid(e1, mk(rest1)))) end;
    elseif (ret1) == 2 then 
      local e2 = c2[2];
      do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(__tink_io_ParseResult.Broke(e2))) end;
    elseif (ret1) == 3 then 
      if (cursor.currentPos < cursor.length) then 
        local v1 = finish();
        local v2 = __tink_streams_Single.new(__tink_core__Lazy_LazyConst.new(__tink__Chunk_Chunk_Impl_.EMPTY));
        do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(__tink_io_ParseResult.Parsed(v1, mk(v2)))) end;
      else
        if (not resume) then 
          do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(__tink_io_ParseResult.Parsed(finish(), flush()))) end;
        else
          local _g2 = p:eof(cursor);
          local ret2 = _g2[1];
          if (ret2) == 0 then 
            local result = _g2[2];
            local ret3 = consume(result):map(function(_) 
              do return __tink_io_ParseResult.Parsed(finish(), flush()) end;
            end);
            do return ret3:gather() end;
          elseif (ret2) == 1 then 
            local e3 = _g2[2];
            do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(__tink_io_ParseResult.Invalid(e3, flush()))) end; end;
        end;
      end; end;
  end);
  do return ret:gather() end;
end
__tink_io__StreamParser_StreamParser_Impl_.parse = function(s,p) 
  local res = nil;
  local onResult = function(r) 
    res = r;
    do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(_hx_o({__fields__={resume=true},resume=false}))) end;
  end;
  do return __tink_io__StreamParser_StreamParser_Impl_.doParse(s, p, onResult, function() 
    do return res end;
  end) end;
end

__tink_io_WorkerObject.new = {}
__tink_io_WorkerObject.__name__ = true
__tink_io_WorkerObject.prototype = _hx_a();
__tink_io_WorkerObject.prototype.work= nil;

__tink_io_WorkerObject.prototype.__class__ =  __tink_io_WorkerObject

__tink_io__Worker_EagerWorker.new = function() 
  local self = _hx_new(__tink_io__Worker_EagerWorker.prototype)
  __tink_io__Worker_EagerWorker.super(self)
  return self
end
__tink_io__Worker_EagerWorker.super = function(self) 
end
__tink_io__Worker_EagerWorker.__name__ = true
__tink_io__Worker_EagerWorker.__interfaces__ = {__tink_io_WorkerObject}
__tink_io__Worker_EagerWorker.prototype = _hx_a();
__tink_io__Worker_EagerWorker.prototype.work = function(self,task) 
  do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(task:get())) end
end

__tink_io__Worker_EagerWorker.prototype.__class__ =  __tink_io__Worker_EagerWorker

__tink_io__Worker_Worker_Impl_.new = {}
__tink_io__Worker_Worker_Impl_.__name__ = true
__tink_io__Worker_Worker_Impl_.ensure = function(this1) 
  if (this1 == nil) then 
    do return __tink_io__Worker_Worker_Impl_.get() end;
  else
    do return this1 end;
  end;
end
__tink_io__Worker_Worker_Impl_.get = function() 
  do return __tink_io__Worker_Worker_Impl_.pool[Std.random(__tink_io__Worker_Worker_Impl_.pool.length)] end;
end
__tink_io__Worker_Worker_Impl_.work = function(this1,task) 
  do return this1:work(task) end;
end

__tink_streams_Generator.new = function(upcoming) 
  local self = _hx_new(__tink_streams_Generator.prototype)
  __tink_streams_Generator.super(self,upcoming)
  return self
end
__tink_streams_Generator.super = function(self,upcoming) 
  __tink_streams_StreamBase.super(self);
  self.upcoming = upcoming;
end
__tink_streams_Generator.__name__ = true
__tink_streams_Generator.prototype = _hx_a();
__tink_streams_Generator.prototype.upcoming= nil;
__tink_streams_Generator.prototype.forEach = function(self,handler) 
  local _gthis = self;
  do return __tink_core__Future_Future_Impl_.async(function(cb) 
    _gthis.upcoming:handle(function(e) 
      local tmp = e[1];
      if (tmp) == 0 then 
        local _then = e[3];
        local v = e[2];
        handler(v):handle(function(s) 
          local tmp1 = s[1];
          if (tmp1) == 0 then 
            cb(__tink_streams_Conclusion.Halted(_gthis));
          elseif (tmp1) == 1 then 
            cb(__tink_streams_Conclusion.Halted(_then));
          elseif (tmp1) == 2 then 
            _then:forEach(handler):handle(cb);
          elseif (tmp1) == 3 then 
            local e1 = s[2];
            cb(__tink_streams_Conclusion.Clogged(e1, _gthis)); end;
        end);
      elseif (tmp) == 1 then 
        local e2 = e[2];
        cb(__tink_streams_Conclusion.Failed(e2));
      elseif (tmp) == 2 then 
        cb(__tink_streams_Conclusion.Depleted); end;
    end);
  end, true) end
end

__tink_streams_Generator.prototype.__class__ =  __tink_streams_Generator
__tink_streams_Generator.__super__ = __tink_streams_StreamBase
setmetatable(__tink_streams_Generator.prototype,{__index=__tink_streams_StreamBase.prototype})

__tink_io_std_InputSource.new = function(name,target,worker,buf,offset) 
  local self = _hx_new(__tink_io_std_InputSource.prototype)
  __tink_io_std_InputSource.super(self,name,target,worker,buf,offset)
  return self
end
__tink_io_std_InputSource.super = function(self,name,target,worker,buf,offset) 
  local next = function(buf1,offset1) 
    do return __tink_io_std_InputSource.new(name, target, worker, buf1, offset1) end;
  end;
  local free = buf.length - offset;
  __tink_streams_Generator.super(self,__tink_core__Future_Future_Impl_.async(function(cb) 
    __tink_io__Worker_Worker_Impl_.work(worker, __tink_core__Lazy_LazyFunc.new(function() 
      local _hx_status, _hx_result = pcall(function() 
      
          local read = target:readBytes(buf, offset, free);
          if (read == 0) then 
            do return __tink_streams_Step.Link(__tink__Chunk_Chunk_Impl_.EMPTY, next(buf, offset)) end;
          else
            local nextOffset = (function() 
              local _hx_1
              if ((free - read) < 1024) then 
              _hx_1 = 0; else 
              _hx_1 = offset + read; end
              return _hx_1
            end )();
            local nextBuf = (function() 
              local _hx_2
              if (nextOffset == 0) then 
              _hx_2 = __haxe_io_Bytes.alloc(buf.length); else 
              _hx_2 = buf; end
              return _hx_2
            end )();
            do return __tink_streams_Step.Link(__tink_chunk_ByteChunk.of(buf):slice(offset, offset + read), next(nextBuf, nextOffset)) end;
          end;
        return _hx_pcall_default
      end)
      if not _hx_status and _hx_result == "_hx_pcall_break" then
      elseif not _hx_status then 
      
        local _hx_3 = _hx_result
        if( __lua_Boot.__instanceof(_hx_3,__haxe_io_Eof) ) then 
          local e = _hx_3
          do return __tink_streams_Step.End end;
        elseif( __lua_Boot.__instanceof(_hx_3,__haxe_io_Error) ) then 
          local e1 = _hx_3
          if (e1[1] == 0) then 
            do return __tink_streams_Step.Link(__tink__Chunk_Chunk_Impl_.EMPTY, next(buf, offset)) end;
          else
            do return __tink_streams_Step.Fail(__tink_core_TypedError.withData(nil, Std.string("Failed to read from ") .. Std.string(name), e1, _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="tink/io/std/InputSource.hx",lineNumber=50,className="tink.io.std.InputSource",methodName="new"}))) end;
          end;
        else _G.error(_hx_3)
        end
      elseif _hx_result ~= _hx_pcall_default then
        return _hx_result
      end;
    end)):handle(function(step) 
      local tmp = step[1];
      if (tmp) == 1 then 
        local _g = step[2];
        local _hx_status, _hx_result = pcall(function() 
        
            target:close();
          return _hx_pcall_default
        end)
        if not _hx_status and _hx_result == "_hx_pcall_break" then
        elseif not _hx_status then 
        
          local _hx_4 = _hx_result
          local e2 = _hx_4
        elseif _hx_result ~= _hx_pcall_default then
          return _hx_result
        end;
      elseif (tmp) == 2 then 
        local _hx_status, _hx_result = pcall(function() 
        
            target:close();
          return _hx_pcall_default
        end)
        if not _hx_status and _hx_result == "_hx_pcall_break" then
        elseif not _hx_status then 
        
          local _hx_5 = _hx_result
          local e3 = _hx_5
        elseif _hx_result ~= _hx_pcall_default then
          return _hx_result
        end;else end;
      cb(step);
    end);
  end, true));
end
__tink_io_std_InputSource.__name__ = true
__tink_io_std_InputSource.prototype = _hx_a();

__tink_io_std_InputSource.prototype.__class__ =  __tink_io_std_InputSource
__tink_io_std_InputSource.__super__ = __tink_streams_Generator
setmetatable(__tink_io_std_InputSource.prototype,{__index=__tink_streams_Generator.prototype})

__tink_io_std_OutputSink.new = function(name,target,worker) 
  local self = _hx_new(__tink_io_std_OutputSink.prototype)
  __tink_io_std_OutputSink.super(self,name,target,worker)
  return self
end
__tink_io_std_OutputSink.super = function(self,name,target,worker) 
  self.name = name;
  self.target = target;
  self.worker = worker;
end
__tink_io_std_OutputSink.__name__ = true
__tink_io_std_OutputSink.prototype = _hx_a();
__tink_io_std_OutputSink.prototype.name= nil;
__tink_io_std_OutputSink.prototype.target= nil;
__tink_io_std_OutputSink.prototype.worker= nil;
__tink_io_std_OutputSink.prototype.consume = function(self,source,options) 
  local _gthis = self;
  local rest = __tink__Chunk_Chunk_Impl_.EMPTY;
  local ret = source:forEach(__tink_streams__Stream_Handler_Impl_.ofUnknown(function(c) 
    do return __tink_core__Future_Future_Impl_.async(function(cb) 
      local pos = 0;
      local bytes = c:toBytes();
      local write = nil;
      write = function() 
        if (pos == bytes.length) then 
          cb(__tink_streams_Handled.Resume);
        else
          __tink_io__Worker_Worker_Impl_.work(_gthis.worker, __tink_core__Lazy_LazyFunc.new(function() 
            local _hx_status, _hx_result = pcall(function() 
            
                do return __tink_core_Outcome.Success(_gthis.target:writeBytes(bytes, pos, bytes.length - pos)) end;
              return _hx_pcall_default
            end)
            if not _hx_status and _hx_result == "_hx_pcall_break" then
            elseif not _hx_status then 
            
              local _hx_1 = _hx_result
              if( __lua_Boot.__instanceof(_hx_1,__haxe_io_Eof) ) then 
                local e = _hx_1
                do return __tink_core_Outcome.Success(-1) end;
              elseif( __lua_Boot.__instanceof(_hx_1,__haxe_io_Error) ) then 
                local e1 = _hx_1
                if (e1[1] == 0) then 
                  do return __tink_core_Outcome.Success(0) end;
                else
                  do return __tink_core_Outcome.Failure(__tink_core_TypedError.withData(nil, Std.string("Error writing to ") .. Std.string(_gthis.name), e1, _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="tink/io/std/OutputSink.hx",lineNumber=40,className="tink.io.std.OutputSink",methodName="consume"}))) end;
                end;
              elseif( __lua_Boot.__instanceof(_hx_1,__tink_core_TypedError) ) then 
                local e2 = _hx_1
                do return __tink_core_Outcome.Failure(e2) end;
              else
              local e3 = _hx_1
              do return __tink_core_Outcome.Failure(__tink_core_TypedError.withData(nil, Std.string("Error writing to ") .. Std.string(_gthis.name), e3, _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="tink/io/std/OutputSink.hx",lineNumber=46,className="tink.io.std.OutputSink",methodName="consume"}))) end;
               end 
            elseif _hx_result ~= _hx_pcall_default then
              return _hx_result
            end;
          end)):handle(function(o) 
            local write1 = o[1];
            if (write1) == 0 then 
              local _g = o[2];
              if (_g == -1) then 
                rest = __tink_chunk_ByteChunk.of(bytes):slice(pos, bytes.length);
                cb(__tink_streams_Handled.Finish);
              else
                local v = _g;
                pos = pos + v;
                if (pos == bytes.length) then 
                  cb(__tink_streams_Handled.Resume);
                else
                  write();
                end;
              end;
            elseif (write1) == 1 then 
              local e4 = o[2];
              cb(__tink_streams_Handled.Clog(e4)); end;
          end);
        end;
      end;
      write();
    end) end;
  end));
  if ((options ~= nil) and options["end"]) then 
    ret:handle(function(_end) 
      local _hx_status, _hx_result = pcall(function() 
      
          _gthis.target:close();
        return _hx_pcall_default
      end)
      if not _hx_status and _hx_result == "_hx_pcall_break" then
      elseif not _hx_status then 
      
        local _hx_2 = _hx_result
        local e5 = _hx_2
      elseif _hx_result ~= _hx_pcall_default then
        return _hx_result
      end;
    end);
  end;
  local ret1 = ret:map(function(c1) 
    do return __tink_io_PipeResultTools.toResult(c1, __tink_core_Noise.Noise, rest) end;
  end);
  do return ret1:gather() end
end

__tink_io_std_OutputSink.prototype.__class__ =  __tink_io_std_OutputSink
__tink_io_std_OutputSink.__super__ = __tink_io_SinkBase
setmetatable(__tink_io_std_OutputSink.prototype,{__index=__tink_io_SinkBase.prototype})

__tink_streams__Stream_Stream_Impl_.new = {}
__tink_streams__Stream_Stream_Impl_.__name__ = true
__tink_streams__Stream_Stream_Impl_.single = function(i) 
  do return __tink_streams_Single.new(__tink_core__Lazy_LazyConst.new(i)) end;
end
__tink_streams__Stream_Stream_Impl_.flatten = function(f) 
  do return __tink_streams_FutureStream.new(f) end;
end
__tink_streams__Stream_Stream_Impl_.ofError = function(e) 
  do return __tink_streams__Stream_ErrorStream.new(e) end;
end
_hxClasses["tink.streams.RegroupStatus"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Flowing","Errored","Ended"},3)}
__tink_streams_RegroupStatus = _hxClasses["tink.streams.RegroupStatus"];
__tink_streams_RegroupStatus.Flowing = _hx_tab_array({[0]="Flowing",0,__enum__ = __tink_streams_RegroupStatus},2)

__tink_streams_RegroupStatus.Errored = function(e) local _x = _hx_tab_array({[0]="Errored",1,e,__enum__=__tink_streams_RegroupStatus}, 3); return _x; end 
__tink_streams_RegroupStatus.Ended = _hx_tab_array({[0]="Ended",2,__enum__ = __tink_streams_RegroupStatus},2)

_hxClasses["tink.streams.RegroupResult"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Converted","Terminated","Untouched","Errored"},4)}
__tink_streams_RegroupResult = _hxClasses["tink.streams.RegroupResult"];
__tink_streams_RegroupResult.Converted = function(data) local _x = _hx_tab_array({[0]="Converted",0,data,__enum__=__tink_streams_RegroupResult}, 3); return _x; end 
__tink_streams_RegroupResult.Terminated = function(data) local _x = _hx_tab_array({[0]="Terminated",1,data,__enum__=__tink_streams_RegroupResult}, 3); return _x; end 
__tink_streams_RegroupResult.Untouched = _hx_tab_array({[0]="Untouched",2,__enum__ = __tink_streams_RegroupResult},2)

__tink_streams_RegroupResult.Errored = function(e) local _x = _hx_tab_array({[0]="Errored",3,e,__enum__=__tink_streams_RegroupResult}, 3); return _x; end 

__tink_streams__Stream_Regrouper_Impl_.new = {}
__tink_streams__Stream_Regrouper_Impl_.__name__ = true
__tink_streams__Stream_Regrouper_Impl_.ofIgnoranceSync = function(f) 
  do return _hx_o({__fields__={apply=true},apply=function(self,i,_) 
    do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(f(i))) end;
  end}) end;
end

__tink_streams__Stream_CompoundStream.new = function(parts) 
  local self = _hx_new(__tink_streams__Stream_CompoundStream.prototype)
  __tink_streams__Stream_CompoundStream.super(self,parts)
  return self
end
__tink_streams__Stream_CompoundStream.super = function(self,parts) 
  __tink_streams_StreamBase.super(self);
  self.parts = parts;
end
__tink_streams__Stream_CompoundStream.__name__ = true
__tink_streams__Stream_CompoundStream.consumeParts = function(parts,handler,cb) 
  if (parts.length == 0) then 
    cb(__tink_streams_Conclusion.Depleted);
  else
    parts[0]:forEach(handler):handle(function(o) 
      local tmp = o[1];
      if (tmp) == 0 then 
        local rest = o[2];
        local _g = _hx_tab_array({}, 0);
        local _g1 = 0;
        local _g2 = parts;
        while (_g1 < _g2.length) do 
          local i = _g2[_g1];
          _g1 = _g1 + 1;
          _g:push(i);
        end;
        parts = _g;
        parts[0] = rest;
        local tmp1 = __tink_streams_Conclusion.Halted(__tink_streams__Stream_CompoundStream.new(parts));
        cb(tmp1);
      elseif (tmp) == 1 then 
        local at = o[3];
        local e = o[2];
        if (at:get_depleted()) then 
          parts = parts:slice(1);
        else
          local _g3 = _hx_tab_array({}, 0);
          local _g11 = 0;
          local _g21 = parts;
          while (_g11 < _g21.length) do 
            local i1 = _g21[_g11];
            _g11 = _g11 + 1;
            _g3:push(i1);
          end;
          parts = _g3;
          parts[0] = at;
        end;
        local tmp2 = __tink_streams_Conclusion.Clogged(e, __tink_streams__Stream_CompoundStream.new(parts));
        cb(tmp2);
      elseif (tmp) == 2 then 
        local e1 = o[2];
        cb(__tink_streams_Conclusion.Failed(e1));
      elseif (tmp) == 3 then 
        __tink_streams__Stream_CompoundStream.consumeParts(parts:slice(1), handler, cb); end;
    end);
  end;
end
__tink_streams__Stream_CompoundStream.of = function(streams) 
  local ret = _hx_tab_array({}, 0);
  local _g = 0;
  while (_g < streams.length) do 
    local s = streams[_g];
    _g = _g + 1;
    s:decompose(ret);
  end;
  if (ret.length == 0) then 
    do return __tink_streams_Empty.inst end;
  else
    do return __tink_streams__Stream_CompoundStream.new(ret) end;
  end;
end
__tink_streams__Stream_CompoundStream.prototype = _hx_a();
__tink_streams__Stream_CompoundStream.prototype.parts= nil;
__tink_streams__Stream_CompoundStream.prototype.get_depleted = function(self) 
  local _g = self.parts.length;
  if (_g) == 0 then 
    do return true end;
  elseif (_g) == 1 then 
    do return self.parts[0]:get_depleted() end;else
  do return false end; end;
end
__tink_streams__Stream_CompoundStream.prototype.decompose = function(self,into) 
  local _g = 0;
  local _g1 = self.parts;
  while (_g < _g1.length) do 
    local p = _g1[_g];
    _g = _g + 1;
    p:decompose(into);
  end;
end
__tink_streams__Stream_CompoundStream.prototype.forEach = function(self,handler) 
  local parts = self.parts;
  local handler1 = handler;
  do return __tink_core__Future_Future_Impl_.async(function(cb) 
    __tink_streams__Stream_CompoundStream.consumeParts(parts, handler1, cb);
  end) end
end

__tink_streams__Stream_CompoundStream.prototype.__class__ =  __tink_streams__Stream_CompoundStream
__tink_streams__Stream_CompoundStream.__super__ = __tink_streams_StreamBase
setmetatable(__tink_streams__Stream_CompoundStream.prototype,{__index=__tink_streams_StreamBase.prototype})

__tink_streams__Stream_RegroupStream.new = function(source,f,prev) 
  local self = _hx_new(__tink_streams__Stream_RegroupStream.prototype)
  __tink_streams__Stream_RegroupStream.super(self,source,f,prev)
  return self
end
__tink_streams__Stream_RegroupStream.super = function(self,source,f,prev) 
  if (prev == nil) then 
    prev = __tink_streams_Empty.inst;
  end;
  local ret = nil;
  local terminated = false;
  local buf = _hx_tab_array({}, 0);
  local ret1 = source:forEach(__tink_streams__Stream_Handler_Impl_.ofUnknown(function(item) 
    buf:push(item);
    local ret2 = f:apply(buf, __tink_streams_RegroupStatus.Flowing):map(function(o) 
      local ret3 = o[1];
      if (ret3) == 0 then 
        local v = o[2];
        ret = v;
        do return __tink_streams_Handled.Finish end;
      elseif (ret3) == 1 then 
        local v1 = o[2];
        local l = __tink_core__Lazy_LazyFunc.new(__tink_streams_Empty.make);
        if (v1[1] == 0) then 
          local v2 = v1[2];
          ret = v2;
        else
          ret = l:get();
        end;
        terminated = true;
        do return __tink_streams_Handled.Finish end;
      elseif (ret3) == 2 then 
        do return __tink_streams_Handled.Resume end;
      elseif (ret3) == 3 then 
        local e = o[2];
        do return __tink_streams_Handled.Clog(e) end; end;
    end);
    do return ret2:gather() end;
  end)):map(function(o1) 
    local ret4 = o1[1];
    if (ret4) == 0 then 
      if (terminated) then 
        do return ret end;
      else
        local rest = o1[2];
        do return __tink_streams__Stream_RegroupStream.new(rest, f, ret) end;
      end;
    elseif (ret4) == 1 then 
      local rest1 = o1[3];
      local e1 = o1[2];
      do return __tink_streams__Stream_CloggedStream.new(__tink_streams__Stream_Stream_Impl_.ofError(e1), rest1) end;
    elseif (ret4) == 2 then 
      local e2 = o1[2];
      do return __tink_streams__Stream_Stream_Impl_.ofError(e2) end;
    elseif (ret4) == 3 then 
      if (buf.length == 0) then 
        do return __tink_streams_Empty.inst end;
      else
        local ret5 = f:apply(buf, __tink_streams_RegroupStatus.Ended):map(function(o2) 
          local ret6 = o2[1];
          if (ret6) == 0 then 
            local v3 = o2[2];
            do return v3 end;
          elseif (ret6) == 1 then 
            local v4 = o2[2];
            local l1 = __tink_core__Lazy_LazyFunc.new(__tink_streams_Empty.make);
            if (v4[1] == 0) then 
              local v5 = v4[2];
              do return v5 end;
            else
              do return l1:get() end;
            end;
          elseif (ret6) == 2 then 
            do return __tink_streams_Empty.inst end;
          elseif (ret6) == 3 then 
            local e3 = o2[2];
            do return __tink_streams__Stream_Stream_Impl_.ofError(e3) end; end;
        end);
        do return __tink_streams__Stream_Stream_Impl_.flatten(ret5:gather()) end;
      end; end;
  end);
  local next = __tink_streams__Stream_Stream_Impl_.flatten(ret1:gather());
  __tink_streams__Stream_CompoundStream.super(self,_hx_tab_array({[0]=prev, next}, 2));
end
__tink_streams__Stream_RegroupStream.__name__ = true
__tink_streams__Stream_RegroupStream.prototype = _hx_a();

__tink_streams__Stream_RegroupStream.prototype.__class__ =  __tink_streams__Stream_RegroupStream
__tink_streams__Stream_RegroupStream.__super__ = __tink_streams__Stream_CompoundStream
setmetatable(__tink_streams__Stream_RegroupStream.prototype,{__index=__tink_streams__Stream_CompoundStream.prototype})
_hxClasses["tink.streams.Handled"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="BackOff","Finish","Resume","Clog"},4)}
__tink_streams_Handled = _hxClasses["tink.streams.Handled"];
__tink_streams_Handled.BackOff = _hx_tab_array({[0]="BackOff",0,__enum__ = __tink_streams_Handled},2)

__tink_streams_Handled.Finish = _hx_tab_array({[0]="Finish",1,__enum__ = __tink_streams_Handled},2)

__tink_streams_Handled.Resume = _hx_tab_array({[0]="Resume",2,__enum__ = __tink_streams_Handled},2)

__tink_streams_Handled.Clog = function(e) local _x = _hx_tab_array({[0]="Clog",3,e,__enum__=__tink_streams_Handled}, 3); return _x; end 
_hxClasses["tink.streams.Conclusion"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Halted","Clogged","Failed","Depleted"},4)}
__tink_streams_Conclusion = _hxClasses["tink.streams.Conclusion"];
__tink_streams_Conclusion.Halted = function(rest) local _x = _hx_tab_array({[0]="Halted",0,rest,__enum__=__tink_streams_Conclusion}, 3); return _x; end 
__tink_streams_Conclusion.Clogged = function(error,at) local _x = _hx_tab_array({[0]="Clogged",1,error,at,__enum__=__tink_streams_Conclusion}, 4); return _x; end 
__tink_streams_Conclusion.Failed = function(error) local _x = _hx_tab_array({[0]="Failed",2,error,__enum__=__tink_streams_Conclusion}, 3); return _x; end 
__tink_streams_Conclusion.Depleted = _hx_tab_array({[0]="Depleted",3,__enum__ = __tink_streams_Conclusion},2)

_hxClasses["tink.streams.ReductionStep"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Progress","Crash"},2)}
__tink_streams_ReductionStep = _hxClasses["tink.streams.ReductionStep"];
__tink_streams_ReductionStep.Progress = function(result) local _x = _hx_tab_array({[0]="Progress",0,result,__enum__=__tink_streams_ReductionStep}, 3); return _x; end 
__tink_streams_ReductionStep.Crash = function(e) local _x = _hx_tab_array({[0]="Crash",1,e,__enum__=__tink_streams_ReductionStep}, 3); return _x; end 
_hxClasses["tink.streams.Reduction"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Crashed","Failed","Reduced"},3)}
__tink_streams_Reduction = _hxClasses["tink.streams.Reduction"];
__tink_streams_Reduction.Crashed = function(error,at) local _x = _hx_tab_array({[0]="Crashed",0,error,at,__enum__=__tink_streams_Reduction}, 4); return _x; end 
__tink_streams_Reduction.Failed = function(error) local _x = _hx_tab_array({[0]="Failed",1,error,__enum__=__tink_streams_Reduction}, 3); return _x; end 
__tink_streams_Reduction.Reduced = function(result) local _x = _hx_tab_array({[0]="Reduced",2,result,__enum__=__tink_streams_Reduction}, 3); return _x; end 

__tink_streams__Stream_CloggedStream.new = function(rest,error) 
  local self = _hx_new(__tink_streams__Stream_CloggedStream.prototype)
  __tink_streams__Stream_CloggedStream.super(self,rest,error)
  return self
end
__tink_streams__Stream_CloggedStream.super = function(self,rest,error) 
  __tink_streams_StreamBase.super(self);
  self.rest = rest;
  self.error = error;
end
__tink_streams__Stream_CloggedStream.__name__ = true
__tink_streams__Stream_CloggedStream.prototype = _hx_a();
__tink_streams__Stream_CloggedStream.prototype.rest= nil;
__tink_streams__Stream_CloggedStream.prototype.error= nil;
__tink_streams__Stream_CloggedStream.prototype.forEach = function(self,handler) 
  do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(__tink_streams_Conclusion.Clogged(self.error, self.rest))) end
end

__tink_streams__Stream_CloggedStream.prototype.__class__ =  __tink_streams__Stream_CloggedStream
__tink_streams__Stream_CloggedStream.__super__ = __tink_streams_StreamBase
setmetatable(__tink_streams__Stream_CloggedStream.prototype,{__index=__tink_streams_StreamBase.prototype})

__tink_streams__Stream_ErrorStream.new = function(error) 
  local self = _hx_new(__tink_streams__Stream_ErrorStream.prototype)
  __tink_streams__Stream_ErrorStream.super(self,error)
  return self
end
__tink_streams__Stream_ErrorStream.super = function(self,error) 
  __tink_streams_StreamBase.super(self);
  self.error = error;
end
__tink_streams__Stream_ErrorStream.__name__ = true
__tink_streams__Stream_ErrorStream.prototype = _hx_a();
__tink_streams__Stream_ErrorStream.prototype.error= nil;
__tink_streams__Stream_ErrorStream.prototype.forEach = function(self,handler) 
  do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(__tink_streams_Conclusion.Failed(self.error))) end
end

__tink_streams__Stream_ErrorStream.prototype.__class__ =  __tink_streams__Stream_ErrorStream
__tink_streams__Stream_ErrorStream.__super__ = __tink_streams_StreamBase
setmetatable(__tink_streams__Stream_ErrorStream.prototype,{__index=__tink_streams_StreamBase.prototype})

__tink_streams_Single.new = function(value) 
  local self = _hx_new(__tink_streams_Single.prototype)
  __tink_streams_Single.super(self,value)
  return self
end
__tink_streams_Single.super = function(self,value) 
  __tink_streams_StreamBase.super(self);
  self.value = value;
end
__tink_streams_Single.__name__ = true
__tink_streams_Single.prototype = _hx_a();
__tink_streams_Single.prototype.value= nil;
__tink_streams_Single.prototype.forEach = function(self,handle) 
  local _gthis = self;
  local ret = handle(self.value:get()):map(function(step) 
    local ret1 = step[1];
    if (ret1) == 0 then 
      do return __tink_streams_Conclusion.Halted(_gthis) end;
    elseif (ret1) == 1 then 
      do return __tink_streams_Conclusion.Halted(__tink_streams_Empty.inst) end;
    elseif (ret1) == 2 then 
      do return __tink_streams_Conclusion.Depleted end;
    elseif (ret1) == 3 then 
      local e = step[2];
      do return __tink_streams_Conclusion.Clogged(e, _gthis) end; end;
  end);
  do return ret:gather() end
end

__tink_streams_Single.prototype.__class__ =  __tink_streams_Single
__tink_streams_Single.__super__ = __tink_streams_StreamBase
setmetatable(__tink_streams_Single.prototype,{__index=__tink_streams_StreamBase.prototype})

__tink_streams__Stream_Handler_Impl_.new = {}
__tink_streams__Stream_Handler_Impl_.__name__ = true
__tink_streams__Stream_Handler_Impl_.ofUnknown = function(f) 
  local this1 = f;
  do return this1 end;
end

__tink_streams__Stream_Reducer_Impl_.new = {}
__tink_streams__Stream_Reducer_Impl_.__name__ = true
__tink_streams__Stream_Reducer_Impl_.ofSafe = function(f) 
  local this1 = f;
  do return this1 end;
end

__tink_streams_FutureStream.new = function(f) 
  local self = _hx_new(__tink_streams_FutureStream.prototype)
  __tink_streams_FutureStream.super(self,f)
  return self
end
__tink_streams_FutureStream.super = function(self,f) 
  __tink_streams_StreamBase.super(self);
  self.f = f;
end
__tink_streams_FutureStream.__name__ = true
__tink_streams_FutureStream.prototype = _hx_a();
__tink_streams_FutureStream.prototype.f= nil;
__tink_streams_FutureStream.prototype.forEach = function(self,handler) 
  local _gthis = self;
  do return __tink_core__Future_Future_Impl_.async(function(cb) 
    _gthis.f:handle(function(s) 
      s:forEach(handler):handle(cb);
    end);
  end) end
end

__tink_streams_FutureStream.prototype.__class__ =  __tink_streams_FutureStream
__tink_streams_FutureStream.__super__ = __tink_streams_StreamBase
setmetatable(__tink_streams_FutureStream.prototype,{__index=__tink_streams_StreamBase.prototype})
_hxClasses["tink.streams.Step"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Link","Fail","End"},3)}
__tink_streams_Step = _hxClasses["tink.streams.Step"];
__tink_streams_Step.Link = function(value,next) local _x = _hx_tab_array({[0]="Link",0,value,next,__enum__=__tink_streams_Step}, 4); return _x; end 
__tink_streams_Step.Fail = function(e) local _x = _hx_tab_array({[0]="Fail",1,e,__enum__=__tink_streams_Step}, 3); return _x; end 
__tink_streams_Step.End = _hx_tab_array({[0]="End",2,__enum__ = __tink_streams_Step},2)


__tink_url__Host_Host_Impl_.new = {}
__tink_url__Host_Host_Impl_.__name__ = true
__tink_url__Host_Host_Impl_._new = function(name,port) 
  local this1;
  if (port == nil) then 
    this1 = name;
  else
    if ((port > 65535) or (port <= 0)) then 
      _G.error("Invalid port",0);
    else
      this1 = Std.string(Std.string(Std.string("") .. Std.string(name)) .. Std.string(":")) .. Std.string(port);
    end;
  end;
  do return this1 end;
end
__tink_url__Host_Host_Impl_.get_name = function(this1) 
  if (this1 == nil) then 
    do return nil end;
  else
    local idx = 1;
    local ret = _hx_tab_array({}, 0);
    local delim_offset = (function() 
      local _hx_1
      if (__lua_lib_luautf8_Utf8.len("]") > 0) then 
      _hx_1 = __lua_lib_luautf8_Utf8.len("]"); else 
      _hx_1 = 1; end
      return _hx_1
    end )();
    while (idx ~= nil) do 
      local newidx = 0;
      if (__lua_lib_luautf8_Utf8.len("]") > 0) then 
        newidx = __lua_lib_luautf8_Utf8.find(this1, "]", idx, true);
      else
        if (idx >= __lua_lib_luautf8_Utf8.len(this1)) then 
          newidx = nil;
        else
          newidx = idx + 1;
        end;
      end;
      if (newidx ~= nil) then 
        local match = __lua_lib_luautf8_Utf8.sub(this1, idx, newidx - 1);
        ret:push(match);
        idx = newidx + __lua_lib_luautf8_Utf8.len("]");
      else
        ret:push(__lua_lib_luautf8_Utf8.sub(this1, idx, __lua_lib_luautf8_Utf8.len(this1)));
        idx = nil;
      end;
    end;
    local _g = ret;
    local _g1 = _g.length;
    if (_g1) == 1 then 
      local v = _g[0];
      local idx1 = 1;
      local ret1 = _hx_tab_array({}, 0);
      local delim_offset1 = (function() 
        local _hx_2
        if (__lua_lib_luautf8_Utf8.len(":") > 0) then 
        _hx_2 = __lua_lib_luautf8_Utf8.len(":"); else 
        _hx_2 = 1; end
        return _hx_2
      end )();
      while (idx1 ~= nil) do 
        local newidx1 = 0;
        if (__lua_lib_luautf8_Utf8.len(":") > 0) then 
          newidx1 = __lua_lib_luautf8_Utf8.find(v, ":", idx1, true);
        else
          if (idx1 >= __lua_lib_luautf8_Utf8.len(v)) then 
            newidx1 = nil;
          else
            newidx1 = idx1 + 1;
          end;
        end;
        if (newidx1 ~= nil) then 
          local match1 = __lua_lib_luautf8_Utf8.sub(v, idx1, newidx1 - 1);
          ret1:push(match1);
          idx1 = newidx1 + __lua_lib_luautf8_Utf8.len(":");
        else
          ret1:push(__lua_lib_luautf8_Utf8.sub(v, idx1, __lua_lib_luautf8_Utf8.len(v)));
          idx1 = nil;
        end;
      end;
      do return ret1[0] end;
    elseif (_g1) == 2 then 
      local _g3 = _g[1];
      local v1 = _g[0];
      do return Std.string(v1) .. Std.string("]") end;else
    _G.error("assert",0); end;
  end;
end
__tink_url__Host_Host_Impl_.get_port = function(this1) 
  if (this1 == nil) then 
    do return nil end;
  else
    local idx = 1;
    local ret = _hx_tab_array({}, 0);
    local delim_offset = (function() 
      local _hx_1
      if (__lua_lib_luautf8_Utf8.len("]") > 0) then 
      _hx_1 = __lua_lib_luautf8_Utf8.len("]"); else 
      _hx_1 = 1; end
      return _hx_1
    end )();
    while (idx ~= nil) do 
      local newidx = 0;
      if (__lua_lib_luautf8_Utf8.len("]") > 0) then 
        newidx = __lua_lib_luautf8_Utf8.find(this1, "]", idx, true);
      else
        if (idx >= __lua_lib_luautf8_Utf8.len(this1)) then 
          newidx = nil;
        else
          newidx = idx + 1;
        end;
      end;
      if (newidx ~= nil) then 
        local match = __lua_lib_luautf8_Utf8.sub(this1, idx, newidx - 1);
        ret:push(match);
        idx = newidx + __lua_lib_luautf8_Utf8.len("]");
      else
        ret:push(__lua_lib_luautf8_Utf8.sub(this1, idx, __lua_lib_luautf8_Utf8.len(this1)));
        idx = nil;
      end;
    end;
    local _g = ret;
    local _g1 = _g.length;
    if (_g1) == 1 then 
      local v = _g[0];
      local idx1 = 1;
      local ret1 = _hx_tab_array({}, 0);
      local delim_offset1 = (function() 
        local _hx_2
        if (__lua_lib_luautf8_Utf8.len(":") > 0) then 
        _hx_2 = __lua_lib_luautf8_Utf8.len(":"); else 
        _hx_2 = 1; end
        return _hx_2
      end )();
      while (idx1 ~= nil) do 
        local newidx1 = 0;
        if (__lua_lib_luautf8_Utf8.len(":") > 0) then 
          newidx1 = __lua_lib_luautf8_Utf8.find(v, ":", idx1, true);
        else
          if (idx1 >= __lua_lib_luautf8_Utf8.len(v)) then 
            newidx1 = nil;
          else
            newidx1 = idx1 + 1;
          end;
        end;
        if (newidx1 ~= nil) then 
          local match1 = __lua_lib_luautf8_Utf8.sub(v, idx1, newidx1 - 1);
          ret1:push(match1);
          idx1 = newidx1 + __lua_lib_luautf8_Utf8.len(":");
        else
          ret1:push(__lua_lib_luautf8_Utf8.sub(v, idx1, __lua_lib_luautf8_Utf8.len(v)));
          idx1 = nil;
        end;
      end;
      local _g2 = ret1[1];
      if (_g2 == nil) then 
        do return nil end;
      else
        local p = _g2;
        do return Std.parseInt(p) end;
      end;
    elseif (_g1) == 2 then 
      local _g21 = _g[0];
      local v1 = _g[1];
      local idx2 = 1;
      local ret2 = _hx_tab_array({}, 0);
      local delim_offset2 = (function() 
        local _hx_3
        if (__lua_lib_luautf8_Utf8.len(":") > 0) then 
        _hx_3 = __lua_lib_luautf8_Utf8.len(":"); else 
        _hx_3 = 1; end
        return _hx_3
      end )();
      while (idx2 ~= nil) do 
        local newidx2 = 0;
        if (__lua_lib_luautf8_Utf8.len(":") > 0) then 
          newidx2 = __lua_lib_luautf8_Utf8.find(v1, ":", idx2, true);
        else
          if (idx2 >= __lua_lib_luautf8_Utf8.len(v1)) then 
            newidx2 = nil;
          else
            newidx2 = idx2 + 1;
          end;
        end;
        if (newidx2 ~= nil) then 
          local match2 = __lua_lib_luautf8_Utf8.sub(v1, idx2, newidx2 - 1);
          ret2:push(match2);
          idx2 = newidx2 + __lua_lib_luautf8_Utf8.len(":");
        else
          ret2:push(__lua_lib_luautf8_Utf8.sub(v1, idx2, __lua_lib_luautf8_Utf8.len(v1)));
          idx2 = nil;
        end;
      end;
      local _g3 = ret2[1];
      if (_g3 == nil) then 
        do return nil end;
      else
        local p1 = _g3;
        do return Std.parseInt(p1) end;
      end;else
    _G.error("assert",0); end;
  end;
end

__tink_url__Path_Path_Impl_.new = {}
__tink_url__Path_Path_Impl_.__name__ = true
__tink_url__Path_Path_Impl_.join = function(this1,that) 
  if (that == "") then 
    do return this1 end;
  else
    if (__lua_lib_luautf8_Utf8.sub(that, 1, 1) == "/") then 
      do return that end;
    else
      local index = __lua_lib_luautf8_Utf8.len(this1) - 1;
      if (__lua_lib_luautf8_Utf8.sub(this1, index + 1, index + 1) == "/") then 
        do return __tink_url__Path_Path_Impl_.ofString(Std.string(this1) .. Std.string(that)) end;
      else
        local startIndex = nil;
        local ret = -1;
        if (startIndex == nil) then 
          startIndex = __lua_lib_luautf8_Utf8.len(this1);
        end;
        while (true) do 
          local startIndex1 = ret + 1;
          if (startIndex1 == nil) then 
            startIndex1 = 1;
          else
            startIndex1 = startIndex1 + 1;
          end;
          local r = __lua_lib_luautf8_Utf8.find(this1, "/", startIndex1, true);
          local p = (function() 
            local _hx_1
            if ((r ~= nil) and (r > 0)) then 
            _hx_1 = r - 1; else 
            _hx_1 = -1; end
            return _hx_1
          end )();
          if ((p == -1) or (p > startIndex)) then 
            break;
          end;
          ret = p;
        end;
        local _g = ret;
        if (_g == -1) then 
          do return that end;
        else
          local v = _g;
          local pos = 0;
          local len = v + 1;
          if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(this1)))) then 
            len = __lua_lib_luautf8_Utf8.len(this1);
          else
            if (len < 0) then 
              len = __lua_lib_luautf8_Utf8.len(this1) + len;
            end;
          end;
          if (pos < 0) then 
            pos = __lua_lib_luautf8_Utf8.len(this1) + pos;
          end;
          if (pos < 0) then 
            pos = 0;
          end;
          do return __tink_url__Path_Path_Impl_.ofString(Std.string(__lua_lib_luautf8_Utf8.sub(this1, pos + 1, pos + len)) .. Std.string(that)) end;
        end;
      end;
    end;
  end;
end
__tink_url__Path_Path_Impl_.ofString = function(s) 
  local this1 = __tink_url__Path_Path_Impl_.normalize(s);
  do return this1 end;
end
__tink_url__Path_Path_Impl_.normalize = function(s) 
  s = StringTools.trim(StringTools.replace(s, "\\", "/"));
  if (s == ".") then 
    do return "./" end;
  end;
  local isDir = (StringTools.endsWith(s, "/..") or StringTools.endsWith(s, "/")) or StringTools.endsWith(s, "/.");
  local parts = _hx_tab_array({}, 0);
  local isAbsolute = StringTools.startsWith(s, "/");
  local up = 0;
  local _g = 0;
  local idx = 1;
  local ret = _hx_tab_array({}, 0);
  local delim_offset = (function() 
    local _hx_1
    if (__lua_lib_luautf8_Utf8.len("/") > 0) then 
    _hx_1 = __lua_lib_luautf8_Utf8.len("/"); else 
    _hx_1 = 1; end
    return _hx_1
  end )();
  while (idx ~= nil) do 
    local newidx = 0;
    if (__lua_lib_luautf8_Utf8.len("/") > 0) then 
      newidx = __lua_lib_luautf8_Utf8.find(s, "/", idx, true);
    else
      if (idx >= __lua_lib_luautf8_Utf8.len(s)) then 
        newidx = nil;
      else
        newidx = idx + 1;
      end;
    end;
    if (newidx ~= nil) then 
      local match = __lua_lib_luautf8_Utf8.sub(s, idx, newidx - 1);
      ret:push(match);
      idx = newidx + __lua_lib_luautf8_Utf8.len("/");
    else
      ret:push(__lua_lib_luautf8_Utf8.sub(s, idx, __lua_lib_luautf8_Utf8.len(s)));
      idx = nil;
    end;
  end;
  local _g1 = ret;
  while (_g < _g1.length) do 
    local part = _g1[_g];
    _g = _g + 1;
    local _g2 = StringTools.trim(part);
    local _g3 = _g2;
    if (_g3) == "" then 
    elseif (_g3) == "." then 
    elseif (_g3) == ".." then 
      if (parts:pop() == nil) then 
        up = up + 1;
      end;else
    local v = _g2;
    parts:push(v); end;
  end;
  if (isAbsolute) then 
    parts:unshift("");
  else
    local _g21 = 0;
    local _g31 = up;
    while (_g21 < _g31) do 
      _g21 = _g21 + 1;
      local i = _g21 - 1;
      parts:unshift("..");
    end;
  end;
  if (isDir) then 
    parts:push("");
  end;
  do return parts:join("/") end;
end
_hx_bit_clamp = function(v)
  if v <= 2147483647 and v >= -2147483648 then
    if v > 0 then return _G.math.floor(v)
    else return _G.math.ceil(v)
    end
  end
  if v > 2251798999999999 then v = v*2 end;
  if (v ~= v or math.abs(v) == _G.math.huge) then return nil end
  return _hx_bit.band(v, 2147483647 ) - math.abs(_hx_bit.band(v, 2147483648))
end

-- require this for lua 5.1
pcall(require, 'bit')
if bit then
  _hx_bit = bit
else
  local _hx_bit_raw = _G.require('bit32')
  _hx_bit = setmetatable({}, { __index = _hx_bit_raw });
  -- lua 5.2 weirdness
  _hx_bit.bnot = function(...) return _hx_bit_clamp(_hx_bit_raw.bnot(...)) end;
  _hx_bit.bxor = function(...) return _hx_bit_clamp(_hx_bit_raw.bxor(...)) end;
end

_hx_array_mt.__index = Array.prototype

local _hx_static_init = function()
  EReg.FLAGS = __lua_lib_lrexlib_Rex.flags();
  
  __haxe_SysTools.winMetaCharacters = _hx_tab_array({[0]=32, 40, 41, 37, 33, 94, 34, 60, 62, 38, 124, 10, 13, 44, 59}, 15);
  
  __civo_Charges.path = "/charges";
  
  __civo_Dns.path = "/dns";
  
  __civo_Firewalls.path = "/firewalls";
  
  __civo_Instances.path = "/instances";
  
  __civo_Kubernetes.path = "/kubernetes/clusters";
  
  __civo_Kubernetes.apps = "/kubernetes/applications";
  
  __civo_LoadBalancers.path = "/loadbalancers";
  
  __civo_Networks.path = "/networks";
  
  __civo_Quota.path = "/quota";
  
  __civo_Regions.path = "/regions";
  
  __civo_Snapshots.path = "/snapshots";
  
  __civo_Ssh.path = "/sshkeys";
  
  __civo_Templates.path = "/templates";
  
  __civo_Volumes.path = "/volumes";
  
  __civo_Webhooks.path = "/webhooks";
  
  __haxe_EntryPoint.pending = Array.new();
  
  __haxe_EntryPoint.threadCount = 0;
  
  __haxe_ds_StringMap.tnull = ({});
  
  __lua_Boot.MAXSTACKSIZE = 1000;
  
  __lua_Boot.platformBigEndian = _G.string.byte(_G.string.dump(function() 
  end), 7) > 0;
  
  __lua_Boot.hiddenFields = {__id__=true, hx__closures=true, super=true, prototype=true, __fields__=true, __ifields__=true, __class__=true, __properties__=true}
  
  __lua_Boot.os_patterns = (function() 
    local _hx_2
    
    local _g = __haxe_ds_StringMap.new();
    
    local value = _hx_tab_array({[0]="windows", "^mingw", "^cygwin"}, 3);
    if (value == nil) then 
      _g.h.Windows = __haxe_ds_StringMap.tnull;
    else
      _g.h.Windows = value;
    end;
    
    local value1 = _hx_tab_array({[0]="linux"}, 1);
    if (value1 == nil) then 
      _g.h.Linux = __haxe_ds_StringMap.tnull;
    else
      _g.h.Linux = value1;
    end;
    
    local value2 = _hx_tab_array({[0]="mac", "darwin", "osx"}, 3);
    if (value2 == nil) then 
      _g.h.Mac = __haxe_ds_StringMap.tnull;
    else
      _g.h.Mac = value2;
    end;
    
    local value3 = _hx_tab_array({[0]="bsd$"}, 1);
    if (value3 == nil) then 
      _g.h.BSD = __haxe_ds_StringMap.tnull;
    else
      _g.h.BSD = value3;
    end;
    
    local value4 = _hx_tab_array({[0]="SunOS"}, 1);
    if (value4 == nil) then 
      _g.h.Solaris = __haxe_ds_StringMap.tnull;
    else
      _g.h.Solaris = value4;
    end;
    
    _hx_2 = _g;
    return _hx_2
  end )();
  
  __sys_io_Process.argQuote = (function() 
    local _hx_3
    if (Sys.systemName() == "Windows") then 
    _hx_3 = function(x) 
      do return __haxe_SysTools.quoteWinArg(x, true) end;
    end; else 
    _hx_3 = __haxe_SysTools.quoteUnixArg; end
    return _hx_3
  end )();
  
  __sys_io_Process._shell = (function() 
    local _hx_4
    if (Sys.systemName() == "Windows") then 
    _hx_4 = "cmd.exe"; else 
    _hx_4 = "/bin/sh"; end
    return _hx_4
  end )();
  
  __tink__Chunk_EmptyChunk.EMPTY = __haxe_io_Bytes.alloc(0);
  
  __tink__Chunk_Chunk_Impl_.EMPTY = __tink__Chunk_EmptyChunk.new();
  
  __tink_core__Callback_Callback_Impl_.depth = 0;
  
  __tink_http_Fetch.client = __haxe_ds_EnumValueMap.new();
  
  __tink_http_Fetch.sclient = __haxe_ds_EnumValueMap.new();
  
  __tink_streams_Empty.inst = __tink_streams_Empty.new();
  
  __tink_io__Source_Source_Impl_.EMPTY = __tink_streams_Empty.inst;
  
  __tink_io__Worker_Worker_Impl_.EAGER = __tink_io__Worker_EagerWorker.new();
  
  __tink_io__Worker_Worker_Impl_.pool = _hx_tab_array({[0]=__tink_io__Worker_Worker_Impl_.EAGER}, 1);
  
  
  if (__lua_lib_lrexlib_Rex == nil) then 
    _G.error("Rex is missing.  Please install lrexlib-pcre.",0);
  end;
  String.__name__ = true;
  Array.__name__ = true;
end

_hx_bind = function(o,m)
  if m == nil then return nil end;
  local f;
  if o._hx__closures == nil then
    _G.rawset(o, '_hx__closures', {});
  else
    f = o._hx__closures[m];
  end
  if (f == nil) then
    f = function(...) return m(o, ...) end;
    o._hx__closures[m] = f;
  end
  return f;
end

_hx_funcToField = function(f)
  if type(f) == 'function' then
    return function(self,...)
      return f(...)
    end
  else
    return f
  end
end

_G.math.randomseed(_G.os.time());

_hx_box_mr = function(x,nt)
    res = _hx_o({__fields__={}})
    for i,v in ipairs(nt) do
      res[v] = x[i]
    end
    return res
end

_hx_table = {}
_hx_table.pack = _G.table.pack or function(...)
    return {...}
end
_hx_table.unpack = _G.table.unpack or _G.unpack
_hx_table.maxn = _G.table.maxn or function(t)
  local maxn=0;
  for i in pairs(t) do
    maxn=type(i)=='number'and i>maxn and i or maxn
  end
  return maxn
end;

_hx_wrap_if_string_field = function(o, fld)
  if _G.type(o) == 'string' then
    if fld == 'length' then
      return _G.string.len(o)
    else
      return String.prototype[fld]
    end
  else
    return o[fld]
  end
end

_hx_static_init();

  Civo.main();
  __haxe_EntryPoint.run();

return _hx_exports
